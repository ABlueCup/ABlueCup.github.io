{"meta":{"title":"卡而的博客","subtitle":"vim  grunt webpack less bootstrap jqueryUI bower http-server","description":"优雅源自技术的丰富和成熟。","author":"卡而","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-06-07T05:45:29.000Z","updated":"2018-06-07T05:46:17.308Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-06-07T05:48:59.000Z","updated":"2018-06-07T05:49:48.722Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"zhufeng.md","slug":"zhufeng-md","date":"2019-03-13T01:35:00.000Z","updated":"2019-03-20T10:05:43.471Z","comments":true,"path":"2019/03/13/zhufeng-md/","link":"","permalink":"http://yoursite.com/2019/03/13/zhufeng-md/","excerpt":"JavaScript，通常缩写为JS，是一种高级的，解释执行的编程语言。 JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。 它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。","text":"JavaScript，通常缩写为JS，是一种高级的，解释执行的编程语言。 JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。 它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。 JascriptJS: 轻量级的客户端脚本编程语言； 编程语言HTML + CSS是标记语言编程语言是具备一定逻辑的，拥有自己的编程思想（面向对象编程[oop]、 面向过程编程） 面向对象编程 java c++ php c# (.net) js.. 面向过程编程 c.. 目前的Js已经不仅仅是客户端语言了，基于Node可以做服务器端程序，所以js是全栈编程语言 js 包括三部分 ECMAscript（ES） js语法核心 DOM document object model 文档对象模型， 提供各种API供js获取和操作html元素（dom元素） BOM brower object model 浏览器对象模型，提供各种API供js操作浏览器 ECMAScript它是Js的语法规划，JS中的变量、数据类型、语法规范、操作语句、设计模式等等都是ES规定的 变量(variable)定义：它不是具体的值，只是一个用来存储具体值的容器或者代名词 存储的值可以改变，所以称为变量 基于ES语法规范，在js中创建变量有以下规范 - var (ES3) - function (ES3) 创建函数（函数也是变量，只不过存储的值是函数类型而已） - let (ES6) - const (ES6) 创建常量 - import (ES6) 基于ES6的模块规范导出需要的信息 - class (ES6) 基于ES6创建类 123456789101112/** *语法： var [变量名] = 值; / *let [变量名] = 值; / *const [变量名] = 值; *function 函数名()&#123;&#125;**/...var n = 13;n = 15;const m = 100; 创建变量的命名规范 严格区分大小写 遵循驼峰命名法：按照数字、字母、下划线命名，数字不能作为开头，命名基于英文单词，拼写成一个完整的名字（第一个单词字母小写，其余每一个有意义的单词首字母大写） 语义化强一些 不能使用关键字和保留字： 在js中有特殊含义的叫关键字，未来可能成为关键字的叫做保留字 数据值是一门编程语言进行生产的材料。JS中包含的值有一下数据类型： 基本数据类型 （值） 数字 number 字符串 string 布尔值 boolean null undefined 引用数据类型 对象object 普通对象 数组对象 正则对象 日期对象 … 函数 function ES6中新增加的一个特殊的数据类型Symbol(唯一的值) 12345678910111213141516171819202122[基本数据类型] 数字类型中有一个特殊的值，叫 NaN (not a number 代表不是一个有效的数字，但是属于number类型) JS中所有用单引号或者双引号包裹起来的都是字符串，里面的内容是当前字符串中的字符（一个字符串由0到多个字符自称） boolean: true false[引用数据类型]var o=&#123;name: &apos;name&apos;, age: 9&#125; =&gt; 普通对象 由大括号包裹起来，里面包含多组属性名和属性值（包含多组键值对） &#123;&#125; 空对象var array = [1,2,3]; // =&gt; 中括号包裹起来， 包含零到多项内容，这种是数组对象 []空数组var reg = /-?(d|[1-9]\\d+))(\\.\\d+)?/g; /=&gt; 由元字符组成一个完整的正则 //不是空正则 当行注释 ^=^function fn()&#123;&#125;[Symbol] 创建出来的是一个唯一的值 var a = Symbol(&apos;珠峰&apos;); var b = Symbol(&apos;珠峰&apos;); a==b =&gt; false; const a = Symbol(&apos;flag&apos;); a 是唯一且不能改变的量 扩展： JS代码如何运行以及运行后如何输出结果[如何被运行] 把代码运行在浏览器中，浏览器内核来渲染解析； 基于Node来运行（Node也是基于V8引擎渲染和解析JS的工具) [如何输出结果] alert： 在浏览器中通过弹框的方式输出（浏览器提示框）； 12345alert();// =&gt; window.alert()alert(1+1) =&gt; &apos;2&apos; 基于alert输出的结果都会转换成字符串：把值（如果是表达式先计算出结果）通过toString()这个方法转化成字符串，然后再输出alert([12,23]) =&gt; &quot;12,23&quot;alert(&#123;name:&apos;xx&apos;&#125;) =&gt; &apos;[object Object]&apos; 对象.toString()结果是[object Object] confirm 和alert用法一致，只不过提示的框中有确定和取消两个按钮，所以它是确认提示框 123456var flag = confirm(&apos;确定要退出吗&apos;);if(flag)&#123; // 用户点击的是确定按钮&#125;else&#123; //用户点击的取消按钮&#125; prompt 在confirm的基础上增加输入框 console.log :在浏览器控制台输出日志 Elements: 当前页面中的元素和样式在这里都可以看见，还可以调节样式修改结构等； Console: 控制台 可以在JS代码中通过.log输出到这里，也可以在这里直接编写JS代码； Source: 当前网站的源文件都在这里 …… console.dir 比log的输出更详细（尤其是输出对象数据值的时候） console.table: 把一个JSON数据按照表格的方式输出.. (更多的console输出方法) 数据类型的详细剖析number数字类型NaN： not a number， 但它是数字类型isNaN: 检测当前值是否不是有效数字，返回true 代表不是有效数字，返回false代表是有效数字12345678910111213141516171819202122232425262728293031323334isNaN([value])isNaN(&apos;13&apos;) =&gt; falseisNaN(&apos;AA&apos;) =&gt; trueisNaN(true) =&gt; falseisNaN(false) =&gt; falseisNaN(null) =&gt; falseisNaN(undefined) =&gt; trueisNaN(&#123;age:9&#125;) =&gt; trueisNaN([12,23]) =&gt; trueisNaN([12]) =&gt; falseisNaN(/DS/) =&gt; trueisNaN(function()&#123;&#125;) =&gt; true重要： isNaN检测的机制1、首先验证当前要检测的值是否为数字类型的值，如果不是，浏览器会默认的把值转换为数字类型； 把非数字类型转化为数字 -其他基本类型转换为数字： 直接使用Number这个方法； [字符串转化为数字] 如果当前字符串中出现任意一个非有效数字字符，结果为NaN Number(&apos;13&apos;) =&gt; 13 Number(&apos;13a&apos;) =&gt; NaN Number(&apos;13.5&apos;) =&gt; 13.5 可以识别小数点 [布尔转数字] Number(true) =&gt; 1 Number(false) =&gt; 0 [其他] Number(null) =&gt; 0 Number(undefined) =&gt; NaN - 把引用数据类型值转换为数字： 先把引用值调取toString转化为字符串，然后把字符串调取Number转化为数字 Number(&apos;&apos;) =&gt; 0 ([]).toString =&gt; &apos;&apos;; isNaN([]) =&gt; false 2、当前检测的值已经是数字类型，是有效数字返回false,不是返回true (数字类型中只有NaN不是有效数字，其余都是有效数字) parseInt parseFloat 等同于Number,也是为了把其他值转化为数字类型和Number的区别在于字符串转换分析上Number出现任意非有效字符，即为NaNparseInt: 把一个字符串中的整数部分解析出来parseFloat: 把一个字符串中的小数（浮点数）解析出来 123456parseInt(&apos;13.5px&apos;) =&gt; 13parseFloat(&apos;13.5px&apos;) = 13.5parseInt(&apos;w13.5&apos;) =&gt; NaNparseInt从字符串最左边字符开始查找有效数字字符，并且转化为数字，但是一旦遇到非有效数字字符，查找结束parseFloat多识别一个字符. parseFloat(&apos;.2p&apos;) =&gt; 0.2 NaN的比较123(NaN == NaN) =&gt; false NaN和谁都不相等，包括和自己也不相等` 思考题： 有一个变量，存储的值不知道，我想检测它是否为一个有效数字，下面的方案是否可以123if(Number(num) == NaN)&#123; // 条件永远不成立 alert(&quot;num不是有效数字&quot;);&#125; 只有一种方案 123if(isNaN(num))&#123; alert(&quot;num不是有效数字&quot;);&#125; 布尔类型 只有两个值 true/false如何把其他类型转化为布尔类型 Boolean123Boolean(1) =&gt; trueBoolean(0) =&gt; false数字里面只有0和NaN是false,其余都是true ! 1!&apos;st&apos; 非、取反，先把其他数据类型转化为布尔类型，然后取反 !! 1否定之否定，肯定 规律 在js中只有 0 null undefined NaN 空字符串 转化为布尔类型的false,其余都转化为true null &amp; undefined 都代表空null ：空对象指针undefined ：未定义 null 一般是意料之中的没有（通俗理解都是认为手动的设置为null, 后面的程序中我们会再次给它赋值）1var num = null; // =&gt;null 是手动赋值的, 预示着我会把num变量的值修改 undefined 代表着没有，一般都不是人为控制的，大部分都是浏览器自主为空，后面可以赋值，也可以不赋值； 12var num;// 此时num会被浏览器分配一个值 undefined, 后面可以赋值，也可以不赋值 string其他数据类型转化为string类型().toString() 基本数据类型转化为string类型，直接使用引号包裹住字符； 引用类型转化为string类型 function(){} 直接使用引号包裹 普通对象， [object Object] 数组 [] =&gt; ‘’; [12] =&gt; ‘12’; [12,23] =&gt; ‘12, 23’; 正则对象，日期对象，直接使用引号包裹； object对象数据类型分为四类 普通对象特点 - 由大括号包裹起来； - 由0到多组属性名和属性值（键值对）组成； 属性是用来描述当前对象特征的，属性值是对这个特征的描述；(属性：键[key] 属性值：值[value])1234567891011121314151617181920212223242526272829var obj = &#123; name: &apos;kyle&apos;, age: 9&#125;// 对象的操作：对键值对的增删改查[获取] 语法： 对象.属性名 / 对象[属性名]obj.nameobj[&apos;name&apos;] 一般来说属性名都是字符串格式，属性值不固定，任何格式都可以[增/改]js对象中属性名是不允许重复的，是唯一的。obj.name = &apos;xxx&apos;;// 原有对象中存在name属性，此处是修改属性值obj.sex = &apos;man&apos;; // 原对象中不存在sex属性，此处是新增属性obj[&apos;age&apos;] = 12;[删]彻底删除delete obj.age // delete obj[&apos;age&apos;] 对象中不存在age属性了假删除：并没有移除属性，只是让当前属性的值为空obj.sex = null;// obj[&apos;sex] = null;obj.class // undefined;在获取属性值的时候，如果当前对象有这个属性名，可以正常取值(哪怕是null),但是如果没有这个属性名，则获取的值是undefinedvar obj = &#123;name:&apos;kyle&apos;, age: 9&#125;var name = &apos;peng&apos;;obj.name =&gt; &apos;kyle;obj[&apos;name&apos;] =&gt; &apos;kyle&apos;;obj[name] =&gt; undefined; 此处的name是一个变量，我们要获取的并不是属性名叫name,而是储存在name中的值 &apos;peng&apos;; 一个对象中的属性名不仅仅是字符串格式，还有可能是数字格式,遇到其他格式的先转化为字符串格式 123456789// chrome控制台下shift+enter换行var obj = &#123; name: 'kyle', 0:9&#125;// 数字格式用obj[0]和obj['0'],但是不能用obj.0// SyntaxError 语法错误 当我们存储的属性名不是字符串也不是数字格式时，会调用.toString()转化为字符串格式后，再进行存储 null undefined boolean 引用类型都可以先转化为字符串再储存值obj[{}] = 300; obj = {‘[object Object]’:300}, 获取的时候也是先把{}转化为字符串，然后再获取值 数组对象（对象由键值对组成）var oo = {a:12}var ary=[12,23];//=&gt; 12,23都是属性值，属性名呢？通过观察结果：数组对象的属性名是数字，我们把数字属性名成为当前对象的索引。ary[0], ary[‘0’] 数组和对象的关系： 数组是一种特殊的对象，属性名是数字 浅分析js的运行机制1、当浏览器(他的内核/引擎)解析和渲染JS的时候，会提供一个供JS代码运行的环境，我们把这个环境称为全局作用域(global scope);2、代码自上而下执行（之前还有一个变量提升阶段） =&gt;基本数据类型的值会存储在当前作用域下 var a =12; 有三步操作 1）在当前环境下开辟一个空间存储12； 2）声明一个变量名 a; 3) 把声明的变量和值关联起来，赋值操作叫做定义 var b=a; 基本数据类型值也叫值类型，是按照值来操作的：把原有的值复制一份放到新的空间或位置上，和原来的值没有关系. 1) 在当前环境下开辟一个空间存储12； 2） 声明变量 b 3) b 和 12 关联； a 和 b 没有关系； b =23 1) 开辟空间存储13; 2) b和13关联 变量和基本类型数据是一一对应关系； =&gt; 引用数据类型的值不能存储在当前的作用域下，因为可能存储的内容过于复杂，我们需要先开辟一个新的空间，把内容存储到这个空间中 1）开辟一个新的空间，把对象中的键值对依次存储起来（为了保证后面可以找到这个空间，此空间有一个16进制的地址） 2）声明一个变量 3）让变量和空间地址关联在一起（把空间的地址赋值给变量） 引用类型不是按值操作，是按照引用的地址操作：把原来空间的地址赋值给新的变量，但是原来的空间没有被克隆。这样就会出现多个变量关联的是同一个空间，相互之间就会存在影响。 作用域叫栈内存，存储引用类型数据值的叫堆内存栈内存：本身就是供JS代码执行的环境，所有的基本类型值都会直接在栈内存中开辟一个位置；堆内存：独立于栈内存的内存，存储引用类型中的数据值；对象存储的键值对，函数存储的是代码字符串 头脑风暴123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!Doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;style&gt;.box&#123; margin: 20px auto; width:300px;&#125;.box li&#123; line-height: 35px; padding: 0 5px; border-bottom: 1px dash #aaa; text-overflow: ellipsis; white-space: nowrap; overflow: hidden;&#125;.bg0&#123; background-color:pink;&#125;.bg1&#123; background-color:lightGreen;&#125;.bg2&#123; background-color:lightBlue;&#125;.hover&#123; background-color: orange;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=\"box\" id=\"box\"&gt;&lt;li&gt;剴；开放日哦个人头&lt;/li&gt;&lt;li&gt;jk;;;ssd&lt;/li&gt;&lt;li&gt;受到攻击；哦哦人啊个今儿个‘&lt;/li&gt;&lt;li&gt;地方igoerg'e'a'eanj；反对党哦【思伽尔和&lt;/li&gt;&lt;li&gt;让他脚痛医脚他已经对方如何【&gt;&lt;/li&gt;&lt;li&gt;kl;'df 梵蒂冈阿尔贡哦哦人啊个&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;// var oBox = document.getElementById(\"box\");//var oList = oBox.getElementsByTagName(\"li\");//console.log(oList);//var arr = ['red', 'green', 'blue'], n;//for(var i=0;i&lt;oList.length; i++)&#123; /**n = i % 3; oList[i].style.backgroundColor = arr[n];*/ //oList[i].className = 'bg' + i%3; // oList[i].style.backgroundColor = i%3 == 0 ? 'lightBlue' : (i % 3 == 1 ? 'lightGreen': 'red');////&#125;function changeColor()&#123; var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); var arr = ['pink','lightGreen','lightBlue']; for(var i = 0; i&lt;oList.length; i++)&#123; oList[i].style.backgroundColor = arr[i % 3]; //oList[i]. &#125;&#125;function changeColor2()&#123; var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); var arr = ['pink', 'lightBlue', 'lightGreen']; for(var i=0; i&lt; oList.length;i++)&#123; if(!(i % 3))&#123; oList[i].style.backgroundColor='lightBlue'; &#125;else&#123; if(i%3 == true)&#123; oList[i].style.backgroundColor='lightGreen'; &#125;else&#123; oList[i].style.backgroundColor='pink'; &#125; &#125; &#125; &#125;function changeColor3()&#123; // 每次循环一组，但是会出现当前这一组不够三个，这样会报错 var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); for(var i=0;i&lt;oList.length;i+=3)&#123; oList[i].style.backgroundColor = 'red'; // if(i+1 &lt;= oList.length -1;) oList[i+1].style.backgroundColor = 'green'; // if(i+2 &lt;= oList.length - 2) oList[i+2].style.backgroundColor = 'blue'; &#125;&#125; changeColor();/**三种方案：1. 依次遍历每一个Li，通过索引除3的余数，设置当前行的样式；2.*/function highLight()&#123; var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); var arr = ['red', 'green','blue']; var arr1 = ['pink','lightGreen','lightBlue']; var n; for(var i=0;i&lt;oList.length;i++)&#123; //n = i % 3; //console.log(n); oList[i].myIndex = i;// 每一次循环的时候都给每一,个li设置一个自定义属性，属性值存储的是当前li的索引 oList[i].addEventListener('mouseover', function()&#123; // 有回调函数，一般是异步执行，放在任务队列里 this.style.background = arr[this.myIndex % 3]; &#125;); oList[i].addEventListener('mouseout', function()&#123; this.style.background = arr1[this.myIndex % 3]; &#125;);// 绑定方法的时候，还没有执行，存储的是字符串,当循环结束，我们手动去操作li的时候，方法才会才会执行，此时changTab(i)的变量i 已经是3了 &#125;&#125;// css 优先级： 行内，ID，样式类，标签highLight();/***css 我们把hover 放在bg的后面，当元素的class=\"bg hover\"的时候，元素呈现hover的样式鼠标滑过，新增样式类hover,鼠标离开，把新增的样式类移除**/&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS中的数据类型转换JS中的数据类型【基本数据类型】 数字 number 字符转 string boolean null undefined [引用类型数据] 对象 普通对象 数组对象 正则对象 日期对象 数学对象 … 函数 function 真实项目中，根据需求，我们往往需要把数据类型之间进行转换（规则和规则之间是相互独立的） 把其他数据类型转化为number类型1. 发生的情况 isNaN检测的时候，当检测的值不是数字类型，浏览器会自己调用Number方法把它转化为数字类型，然后再检测是否为非数字； 123isNaN('3') =&gt; falseNumber('3') =&gt; 3isNaN(3)=&gt; false 基于parseInt / parseFloat 去手动转化为数字； 数学运算 + - * / (+ 不仅仅是数学运算，还可能是字符串拼接) 1234567893 -1 =&gt; 2Number(3) =&gt; 3'3PX -1' =&gt; NaN'3PX' + 1 =&gt; 3PX1var i = '3';i+1 =&gt; '31'i += 1 =&gt; '31'i++ =&gt; 4 i++就是单纯的数学运算，已经摒弃掉字符串拼接的规则 基于 “==” 比较的时候，有时候也会把其他值转化为数字类型 … 2. 转化规律 //=》 转换的方法： Number(浏览器自行转换都是基于这个方法完成的) 12345678910111213141516【把字符串转化为数字】只要遇到一个非有效数字，结果就是NaN; ''变成数字类型是0' '=&gt; 0;' '=&gt;0;'\\n' =&gt; 0; 换行符（多个空格）'\\t' =&gt; 0; 制表符（一个tab键是四个空格）【布尔类型】true =&gt; 1false =&gt; 0;[把没有转换为数字]null =&gt; 0;undefined =&gt; NaN[引用类型转换为数字]首先转换为字符串（toString()）,然后再转换为数字（Number） 把其他类型值转换为字符串1. 发生的情况 基于alert / confirm / prompt /document.write等方法输出内容的时候，会把输出的值转换为字符串，然后再输出 1alert(1) =&gt; '1' 基于 + 进行字符串拼接的时候 把引用值转换为数字类型值的时候，首先会转换为字符串，然后再转换为数字 给对象设置属性名，若属性名不是字符串，先转换为字符串，然后再当作字符串存储到对象中（对象的属性名只能是字符串或者数字） 手动调用toString/toFixed/join/String等方法的时候，也是为了转换为字符串 1234var n = Math.PI; // 圆周率n.toFixed(2) // '3.14'var ary = [12,23,34]ary.join('+') // 12+23+34; … 2. 转换规律123456789101112// 浏览器默认调用的方法都是 toString()[除了对象，都是你理解的转换，也就是直接加引号]1 // '1';null =&gt; 'null'[] =&gt; '';[12] =&gt; '12';[12,23] =&gt; '12,23'(function()&#123;&#125;).toString() // \"function()&#123;&#125;\"【对象】&#123;name:'xxx'&#125; =&gt; '[object Object]'&#123;&#125; =&gt; '[object Object]'不管是什么样的普通对象，最后结果都一样 把其他值转为布尔类型值1.发生的情况 基于!/!!/Boolean()方法转换； 条件判断中的条件最后都会转换为布尔类型 …123456if(n)&#123; // 把n的值转换为不二验证条件的真假&#125;if('3px' + 3)&#123; // 先计算表达式的结果'3px3',把结果转换为布尔类型值true,&#125; 2.转换规律除了 ‘’（空字符串）， null， undefined， 0， NaN转换为boolean是false外，其他都是true. 特殊情况：数学运算和字符串拼接 “+”123456789当表达式中出现字符串，就是字符串拼接，否则就是数学运算1+ true // 2 数学运算\"1\" + true // \"1true\" 字符串拼接[12] + 10 // '1210' 虽然现在没看到字符串，但是引用类型转换为数字，会先转换为字符串，所以变为了字符串拼接（&#123;&#125;）+ 10 // \"[object Object]10\"[] + 10 // '10'&#123;&#125; + 10 // 10 这个和以上说的没有任何关系，因为他根本就不是数学运算，也不是字符串拼接，他是两部分代码 &#123;&#125;代表一个代码块（块级作用域），+10才是我们的操作；严格来说应该分成两部分：&#123;&#125;;+10; 1234512 + true + false + null + undefined + [] + 'hello' + null +undefined + [] + true // \"NaNhellonullundefinedtrue\"13 + NaN = NaNNaN +[] = \"NaN\"12+[]// '12' 特殊情况：&quot;==&quot;在进行比较的时候，如果左右两边数据类型不一样，则先转换为一样的类型，再进行比较。 对象 == 对象；不一定相等，因为对象操作的是引用地址，地址不相同，则不相等 12345&#123;name:'xx'&#125; == &#123;name:'xx'&#125; //falsevar obj1=&#123;&#125;;var obj2 = obj1;obj2 == obj1 //true 对象==数字，把对象转换为数字，然后再比较； 对象==布尔：把对象转换为数字，把布尔也转换为数字； 对象==字符串：把对象转化为数字，把字符串也转化为数字 字符串 == 数字： 字符串转化为数字 字符串== 布尔： 都转化为数字 布尔==数字：把布尔转换为数字1234567不同类型值的比较，都是把其他值转换为数字类型值，在进行比较null == undefined //truenull === undefined //falsenull 和 undefined 和其他值都不相等NaN == NaN //false以上需要特殊记忆的 123456789101==true // true2==true //false 两个情况比较的时候，都转化为数字，这里是把true变为1，而不是把2变为true[] == [] // false 同类型之间直接比较，对象的引用地址不一样，所以是false![]==[]// ![]是false,类型不一样，转化为数字是0，[]转化为数字是0 ，结果是true[]==false// true 0 == 0[] == false // true 都转化为数字 0==0[]==true // false![] == false; // 先算![] == false; false == false ; 结果是true![]==true;// false 操作数组的常用方法数组也是对象数据类型的，也是由键值对组成的123456789101112 var ary =[12,23,34];/***结构* 0： 12* 1：23* 2：34*length:3*/1.以数字为索引，从零开始递增；2、有一个length属性存储的是数组的长度ary[0]// 获取第一项ary[2] ary[ary.length-1] // 获取最后一项 数组中每一项的值可以是任何数据类型的12345// 多维数组var ary = [ &#123;name:&apos;xx&apos;,age:9&#125;, &#123;name:&apos;yy&apos;,age:10&#125;]; 数组当中的常用方法 按照四个维度记忆： 方法的作用 方法的参数 方法的返回值 原有的数组是否改变 push 向数组 末尾 追加新的内容 \\参数：追加的内容，可以是一个，也可以是多个\\返回值： 新增后数组的长度\\原有数组改变 1234567var ary = [12,23,34]ary.push(100); // 4ary // [12,23,34,100]ary.push(200,300);//6ary //[12,23,34,100.200.300]ary.push(&#123;name:'xx'&#125;)//7ary // [12,23,34,100,200,300, &#123;name:'xx'&#125;] pop 删除数组最后一项\\无\\返回值： 被删除的那一项内容\\原有数组改变 123var ary = [12,23,34];ary.pop(); // 34ary // [12,23] shift 作用：删除数组中的第一项\\参数：无\\返回值：被删除的那一项\\原数组改变 基于shift删除数组中的第一项，第一项被删除后，原有后面的每一i选哪个的索引都要向前提一位 unshift 作用：向数组开始位置追加新内容给\\参数：新增的内容\\返回值：新增后数组的长度\\原有数组改变 splice 基于splice可以对数组进行很多操作：删除指定位置的内容，向数组指定位置增加内容，还可以修改指定位置的内容 删除 12345语法：ary.splice(n,m) // 从索引n开始删除m个内容参数：n -&gt; 索引； m -&gt; 要删除的个数返回值： 把删除的部分以一个新数组返回原有数组改变m不写的话或者删除的个数大于最大长度，是指从索引开始删除到数组末尾 新增 1234ary.splice(n,0,x,...)从索引n开始删除0项，把x或者更多内容存放到数组中索引n的前面返回值： [] 因为一项都没有删除原有数组改变 修改 123ary.splice(n,m,x,...)修改的原理就是把原有的内容删除掉，然后把新的内容放入数组返回值是删除内容组成的数组 12345678910需求扩展1、删除数组最后一项，有几种办法： ary.pop();ary.splice(ary.length-1);ary.length--;// 不建议基于delete删除，虽然内容没有了，但是数组的length没有改变1、向数组末尾追加新的内容，有几种办法；ary.push();ary.splice(ary.length,0,x); // x是要添加到索引的前面，所以不能是ary.lengthary[ary.length] = x; slice作用：在一个数组中，按照条件查找出其中的部分内容；参数： 两个参数 n,m; 从索引n开始找到索引m处，但是不包含m; m不写的话，查到数组末尾返回值： 以一个新数组存储查找的内容；原有数组不会改变； ary.slice(0);ary.slice(); // 数组克隆数组 concat作用：实现多个数组（或者值）的拼接参数：数组或者值返回值：拼接后的新数组原有数组不变ary1.concat(ary2,’kyle’,ary3)[].concat(ary1,ary2,’kyle’,ary3) 可以基于空数组作为拼接的开始，再括号中排列拼接的顺序 toString作用：把数组转化为字符串参数：无返回值：数组中每一项用逗号分隔的字符串原有数组不变 join作用：和toString类似，也是把数组转化为字符串，但是可以设置变为字符串之后每一项和每一项之间的连接符参数：指定的连接符返回：字符串原有数组不变 reverse作用：把数组倒过来排列参数：无返回值：排列后的新数组原有数组改变 sort作用：给数组排序参数：无或者是个函数返回值：排序后的新数组原有数组改变 sort在不传递参数的情况下只能处理10以内的排序在真实项目中，基于sort排序，我们都需要传递参数123ary.sort(function(a, b)&#123; return a-b; //升序 return b-a 降序&#125;) indexOf / lastIndexOf这两个方法不兼容IE低版本浏览器(IE678)作用：返回当前项在数组中第一次和最后一次出现的索引参数：要检测的索引返回：索引原有数组不变1234// 验证数组中是否含有某一项if(ary.indexOf(100) &gt; -1)&#123;// 验证数组中是否含有100&#125; 第一阶段我们不深入研究这些方法，搞懂这些方法需要了解OOP/作用域/回调函数等，第二阶段再去研究 数组去重123456789101112131415161718192021/*** 1. 定义一个空对象；* 2. 将数组中的值以当作属性名和属性值存入obj中，之前要先判断obj中是否含有此属性名， typeof ,有则删除，没有则赋值*/var ary = [1, 3, 5, 4, 3, 34, 56, 43, 34];var obj = &#123;&#125;;for (var i = 0; i &lt; ary.length; i++) &#123; var item = ary[i]; if (typeof obj[item] !== 'undefined') &#123; // 存在删除 //ary.splice(i, 1, ary[ary.length - 1]); // 为避免因数组过长而引起的数组塌陷，我们将数组末尾的值赋值给当前值，因为当前值已经在obj中存在，所以没有必要再替换，直接删除最后一项即可； ary[i] = ary[ary.length - 1]; ary.length--; i--; // 当前项已经不是原来的值了，要重新检测当前值，所以i--; continue; &#125; else &#123; obj[item] = item; &#125;&#125; JS常用方法JS中关于JS的一些细节知识 在JS中所有用单引号或者双引号包起来的都是字符串，每一个字符串是有0到多个字符组成；12345var str = 'kylepeng';str.length // 字符串长度str[100] -&gt; undefined;字符串中的每一个字符都有一个自己对应的索引，也有类似于数组一样的length代表自己的长度 字符串中的常用方法字符串是基本类型数据，字符串的每一次操作都是值直接的进行操作，不想数组一样是基于空间地址来操作的，所以不存在原有字符串是否改变这一说，肯定都是不变的 charAt/charCodeAt作用：charAt根据索引获取指定位置的字符； charCodeAt不仅仅获取字符，它获取的是字符对应的Unicode编码值（ASC II码值）参数：索引返回值：字符或者对应的编码123456789 var str = 'sdfsdfse'; str.charAt(0) // s str.charAt(100) // ''空字符串 str[100] // undefined //当索引不存在的时候，str[x]获取的值和数组一样，结果是undefined;str.charCodeAt(0) //115 得到的编码是ASC II中对应的十进制编码'你'.charCodeAt() //20320 中文也有对应的编码//String.fromCharCode(122) // 'z' 通过编码找到对应的字符 indexOf/lastIndexOf获取当前字符在字符串中第一次出现或最后一次出现的索引，用以判断字符串中是否包含某个字符，有这个字符，返回索引，没有这个字符，返回-1 slice作用：str.slice(n,m)从索引n开始到索引m止，不包含m,把找到的字符当作新字符串返回 substring和slice语法一摸一样唯一的区别在于，slice支持负数索引，substring不支持负数索引str.substring(-3,-1) // “”str.substring(-3,1) // “s” substr也是字符串截取的方法str.substr(n,m) 从索引n开始，截取m个字符支持负数索引，负数索引指的是字符串总长度+负数索引和substring一样，第二个参数不写，截取到末尾，但是支持第一个索引为负数 toUpperCase / toLowerCase实现字符大小写的转化 split和数组中的join相对应，join是把数组中的每一项按照指定的连接符变成字符串，split是把字符串按照指定的分隔符，拆分成数组中的每一项。 replace把字符串中的原有字符进行替换参数： 原有字符， 要替换的新字符返回值： 替换后的字符串// =》在不使用正则的请情况下，每执行一次replace,只能替换一次 真实项目需求时间字符串格式化有一个时间字符串 ‘2018-4-4 16:6:8’, 我们想基于这个字符串获取到”04月04日 16时06分” 123456789101112131415161718192021222324252627282930313233343536// 2018-4-4 16:6:8 =&gt; 04月04日 16时06分 var str = '2018-4-4 16:6:8'; var ary = str.split(' '); var ary1 = ary[0].split('-'); var ary2 = ary[1].split(':'); var month = ary1[1], date = ary1[2], hour = ary2[0], minute = ary2[1]; function addZero(n) &#123; if (n &lt; 10) &#123; n = '0' + n; &#125; return n; &#125; var newStr = addZero(month) + '月' + addZero(date) + '日 ' + addZero(hour) + '时' + addZero(minute) + '分'; console.log(newStr); // 正则方法 ~ function(pro) &#123; pro.formatTime = function(template) &#123; template = template || '&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒'; var ary = this.match(/\\d+/g); template = template.replace(/\\&#123;(\\d+)\\&#125;/g, function() &#123; var n = arguments[1]; val = ary[n] || '0'; val &lt; 10 ? val = '0' + val : null; return val; &#125;); return template; &#125; &#125;(String.prototype); console.log(str.formatTime()); console.log(str.formatTime('&#123;1&#125;月&#123;2&#125;日')); URL地址问号传参解析12345678910111213141516171819202122232425262728/** *https://www.zhufeng.cn/stu/?lx=1&amp;name=aa&amp;sex=man#teacher // #后面的成为哈希值HASH,这个值可能有，可能没有，我们需*要处理，有的话我们需要过滤掉 * 1、先找到问号，把问号后面的信息截取下来即可 * A、首先我们需要验证是否存在#哈希值，存在我们从问号开始截取到#，不存在我们直接截取到字符串末尾 * 2、以&amp;进行拆分（数组） * 3、 遍历数组中的每一项，把每一项按照=拆分，把拆分后的第一项作为对象的属性名，第二项作为属性值进行存储即可 */function getURL(url) &#123; //var str = url.substring(str); var indexASK = url.indexOf('?'); var indexWell = url.indexOf('#'); var str; // # 可能有，可能没有 if (indexWell &gt; -1) &#123; // # 存在 str = url.substring(indexASK+1,indexWell); &#125; else &#123;// 截取到末尾 str = url.substr(indexASK+1); &#125; var ary = str.split('&amp;'); var obj=&#123;&#125;; for(var i=0;i&lt;ary.length;i++)&#123; var item =ary[i], itemAry = item.split('='); obj[itemAry[0]]=itemAry[1]; &#125; return obj;&#125;console.log(getURL('https://www.zhufeng.cn/stu/?lx=1&amp;name=aa&amp;sex=man#teacher')); JS中的MathMath称为数学函数，但是它属于对象类型的之所以叫做数学函数，是因为Math这个对象中提供了很多操作数字的方法 Math.abs取绝对值 Math.ceil / Math.floor向上或者向下取整 Math.round四舍五入 Math.round(-10.5) =&gt; -10; Math.round(-10.51) =&gt; -11 Math.sqrt开平方 pow取幂 n的m次方Math.pow(2,10) =&gt; 1024 max/min获取最大值和最小值 Math.PI圆周率 Math.random()获取0到1之间的随机小数Math.ceil(Math.random()10); // 1-10之间的随机整数Math.floor(Math.random()(m-n)+n);获取n-m之间的随机整数","categories":[],"tags":[{"name":"js笔记","slug":"js笔记","permalink":"http://yoursite.com/tags/js笔记/"}]},{"title":"逻辑陷阱","slug":"逻辑陷阱","date":"2018-12-29T02:58:11.000Z","updated":"2018-12-29T06:35:54.050Z","comments":true,"path":"2018/12/29/逻辑陷阱/","link":"","permalink":"http://yoursite.com/2018/12/29/逻辑陷阱/","excerpt":"这篇博客收录了一些自己犯过的逻辑方面的错误。","text":"这篇博客收录了一些自己犯过的逻辑方面的错误。 两个if语句123456789101112131415161718192021222324252627282930313233343536373839404142434445// 代码如下&lt;div ng-click=start()&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;var flag = 0;$scope.text = 0;$scope.start = function()&#123; if(flag == 0)&#123; console.log(&apos;0&apos;); $scope.text = &apos;0&apos;; flag = 1; &#125; if(flag ==1)&#123; console.log(&apos;1&apos;); $scope.text = &apos;1&apos;; flag = 0; &#125;&#125;/*结果是无论我们怎么点击, text始终是1。因为如果flag=0;执行完第一个if语句之后，flag = 1;满足第二个条件，将继续执行第二个语句；flag = 1,自然便只执行第二个语句。 免于此困境的方法是使用 if else 或者 swith case;*/$scope.start = function()&#123; if(flag == 0)&#123; console.log(&apos;0&apos;); $scope.text = &apos;0&apos;; flag = 1; &#125;else&#123; console.log(&apos;1&apos;); $scope.text = &apos;1&apos;; flag = 0; &#125;&#125;// 或者$scope.start = function()&#123; switch(flag)&#123; case 0: console.log(&apos;0&apos;); $scope.text = &apos;0&apos;; flag = 1; break; case 1: console.log(&apos;1&apos;); $scope.text = &apos;1&apos;; flag = 0; &#125;&#125;","categories":[],"tags":[]},{"title":"《图解HTTP》笔记","slug":"《图解HTTP》笔记","date":"2018-12-17T06:30:02.000Z","updated":"2018-12-21T09:41:58.158Z","comments":true,"path":"2018/12/17/《图解HTTP》笔记/","link":"","permalink":"http://yoursite.com/2018/12/17/《图解HTTP》笔记/","excerpt":"2018年12月13日购买书籍《图解HTTP》,作者上野宣，17日到达。下文是阅读时的笔记","text":"2018年12月13日购买书籍《图解HTTP》,作者上野宣，17日到达。下文是阅读时的笔记 TCP/IPTCP/IP协议是网络中一系列协议的统称。TCP/IP协议将网络分成四个层次：应用层、传输层、网络层、链路层。 - 应用层是服务与客户通信的活动 - 传输层TCP将应用层的数据报划分成许多小的数据报，并添加报头，负责传输与传输成功与否 - 网络层IP选择传输线路 - 链路层与硬件相关 ##","categories":[],"tags":[]},{"title":"fcc知识整理","slug":"fcc知识整理","date":"2018-12-13T08:19:23.000Z","updated":"2019-03-13T03:09:15.248Z","comments":true,"path":"2018/12/13/fcc知识整理/","link":"","permalink":"http://yoursite.com/2018/12/13/fcc知识整理/","excerpt":"本篇博客主要整理在free code camp 上学习时遇到的问题和解决方法","text":"本篇博客主要整理在free code camp 上学习时遇到的问题和解决方法 angular http中的跨域问题做page的时候遇到了$http.jsonp()出现错误，解决方法如下123456.controller(&apos;contrlName&apos;,function($scope,$http,$sce)&#123; $http.jsonp($sce.trustAsResourceUrl(url)) .then(function(reponse)&#123; //console.log &#125;)&#125;) angular img引入链接 使用 ng-src1&lt;img ng-src=&quot;&#123;&#123;url&#125;&#125;&quot;/&gt; juqery 判断元素在数组或者对象中的位置 index();12array.index(obj);obj.index(obj); 常用语ReferenceError 指一个不存在的变量被引用时发生的错误； https://bubkoo.com/2014/01/04/emmet-a-toolkit-for-improving-html-css-workflow/ css 文字太长，不换行隐藏12345&#123; overflow:hidden; text-overflow: ellipsis; white-space: nowrap;&#125; bootstrap 文件引用12345678&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css&quot; integrity=&quot;sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; $interval 和 $timeout$interval 和 $timeout 是angular的内置函数，与js中的函数interval和timeout作用一样；语法 $interval(fn, delay), $timeout(fn, delay);取消 $interval.cancel(promise), $timeout.cancel(promise);$interval是每隔一定时间调用一次函数，知道取消promise; $timeout 是隔一定时间调用一次函数 ng-style 第一种用法 12345678910&lt;div ng-style=&quot;obj&quot;&gt;&lt;/div&gt;&lt;script&gt; $scope.obj = &#123; &apos;width&apos;:&apos;400px&apos;, &apos;height&apos;:&apos;300px&apos;, &apos;background-color&apos;:&apos;blue&apos; &#125;&lt;/script&gt; 第二种用法 1234567891011&lt;div ng-style=&quot;&#123;&apos;width&apos;:&apos;400px&apos;,&apos;height&apos;:&apos;300px&apos;,&apos;background-color&apos;:filterColor&#125;&quot;&gt;&lt;/div&gt;&lt;script&gt; $scope.filterColor = function(flag)&#123; if(flag == 1)&#123; return &apos;red&apos;; &#125;else&#123; return &apos;blue&apos;; &#125; &#125;&lt;/script&gt; -第三种用法12345678910111213141516&lt;div ng-style=&quot;obj&quot;&gt;&lt;/div&gt;&lt;script&gt; $scope.obj = &#123; &apos;width&apos;:&apos;400px&apos;, &apos;height&apos;:&apos;300px&apos;, &apos;background-color&apos;:filterColor &#125; function filterColor = function(flag)&#123; if(flag == 1)&#123; return &apos;red&apos;; &#125;else&#123; return &apos;blue&apos;; &#125; &#125;&lt;/script&gt; 函数和变量变量会影响函数的运行，在定义函数或者封装函数的时候，要自定义变量，然后调用外界的变量，而不能直接使用外界的变量，这样会污染函数，且不利于函数的使用 js原型js原型有自己的属性和方法，继承者可以继承这些属性和方法，也可以修改这些属性和方法，也可以添加属于自己的属性和方法。任何原型都是对象，任何对象都可以作为原型去继承。 js中的数学公式Math.PI 圆周率Math.pow(a,b) a的b次方Math.sqrt()Math.round()Math.floor()Math.ceil() js中获取年份的两个函数getYear 得到的是以1900开始的年份 2001，得到的就是101getFullYear 得到的是完全年份 关于链接1234567// 获取当前链接的值var _url = window.location.href;// 阻止a链接的跳转$(&quot;.aa&quot;).on(&apos;click&apos;, function(e)&#123; e.preventDefault();&#125;); $().one()和$().off();$().one()用法与$().on()相同，只是在事件执行一次之后，即失效。相当于在on的事件中添加 $().off();Object.keys(obj). 返回obj对象的属性组成的数组；$().attr(); 返回dom对象的属性值，或者设置某个dom对象的属性arr.some(function(currentValue, index, arr){})， 用于遍历数组中的每个元素，检测其是否都满足某个条件","categories":[],"tags":[{"name":"fcc","slug":"fcc","permalink":"http://yoursite.com/tags/fcc/"}]},{"title":"日常总结","slug":"日常总结","date":"2018-12-12T05:55:38.000Z","updated":"2019-03-12T09:42:01.578Z","comments":true,"path":"2018/12/12/日常总结/","link":"","permalink":"http://yoursite.com/2018/12/12/日常总结/","excerpt":"此处是工作中遇到的小问题的总结：","text":"此处是工作中遇到的小问题的总结： 1、a标签的选择问题需要修改带class的a标签的hover的文字颜色，方式如下 123456&lt;style&gt; a.egHyperlink:hover&#123; color:red; &#125;&lt;/style&gt;&lt;a href=&quot;#&quot; class=&quot;egHyperlink&quot;&gt;smile&lt;/a&gt; 2、hr分割线需要一条粉红色的分割线，宽度1px 12345678&lt;style&gt; hr&#123; height:2px; border:none; border-top:1px solid #00BFFF; &#125;&lt;/style&gt;&lt;hr&gt; 展示效果如下： 3、图片环绕文字 12345&lt;div&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/1634933fa3100474?w=1039&amp;h=579&amp;f=png&amp;s=16869&quot; width=&quot;50%&quot; style=&quot;float:left;border:1px solid #00BFFF;margin:0 10px 0 0;&quot;/&gt;&lt;p&gt;What I want to accomplish is for the text to be aligned with the top and left side of the floated img and to wrap immediately underneath with no margin. When I comment out the padding in &apos;p&apos; the image has no bottom margin, but I want the padding property to be active in my stylesheet.What I want to accomplish is for the text to be aligned with the top and left side of the floated img and to wrap immediately underneath with no margin. When I comment out the padding in &apos;p&apos; the image has no bottom margin, but I want the padding property to be active in my stylesheet.&lt;/p&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 效果如下： What I want to accomplish is for the text to be aligned with the top and left side of the floated img and to wrap immediately underneath with no margin. When I comment out the padding in ‘p’ the image has no bottom margin, but I want the padding property to be active in my stylesheet.What I want to accomplish is for the text to be aligned with the top and left side of the floated img and to wrap immediately underneath with no margin. When I comment out the padding in ‘p’ the image has no bottom margin, but I want the padding property to be active in my stylesheet. 4、颜色的值，遇到过几次需要使用颜色而又不是特别严格要求使用某一种颜色的问题，这个时候可以自己选择，今天先更新一个，以后遇到就记下来 #00BFFF rgb(2, 221, 223) 文字颜色，rgb(75,75,75) 5、@media screen问题总是遇到需要使用@media screen来区分设备的问题，却总是忘记代码，脑子啊，css样式要写在{}内 1234567891011# Mobile@media screen and (min-width: 480px)&#123;&#125;# Tablet@meida screen and (min-width: 768px)&#123;&#125;# Desktop@media screen and (min-width: 992px)&#123;&#125;# Huge@media screen and (min-width: 1280px)&#123;&#125; 或者 12345678# Phone@media screen and (max-width:320px)&#123;&#125;# Tablet@media screen and (min-width:321px) and (max-width:768px)&#123;&#125;# Desktop@media screen and (min-width:769px)&#123;&#125;","categories":[],"tags":[]},{"title":"JDK的安装和盒子模型","slug":"盒子模型","date":"2018-07-20T09:03:39.000Z","updated":"2018-12-12T09:22:52.070Z","comments":true,"path":"2018/07/20/盒子模型/","link":"","permalink":"http://yoursite.com/2018/07/20/盒子模型/","excerpt":"这边博客的主要内容一是介绍盒子模型，一是介绍JKD的环境搭建盒子模型有两种：w3c模型和IE模型，通过box-sizing的值来判断是哪一种；box-sizing=content-box，这是默认值,是w3c模型；box-sizing=border-box,是IE模型","text":"这边博客的主要内容一是介绍盒子模型，一是介绍JKD的环境搭建盒子模型有两种：w3c模型和IE模型，通过box-sizing的值来判断是哪一种；box-sizing=content-box，这是默认值,是w3c模型；box-sizing=border-box,是IE模型 盒子模型w3c模型width = 内容的宽度height = 内容的高度 IE模型width = 内容的宽度 + padding + border;height = 内容的高度 + padding + border; 背景色背景色占据的内容和padding,不占据border; outlineoutline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。注释：轮廓线不会占据空间，也不一定是矩形。它的用法和border是一样的。 JDK的环境搭建下载安装包https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html 安装步骤双击.exe程序，按照顺序依次点击C:\\Program Files\\Java\\jdk11 设置环境变量我的电脑（右键）——&gt; 属性 ——&gt; 高级设置 ——&gt; 环境变量 在用户变量里面设置 JAVA_HOME = C:\\Program Files\\Java\\jdk11在系统变量里面添加到PATH C:\\Program Files\\Java\\jdk11\\bin 相关名词JVM java虚拟机JRE java程序的运行环境JDK java的开发包工具 phoneCatng-app 声明angularjs的作用域，创建一个名称为指定名称的module,同时创建$rootScope;ng-controller 创建一个控制器，同时创建一个$scope, $scope是$rootScope的后代，controller是 data model 和 view 之间的粘合剂； component 组件由 template 和 controller组成，使用 .component(name, cod)方法创建 1234567891011121314151617181920212223angular.module(&apos;myapp&apos;).component(&apos;phoneList&apos;,&#123; template: &apos;&lt;ul&gt;&apos;+ &apos;&lt;li ng-repeat=&quot;phone in $ctr.phones&quot;&gt;&apos;+ &apos;&lt;span&gt;&#123;&#123;phone.name&#125;&#125;&lt;/span&gt;&apos;+ &apos;&lt;span&gt;&#123;&#123;phone.snippet&#125;&#125;&lt;/span&gt;&apos;+ &apos;&lt;/li&gt;&apos;+ &apos;&lt;/ul&gt;&apos;, controller: function phoneListController()&#123; this.phones = [ &#123; name: &apos;Nexus S&apos;, snippet: &apos;Fast just got faster with Nexus S.&apos; &#125;, &#123; name: &apos;Motorola XOOM™ with Wi-Fi&apos;, snippet: &apos;The Next, Next Generation tablet.&apos; &#125;, &#123; name: &apos;MOTOROLA XOOM™&apos;, snippet: &apos;The Next, Next Generation tablet.&apos; &#125; ]; &#125; &#125;) 细节补充： 我们创建的组件名称是phoneList,但是在view中，要写&lt;phone-list&gt;&lt;/phone-list&gt;,否则，不显示；component的命名只能是驼峰规则，而view中的标签要用 “-” 代替；","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"angular学习(一)","slug":"angular学习-一","date":"2018-07-18T02:30:15.000Z","updated":"2018-08-08T08:17:26.886Z","comments":true,"path":"2018/07/18/angular学习-一/","link":"","permalink":"http://yoursite.com/2018/07/18/angular学习-一/","excerpt":"angular简介：AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。（参考：angular中文网）","text":"angular简介：AngularJS诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。（参考：angular中文网） 搭建环境参考： 链接： https://angular.io/guide/quickstart 视频： b站上大漠穷秋的视频，具体可以在b站上直接搜索大漠穷秋 通常，我们最开始学习angular的时候，只需要在网页中引入&lt;script src=&quot;angular....js&quot;&gt;&lt;/script&gt;即可。但是随着学习的深入，angular需要的工具的增加，我们需要安装越来越多的东西，像集成、测试等等，angular官方开发了针对angular的开发工具和库@angular/cli。安装命令如下：1npm install -g @angular/cli 因为@angular/cli中集成了sass工具，安装过程中会被墙，所以需要使用vpn。如果没有vpn的话，就需要使用cnpm工具安装，cnpm中国的npm,12npm install -g cnpmcnpm install -g @angular/cli 创建项目命令1ng new project-name 启动服务1ng serve --open 默认浏览器会自动启动并搜索: localhost:4200当然，我们安装环境的时候，也要学会卸载环境，命令如下：1npm uninstall -g @angular/cli 或者1cnpm uninstall -g @angular/cli $apply的使用$apply的解释让页面中的绑定的数据注意到数据的变化12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html ng-app=&quot;weather&quot;&gt;&lt;head&gt; &lt;title&gt;angular&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.7.2/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; angular.module(&quot;weather&quot;,[]) .controller(&quot;Ctrl&quot;,function($scope,$timeout)&#123; $scope.message = &quot;Waiting 2000ms for update&quot;; setTimeout(function()&#123; $scope.message = &quot;Timeout called!&quot;; &#125;,2000) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng:app ng-controller=&quot;Ctrl&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在这个app中，2000毫秒之后，页面绑定的数据并没有变化。$scope.message确实已经变化了，并没有传递到前端页面上。 我们需要将控制器中数据的变化传递到页面上，就需要使用$apply。将函数绑定在$apply中,修改controller如下123456789.controller(&quot;Ctrl&quot;,function($scope)&#123; $scope.message = &quot;Waiting 2000ms for update&quot;; setTimeout(function()&#123; $scope.$apply(function()&#123; $scope.message = &quot;Timeout called!&quot;; &#125;) &#125;,2000) &#125;) 我自己想过一个比喻，关于$rootscope,$scope的，自然也可以应用在这里：我们使用ng创建一个app的时候,会随之产生一个$rootscope;在这个app中创建controller的时候，也会随之产生一个$scope.我们将app比作一个大剧场，大剧场里面有很多小剧场（controller)。大剧场有公共资源可以使用，他们放在一个房间里$rootscope;小剧场也有资源可以单独使用，他们也放在一个小房间里$scope。当然，小剧场自然可以使用大剧场的公共资源。那$apply,$timeout,$http是什么呢，$scope里面放了很多的data,而处理这些data，就像在茶水房里烧水一样，需要工具和方法，我们使用的是js或者jquery这些工具，那如何让剧场里的人知道水烧开了呢，$apply就是。$scope.$apply对于data的包裹，相当于将data纳入了ng框架当中。在ng自带的方法里面，他们会自动将data纳入ng中去，比如上面的代码可以修改成使用ng自带的$timeout方法123456.controller(&quot;Ctrl&quot;,function($scope,$timeout)&#123; $scope.message = &quot;Waiting 2000ms for update&quot;; $timeout(function()&#123; $scope.message = &quot;Timeout called!&quot;; &#125;) &#125;) $apply()和$apply(fn)的区别我们可以像上文中一样使用$apply(fn),将data包裹在$scope.$apply(fn)中；也可以在改变data后，使用$scope.$apply();1234setTime(function()&#123; $scope.message = &quot;Timeout Called!&quot;; $scope.$apply(); &#125;,2000) 但是这样不好的点在于，它不会在有error的时候抛出。 ng-xng-model数据双向绑定，ng-model=”name”相当于定义了一个名为name的数据变量 $scope.name,一处变而处处变。常常会用在表单里面，用以获取用户输入的数据。 Libraries ja_JP Content&gt;Group A&gt;CORP_FUZEExp&gt;CORP_FUZEExp_CountryCatalog_SiteArea&gt;CORP_FUZEExp_Catalog_WTB_SiteArea","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/框架/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"在Github搭建博客（二）","slug":"config-theme","date":"2018-06-05T08:45:35.000Z","updated":"2018-06-07T09:35:36.608Z","comments":true,"path":"2018/06/05/config-theme/","link":"","permalink":"http://yoursite.com/2018/06/05/config-theme/","excerpt":"选择主题我们搭建好博客后，会选择其他的主题而不是hexo自身携带的主题。网上可以搜索到许多的主题，可以击这里查看。我最初选择的是yilia，后来因为嫌字体太大（16px),想修改字体的大小，弄了半天也没弄好，干脆就放弃了，选择了next(它的字体是14px)。 安装next","text":"选择主题我们搭建好博客后，会选择其他的主题而不是hexo自身携带的主题。网上可以搜索到许多的主题，可以击这里查看。我最初选择的是yilia，后来因为嫌字体太大（16px),想修改字体的大小，弄了半天也没弄好，干脆就放弃了，选择了next(它的字体是14px)。 安装next next的地址README中详细地介绍了next的安装方法，我之前在windows10中安装了git，所以选择的方法是在git bash控制台切换到blog目录下输入命令1git clone https://github.com/iissnan/hexo-theme-next themes/next 之后在目录 blog/theme/下会看到目录 next,里面包含了next的主题文件。我们此时打开blog的 _config.yml 文件，找到theme那一行，主题修改为next，如下图所示在cmd控制台依次运行命令123hexo generatehexo server 在浏览器中输入 localhost:4000就可以查看了 next配置的选择建议先阅读整篇文档，尤其是里面的英文注释，有助于帮助理解。在这里，我写下自己做的配置 布局样式的选择四个布局样式都很不错，简洁大方，选择比较随意。 social的选择 menu 的选择 遇到的问题的解决方法标签和分类页面打不开安装和配置好next后，点击标签页和分类页，都出现了Error.原因是找不到页面。在menu的选择图中可以看到，我们将标签和分类的路径设置为 /tags/和/categories/，但是实际上这两个路径并不存在，这就需要我们新建这两个路径,在blog根目录下输入下面的命令行123hexo new page &quot;tags&quot;hexo new page &quot;categories&quot; 路径建好了，我到相应的路径下找到对应的页面进行修改，tags的页面中，要添加type: &quot;tags&quot;,categories的页面中，要添加type: &quot;categories&quot;,如下图所示 如何插入图片图片可以使用本地图片，也可以使用网络服务器上的图片，储存图片的服务器，叫图床。（图柜也比图床好理解吧） 修改hexo的配置文件_config.yml,找到post_asset_folder,将它的值改为true. 这样，当你hexo new &quot;post&quot;的时候，会生成与文件名相同的目录 安装hexo-asset-image插件，它是一个图片路径转换的插件， 1npm install https://github.com/CodeFalling/hexo-asset-image --save 之后就可以将图片放入相应的文件目录中，使用Markdown语法插入图片了 1![alt name](name.png) 这里有一个需要注意的地方就是，图片格式的大小写要一致，比如png不能写成PNG，至于为什么，还不清楚","categories":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/categories/系统/"}],"tags":[{"name":"搭建环境","slug":"搭建环境","permalink":"http://yoursite.com/tags/搭建环境/"}]},{"title":"vim的使用","slug":"vim的使用","date":"2018-06-04T09:00:52.000Z","updated":"2018-06-14T08:19:44.888Z","comments":true,"path":"2018/06/04/vim的使用/","link":"","permalink":"http://yoursite.com/2018/06/04/vim的使用/","excerpt":"参考链接http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/https://coolshell.cn/articles/5426.html上面的博客无论是原文还是翻译都比较有趣，本文是对这两篇博客的阅读笔记。 vim是什么？Vim is a highly configurable text editor for efficiently creating and changing any kind of text. It is included as “vi” with most UNIX systems and with Apple OS X.官网上的解释如上，翻译下就是： Vim 是高度可配置的编辑器，用于高效创建和修改各类文本。它包含在UNIX系统和苹果 OS X 系统的 vi中。","text":"参考链接http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/https://coolshell.cn/articles/5426.html上面的博客无论是原文还是翻译都比较有趣，本文是对这两篇博客的阅读笔记。 vim是什么？Vim is a highly configurable text editor for efficiently creating and changing any kind of text. It is included as “vi” with most UNIX systems and with Apple OS X.官网上的解释如上，翻译下就是： Vim 是高度可配置的编辑器，用于高效创建和修改各类文本。它包含在UNIX系统和苹果 OS X 系统的 vi中。 学习VIM的四个阶段（Survive）存活 i 进入insert模式（插入模式），按Esc回到Normal模式（普通模式）；x 删除当前光标所在的一个字符；:wq w(存盘) q(退出)；dd 删除当前行；p 粘贴hjkl 按照左下上右的顺序移动光标:help 命令的说明 (Feel Comfortable) 感觉舒适1、Insert mode variations（插入字符或行的命令）: a -&gt; 在光标后插入字符；o -&gt; 在当前行下插入新的一行；O -&gt; 在当前行上插入新的一行；cw -&gt; 删除当前光标所在位置的字符到一个单词结尾的字符 2、(Basic moves) 基本的移动命令 hjkl-&gt; 左下上右0 -&gt;(数字0) 移动到当前行的第一个字符；$ -&gt; 移动到当前行的最后一个字符；^ -&gt; 移动到不是blank的第一个字符；g_ -&gt;移动到不是blank的最后一个字符；/pattern -&gt;寻找字符pattern 3、(copy/paster)复制粘贴 yy -&gt; 复制；p -&gt; 粘贴； 4、(Undo/Redo)撤销/重复 u 撤销之前一步的动作；ctr-r 重复之前的命令 5、Load/Save/Quit/Change File (Buffer)下载/保存/退出/改变 文件（缓冲），即对已经完成的文件和正在修改的文件操作的命令 :e&lt;path/to/file&gt; 打开一个文件:saveas &lt;path/to/file&gt; 文件另存为:w 保存但是不退出;:x ZZ :wq 保存并退出:q! 退出但是不保存；:qa! 强制退出:bn :bp 展示下一个文件（同时打开多个文件的时候使用） (Better. Stronger. Faster.)更好 更强 更快Better . (点)重复上一个命令N 重复命令N次举例说明: 2dd 删除两行3p 粘贴文本3次100idesu[ESC] 写一百遍desu. 再写一百遍desu 再写3遍desu Stronger N(G) 光标移动到行Ngg 光标移动到第一行G 光标移动到最后一行Word moves w 移动到下一个word的首字母e 移动到本word的结尾W(大写) 定义WORD是一组word,以blank隔开，移动到下一个WORD的开头E 移动到本WORD的结尾 和 # ，移动到光标所在word相匹配的下一个word,或者上一个word * 下一个，# 上一个% 匹配括号移动，包括 (, {, [.(不理解什么意思) Faster一般的命令格式 &lt;command命令&gt;&lt;结束位置&gt;举例说明0y$ 0 表示光标移动到本行的开始位置；y 开始复制$ 复制到本行结束 另外附加的三个命令v 可视化gU 变成大写gu 变成小写 Vim SuperPowers(Vim超级编辑器)Move on current line (0 ^ $ g_ f F t T , ;) 在当前行移动命令(0 ^ $ g_ f F t T , ; 0 → go to column 0^ → go to first character on the line$ → go to the last columng_ → go to the last character on the linefa → go to next occurrence of the letter a on the line., (resp. ;) will find the next (resp. previous) occurrence.t, → go to just before the character ,.3fa → find the 3rd occurrence of a on this line.F and T → like f and t but backward.","categories":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/categories/系统/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]},{"title":"在Github上搭建博客","slug":"在Github上搭建博客","date":"2018-05-30T07:04:47.000Z","updated":"2018-06-07T09:03:59.911Z","comments":true,"path":"2018/05/30/在Github上搭建博客/","link":"","permalink":"http://yoursite.com/2018/05/30/在Github上搭建博客/","excerpt":"写在前面 为什么自己搭建博客？ 知乎上有关于这个问题的很详尽的回答？链接：https://www.zhihu.com/question/19916345。 我搭建博客用了多久? 大概一下午的时间，当然要感谢找到了一个比较清楚的资料，附上链接：教你免费搭建个人博客。也要感谢16年的时候，学习了linux系统的知识,阅读和操作起来都比较容易。 系统 windows 10 64位，编辑器：sublime text3，控制台：cmd","text":"写在前面 为什么自己搭建博客？ 知乎上有关于这个问题的很详尽的回答？链接：https://www.zhihu.com/question/19916345。 我搭建博客用了多久? 大概一下午的时间，当然要感谢找到了一个比较清楚的资料，附上链接：教你免费搭建个人博客。也要感谢16年的时候，学习了linux系统的知识,阅读和操作起来都比较容易。 系统 windows 10 64位，编辑器：sublime text3，控制台：cmd 搭建博客使用 hexo+Github 什么是hexo?Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。官方文档 什么是Github?GitHub is a development platform inspired by the way you work. From open source to business, you can host and review code, manage projects, and build software alongside millions of other developers. (GitHub是一个受你工作方式启发的开发平台。 从开源到商业，您可以托管和查看代码，管理项目，并与数百万其他开发人员一起构建软件。) click me 准备工作 配置 Github首先，你需要有一个Github的账号。在Github网站上注册账号，并记住自己的Username。我的Username是abluecup。登录，在网页左上方找到 New repository 按钮，点击创建名称为username.github.io的仓库。我的是username是abluecup,我创建的仓库名称就是abluecup.github.io 环境搭建 安装Node.js https://nodejs.org/en/ 安装 Git https://github.com/waylau/git-for-winNode.js和Git的安装，我都是全部默认安装的。当然，你可以根据自己的需要安装。关于Git的教程，推荐廖雪峰的教程。在这里给自己刨个坑，自己以后也会写关于Git的博客。-安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，打开界面：输入 123git config --global user.name &quot;username&quot;git config --global user.email &quot;your email&quot;# username是你注册Github的username,your email是你注册Github时的email 安装Hexo打开cmd, 安装hexo,输入命令然后等待hexo安装完成： 1npm install -g hexo-cli 初始化博客 新建目录test. 进入gitbash控制界面，切换目录到test目录下，输入： 123hexo init blog# 成功提示INFO Start blogging with Hexo! 初始化完成之后，切换目录到blog下，输入命令： 1$ hexo generate 12345# 启动本地服务器$ hexo server# 在浏览器输入 http://localhost:4000/就可以看见网页和模板了INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问 http://localhost:4000/ ，我们会看到网站初始的模样 设置秘钥现在我们可以暂时关闭hexo的本地服务，在git的管理界面输入以下命令:1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一路按Enter键过来就好，最后会得到信息： 1Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. 找到该文件，打开（sublime text），Ctrl + a复制里面的所有内容，然后进入Sign in to GitHub：https://github.com/settings/sshNew SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key 配置博客在blog目录下，用sublime打开_config.yml文件，修改参数信息特别提醒，在每个参数的：后都要加一个空格修改网站相关信息12345678# Sitetitle: 卡而的博客subtitle:副标题description: 描述keywords:关键词author: 作者language:zh-CNtimezone:Asia/Shanghai 配置部署（我的是abluecup，修改成自己的）1234deploy: type: git repo: http://github.com/ABlueCup/ABlueCup.github.io branch: master 发布文章1hexo deploy 后续更新：MarkDown语法链接 遇到的问题： 执行 hexo deploy时，出现错误 error deployer not found:git执行如下代码 1npm install hexo-deployer-git --save 执行 hexo clean , hexo generate , hexo server , hexo deploy等命令时，当前目录必须是在博客根目录下，即 blog/ 文件夹 blog里面","categories":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/categories/系统/"}],"tags":[{"name":"搭建环境","slug":"搭建环境","permalink":"http://yoursite.com/tags/搭建环境/"}]}]}