{"meta":{"title":"卡而的博客","subtitle":"业精于勤，而毁于嬉","description":"体大思精","author":"卡而","url":"https://abluecup.github.io"},"pages":[{"title":"categories","date":"2018-06-07T05:48:59.000Z","updated":"2018-06-07T05:49:48.722Z","comments":true,"path":"categories/index.html","permalink":"https://abluecup.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-07T05:45:29.000Z","updated":"2018-06-07T05:46:17.308Z","comments":true,"path":"tags/index.html","permalink":"https://abluecup.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Javascript基础知识三","slug":"Javascript基础知识三","date":"2019-04-18T08:15:30.000Z","updated":"2019-04-18T09:28:35.097Z","comments":true,"path":"2019/04/18/Javascript基础知识三/","link":"","permalink":"https://abluecup.github.io/2019/04/18/Javascript基础知识三/","excerpt":"此篇内容涉及原型深入,this,商城排序和正则","text":"此篇内容涉及原型深入,this,商城排序和正则 经典面试题1234567891011121314151617181920212223242526272829303132333435/* * 函数有三种角色： * 1 普通函数 堆栈内存释放 作用域链 * 2 类 prototype ： 原型 _proto_ : 原型链 实例 * 3 普通对象 和普通的obj没啥区别，就是对键值对的增删改查 * 三种角色之前没有必然的关系 */function Fn() &#123; var n = 10; this.m = 100;&#125;Fn.prototype.aa = function () &#123; console.log('aa');&#125;Fn.bb = function () &#123; console.log('bb');&#125;// 普通函数执行Fn(); // this:window,有一个私有变量n,和原型以及属性bb没有关系// 构造函数执行var f = new Fn();console.log(f.n); // undefined;console.log(f.m); // 100f.aa(); // 'aa' 实例通过_proto_找到Fn.prototype上的方法aaconsole.log(f.bb); // undefined, bb是把Fn当作一个普通对象设置的属性，和实例没有关系// Fn作为一个对象，只跟bb有关系 12345678910111213// JQ这个类库提供了很多的方法，其中有一部分是卸载原型上的，有一部分是把它当作普通对象处理的~ function () &#123; function jQuery() &#123; // return [JQ实例] &#125; jQuery.prototype.animate = function () &#123;&#125;； jQuery.ajax = function () &#123;&#125;; window..jQuery = window.$ = jQuery;&#125;()$().ajax(); // 无法调取，ajax是jq的私有属性 $.ajax(); 直接的对象键值对操作$().animate(); // 可以调取，原型上的方法 $.animate():无法执行，对象上没有animate这个属性 123456789101112131415161718192021222324252627282930function Foo() &#123; getName = function () &#123; console.log(1); &#125; return this;&#125;;Foo.getName = function () &#123; console.log(2);&#125;Foo.prototype.getName = function () &#123; console.log(3);&#125;;var getName = function () &#123; console.log(4);&#125;;function getName() &#123; console.log(5);&#125;Foo.getName(); // 2 把Foo当作一个对象，找Foo对象下的getName属性getName(); // 4 全局下的getName函数Foo().getName(); // 1 //window.getName(); 先把Foo当作普通函数执行，把执行返回的结果再调取getName方法getName(); // 1new Foo.getName(); // 2 A: Foo.getName , new Anew Foo().getName(); // 3 B: new Foo(), B.getName();new new Foo().getName(); // 3 C: new Foo(), D:C.getName(), new D// 优先级 . = new Fn() &gt; new Fn; 同级别从左到右// Foo -&gt; aaff00 函数代码, getName = aaff11 （4）","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://abluecup.github.io/tags/javascript/"}]},{"title":"Javascript基础知识二","slug":"Javascript基础知识二","date":"2019-04-02T03:24:01.000Z","updated":"2019-04-18T08:19:13.294Z","comments":true,"path":"2019/04/02/Javascript基础知识二/","link":"","permalink":"https://abluecup.github.io/2019/04/02/Javascript基础知识二/","excerpt":"","text":"变量提升机制123456/** 一般都把js放到body的末尾1.为啥？2.放在head中可不可以，如何放到head中也可以实现放到body末尾的效果3.script标签中有两个属性，defer / async, 这两个属性是做什么的*/ 栈内存：作用域， 1. 提供供JS代码自上而下执行的环境（代码都是在栈中执行）； 2. 由于基本类型值比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存储进去； =&gt; 当栈内存被销毁，存储的那些基本值也随之而销毁； 堆内存：引用值对应的空间 存储引用类型值（对象：键值对；函数：代码字符串;） =&gt; 当前堆内存销毁，那么引用值彻底没了 =&gt; 堆内存的释放： 当堆内存没有被任何的变量或者其他东西所占用，浏览器会在空闲的时候，自主进行内存回收，把所有不被占用的内存销毁掉。（webkit内核浏览器） xxx = null;通过空对象指针null可以让原始变量或者其他东西谁都不指向，原先被占用的堆内存就没有被东西占用了，浏览器会销毁它。 12var ary1 =[1,2,4];ary1= null; // 释放堆内存 概念：当栈内存（作用域）形成，JS自上而下执行之前，浏览器首先会把所有带var / function关键字的进行提前的声明或者定义，这种预先处理机制称之为变量提升； 声明： declare // var a ;function aa; (默认值undefined) 定义： defined a=12; (定义就是赋值) =&gt; 带var的只声明，未定义；带function的声明和赋值都完成了；变量提升只发生在当前作用域在全局作用域下声明的变量是全局变量，在私有作用域下声明的变量是私有变量 （带 var , function 的才是声明）浏览器很懒，做过的事情不会重复第二遍，即当代码执行遇到创建函数这部分代码的手，直接跳过（在变量提升阶段，已经完成函数的赋值操作） 在ES3或者ES5语法规范中，只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存 带var 和不带var 的区别123456console.log(a);'a' in window; // in 用来检测属性是否隶属于对象var a=12;console.log(a);console.log(window.a); // window对象的一个属性 在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性的值；私有作用域下声明的私有变量和window没啥关系；全局变量和win中的属性存在映射机制； 12345678910// 不加var,本质是window下的属性，不存在变量提升机制； 加var，本质是变量，存在变量提升机制console.log(a); // Uncaught ReferenceError: a is not defined 按照变量的机制处理，且window下并没有window.a的属性console.log('a' in window);//false undefined, 对象没有这个属性，打印undefinedconsole.log(window.a); // undefineda=12;// window.a=12的简写；console.log(a); //12， 不存在变量a,但是window对象下有a属性console.log(window.a); //12， var a = b =12; // 这样写b是不带var的；var a = 12, b=12;// 这样写，b是带var的； 12345678910111213141516console.log(a,b); // undefined, undefined;var a=12,b=12;function fn()&#123; /** 私有作用域下，带var不带var也有区别 带var的在私有作用域变量提升阶段，都声明为私有变量，和外界没有任何关系； 不带var的不是私有变量，会向上级查找，看是否为上级的变量，不是，继续向上查找，一直找到window为止； 我们把这种查找机制叫做作用域链；也就是我们在私有作用域中操作的这个非私有变量，是一直操作的别人的； */ console.log(a,b); // 形成一个私有作用域，变量提升， a=undefined, b =window.b =12; var a = b=13; // window.b被修改为13 console.log(a,b); //私有作用域 13 ,13&#125; // 跳过函数创建的代码，继续执行fn();console.log(a,b); // 12 ， 13// 被覆盖了 作用域链12345678console.log(b); // 报错function fn()&#123; console.log(b); b=13; conaolog.log(b); // 13&#125;fn();console.log(b); //13 1.变量提升（没有）2.执行fn,没有变量提升；b在fn和window下都没有；在作用域查找的过程中，如果找到win也没有这个变量，相当于给win设置了一个属性b window.b=13; 只对等号左边进行变量提升12345678910111213141516fn(); // fn is not a function fn此时是undefined,不是函数sum(); // 2 普通函数在变量提升阶段已经声明且赋值// 匿名函数之函数表达式var fn = function()&#123; console.log('1'); &#125;// 普通函数function sum()&#123; console.log(2);&#125;;fn(); // 1 当代码执行到这一行的时候，会把函数赋值给fnsum(); // 2 真实项目中，常常采用函数表达式这种方式 条件判断下的变量提升123456789 //在当前作用域中，不管条件是否成立都要进行变量的提升 // 带var的还是只声明 // 带function的在老版本浏览器渲染机制下，声明+定义都处理，但是为了迎合ES6中的块级作用域，新版本浏览器对于函数（在条件判断中的函数），不管条件是否成立，都只是先声明，没有定义，类似于var console.log(a); // undefinedif('a' in window)&#123; var a =100; &#125;console.log(a); // 100 12345678910111213141516171819202122 f = function() &#123; return true &#125;; g = function() &#123; return false &#125;; ~ function() &#123; if (g() &amp;&amp; [] == ![]) &#123; // Uncaught typeError: g is not a function// 新版本浏览器中只声明，未赋值，g=undefined, undefined不是函数，报错；老版本浏览器中g() = true; f = function() &#123; return false &#125;; function g() &#123; return true; &#125;; &#125; &#125;(); console.log(f()); console.log(g()); 同名问题处理1234567891011121314151617181920212223242526272829303132/* * 1.带var和function关键字声明相同的名字，这种也算是重名了（其实是一个FN，只是存储的值不同） */ /* * 2. 关于重名的处理：如果名字重复了，不会重新的声明，但是是会重新的定义：（重新赋值）【不管是变量提升还是代码执行阶段皆是如此】 */ /* *变量提升： fn = ...(1) = ...(2) =...(3) =...(4) */ function fn() &#123; console.log(1); &#125; fn(); // 4 function fn() &#123; console.log(2); &#125; fn(); // 4 var fn = 100; // 带var的在变量提升阶段只是把声明处理了，没有执行赋值操作，所以在代码执行的时候需要完成赋值； fn(); // Uncaught TypeError: fn is not a function; function fn() &#123; console.log(3); &#125; fn(); function fn() &#123; console.log(4); &#125; fn(); let创建的变量不存在变量提升 在ES6中基于let或const创建变量或者函数，不存在变量提升机制, 且切断了全局变量和window属性的映射机制； 在同一个作用域中，基于let不能声明相同的变量； 浏览器在作用域形成之后，执行代码之前，会有一个变量查重机制（语法检测）,发现有重复声明的变量,报错 Uncaught SyntaxError虽然没有把变量提前声明定义，但是浏览器已经记住了，当前作用域下有哪些变量;不管用什么方式，在当前作用域下声明了变量，再次使用let创建都会报错。 123456b =12; // window.b=12console.log(b);a=12; // console.log(a); //Uncaught ReferenceError: a is not definedlet a = 12;console.log(window.a); // undefined ES6 JS中暂时性死区问题12345678910var b = 12;if (true) &#123; console.log(b); // Uncaught ReferenceError: a is not defined let b = 13; // 基于let创建变量，会把大部分&#123;&#125;当成一个私有的块级作用域（类似于函数的私有作用域），在这里也是重新检测语法规范，看一下是否是基于新语法创建的变量，如果是按照新语法来解析&#125;console.log(typeof a);// 在原有浏览器的渲染机制下，基于typeof等逻辑运算符检测一个违背声明过得变量，不会报错，返回undefined console.log(typeof c); // Uncaught ReferenceErrorlet c; //如果当前变量是基于ES6语法处理，在没有声明这个变量的时候，使用TYPEOF检测，会直接报错，不会是undefined,解决了原有的暂时性死区问题 闭包作用域(scope)123456789101112131415var a = 12, b = 13, c = 14;function fn(a) &#123; // 形成作用域后，变量提升前，需要做形参赋值 a =12; // 在私有作用域中，只有以下两种情况是私有变量 A: 声明过的变量 ；B:形参也是私有变量； // 剩下的都不是自己私有的变量，都需要基于作用域链的机制向上查找 console.log(a, b, c); // 12 undefined 14 var b = c = a = 20; // var b=20; c=20;a=20; console.log(a, b, c); // 20,20,20&#125;fn(a); // 执行fn(小括号中是实参：值) -&gt; 执行fn把全局变量a的值12当作实参传递给函数的形参 =&gt; fn(12)console.log(a, b, c); //12,13,20 123456789101112131415// [12,23] -&gt; [100,23] var ary = [12, 23]; function fn(ary) &#123; // 形参赋值赋的是引用地址 // ary = [12,23] console.log(ary); // [12,23] ary[0] = 100; //[100,23] 修改了应用地址中的数据 ary = [100]; // 修改了引用地址 ary[0] = 0; console.log(ary); // [0] &#125; fn(ary); console.log(ary); // [100,23] 查找上级作用域123456789101112131415// 当前函数执行，形成呢个一个私有作用域A，A的上级作用域是谁，和他在哪执行的没有关系，和他在哪创建的有关系，在哪创建的，他的上级作用域就是谁。var a = 12;function fn() &#123; // arguments.callee:函数本身 // arguments.callee.caller: 当前函数在哪执行的caller就是谁（记录的是他的宿主环境）;在全局下执行是null console.log(arguments.callee);&#125;function sum() &#123; var a = 120; fn();&#125;sum(); // 1234567891011121314151617// 当前函数执行，形成呢个一个私有作用域A，A的上级作用域是谁，和他在哪执行的没有关系，和他在哪创建的有关系，在哪创建的，他的上级作用域就是谁。var n = 10;function fn() &#123; var n = 20; function f() &#123; n++; console.log(n); &#125; f(); return f;&#125;var x = fn();x();x();console.log(n); 堆栈内存释放JS中的内存分为堆内存和栈内存堆内存：存储引用类型数据（对象：键值对 函数：代码字符串）栈内存：提供JS代码执行的环境和存储基本类型值 【堆内存释放】 让所有引用堆内存地址的变量赋值为null即可（没有变量占用这个堆内存了）浏览器会在空闲的时候把它释放掉 【栈内存释放】 一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉，但是也有特殊不销毁的存在： 1. 函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放，一旦释放，外面的变量找不到原有的内容了 2. 全局栈内存只有在页面关闭的时候才会被释放掉 如果当前内存没有被释放，那么之前在栈内存中能够存储的基本值也不会被释放，能够一直保存下来。 12345678910111213141516171819var i = 1;function fn(i) &#123; //var i=2; return function(n) &#123; console.log(n + (++i)); &#125;&#125;var f = fn(2); // 先把fn执行，实参2，把fn执行的返回结果（return 后面的值）赋值给ff(3); // 返回的结果执行fn(5)(6); // 和上面两步类似，都是先执行fn,把fn的返回结果再执行fn(7)(8);f(4);// 6,12,16,8// i++ :自身+1 // ++i :自身+1// 区别是在和别人运算的时候，i++,先拿原有的值进行运算，运算结束后，本身累加1； ++i 先自身累加1，再拿累加后的结果进行运算 闭包的作用： 保护私有变量不受外界干扰；形成一个不受外界干扰的栈内存，保存内部的私有变量； 闭包【概念】： 函数执行，形成一个私有作用域，保护里面的私有变量不受外界的干扰，这种保护机制称为“闭包”； =&gt; 市面上开发者认为的闭包：形成一个不销毁的私有栈内存（作用域）才是闭包 123456789101112// =&gt; 闭包：柯里化函数function fn()&#123; return function()&#123; &#125;&#125;var f=fn();//=&gt; 闭包：惰性函数var utils = (function()&#123; return &#123;&#125;&#125;)() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 // 闭包项目实战应用 // 真实项目中为了保证JS的性能（对栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的） // 1.闭包具有保护作用：保护私有变量不受外界干扰 // 在真实项目中，尤其是团队协作开发中，应该尽可能的减少全局变量的使用，以防止相互之间的冲突（“全局变量污染”），此时我们完全可以把这一部分内容封装到一个闭包中，让全局变量转化为私有变量 (function() &#123; var n = 12; function fn() &#123; &#125; // ... &#125;)() // 不仅如此，我们封装类库的时候，也会把自己的程序都存放在闭包中保护起来，防止和用户的程序冲突，但是我们又需要暴露一些方法给客户使用，这样我们如何处理呢 ？ // JQ这种方式，把需要暴露的方法抛到全局 (function() &#123; function jQuery() &#123; //... &#125; window.jQuery = window.$ = jQuery; // 把需要供外面使用的方法，通过给WIN设置属性的方式暴露出去； &#125;)() // zepto这种方式，基于return把需要供外面使用的方法暴露出去 var Zepto = (function()&#123; return &#123; xxx:function()&#123;&#125; &#125; &#125;)(); // 2.闭包具有保存作用：形成不销毁的栈内存，把一些值保存拿下来，方便后面的调取使用var oBox = document.getElementById('box'); var TabList = oBox.getElementsByTagName('li'); var divList = oBox.getElementsByTagName('div'); function changeTab(curIndex) &#123; for (var i = 0; i &lt; TabList.length; i++) &#123; TabList[i].className = ''; divList[i].className = ''; &#125; TabList[curIndex].className = 'active'; divList[curIndex].className = 'active'; &#125; /* for (var i = 0; i &lt; TabList.length; i++) &#123; (function(i) &#123; TabList[i].onclick = function() &#123; changeTab(i); &#125; &#125;)(i); &#125; changeTab(0);*/ // 执行方法：形成一个私有的栈内存，遇到变量I，I 不是私有变量，向上一级作用域查找（上级作用域window） changeTab(0); // 所有的绑定事件都是异步编程，（同步变成：一件事一件事做，当前这件事没完成，下一个任务不能处理； 异步编程：当前这件事件梅雨哦彻底完成，不再等待，继续执行下面的任务），绑定事件后，不需要等待执行，继续执行下一个循环任务，所以当我们点击执行方法的时候，循环早已经结束（全局的I是最后的循环结果） // 解决方案1：自定义属性 for (var i = 0; i &lt; TabList.length; i++) &#123; TabList[i].myIndex = i; TabList[i].onclick = function() &#123; changeTab(this.myIndex); //=&gt; this:给当前元素的某个事件绑定方法，当事件触发，方法执行的时候，方法中的this是当前操作的元素对象 &#125; &#125; // 解决方案2 闭包 /* for (var i = 0; i &lt; TabList.length; i++) &#123; TabList[i].onclick = (function(n) &#123; //让自执行函数执行，把执行的函数返回值赋值给onclick, 此处Onclick绑定的是返回的小函数,点击的时候执行的是小函数，自执行函数在给事件赋值的时候就已经执行了 return function() &#123; changeTab(n); // 上级作用域：自执行函数执行的时候形成的作用域 &#125; &#125;)(i); // i:把本次全局变量i传递给内部函数的形参n &#125;*/ // 总结：循环三次，形成三个不销毁的私有作用域（），而每一个不销毁的栈内存中都存储了一个私有变量，形参n的值；点击的时候，执行返回的小函数，遇到变量n,就是上级作用域中的n // 基于ES6来执行 for (let i = 0; i &lt; TabList.length; i++) &#123; TabList[i].onclick = function() &#123; changeTab(i); &#125; &#125; // 基于ES6中的let来创建变量是存在块级作用域的（类似于私有作用域）； // 作用域： 栈内存 // 1全局作用域 // 2 私有作用域 （函数执行） // 3 块级作用域（一般用&#123;&#125;包起来的都是块级作用域，前提是ES6语法） /* &#123; let a = 1; console.log(a); // 1 &#125; // cosole.log(a); // 报错 for (let i = 0; i &lt; 5; i++) &#123; // 循环也是块级作用域，初始值设置的变量是当前本次会计作用域中的变量（形成了五个块级作用域） &#125; switch case // 块级作用域 let obj = &#123;&#125;; // =&gt; 对象不是块级作用域*/ 面向对象编程（OOP Object Oriented Programming）单例设计模式 singleton pattern12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * 单例设计模式 * 1. 表现形式 * var obj=&#123;xxx:xxx,...&#125; * 在单例设计模式中，obj不仅仅是对象名，它被称为“命名空间”（NameSpace）,把描述事物的属性存放到命名空间中，多个命名空间是独立分开的，互不冲突。 * 2. 作用 * 把描述同一件事务的属性和特征进行“分组、归类”，（存储在不同堆内存中）因此避免了全局变量之间的冲突和污染 * 3.单例设计模式命名的由来：每一个命名空间都是JS中Object这个内置基类的实例，而实例之间是相互独立，互不干扰的，所以我们称之为单例（单独的实例） * *//* * 高级单例模式 * 1. 再给命名空间赋值的时候，不是直接赋值一个对象，而是先执行匿名函数，形成一个私有作用域（不销毁的栈内存），在这个私有作用域aa中创建一个堆内存，把堆内存的地址赋值给命名空间 * 2. 这种模式的好处：我们完全可以在AA中创造很多内容（变量or函数），哪些需要供外面调取使用的，我们暴露到返回的对象中（模块化实现的一种思想） */var nameSpace = (function() &#123; function fn() &#123; &#125;; return &#123; fn: fn &#125;&#125;)();/* * this × 1，给当前元素的某个事件绑定方法，当时间出发方法执行的时候，方法中的this是当前操作的元素 * 2, 普通函数执行，函数中的this取决于执行的主体，谁执行的，this就是谁（执行主体：方法执行看方法名前面是否有点,有的话，点前面是谁this就是谁，没有,this是window） * 3, 自执行函数执行，方法中的this是window */var n = 2;var obj = &#123; n: 3, fn: (function(n) &#123; n *= 2; var n = 5; this.n += 2; return function(m) &#123; this.n *= 2; //console.log(m++(++n)); console.log(m + (++n)); &#125; &#125;)(n) // 自执行函数执行的时候，堆内存的键值对还没有存储完，它和obj还没有关系，此时obj=undefined,obj.n会报错&#125;var fn = obj.fn;fn(3); // obj.fn(3);console.log(n, obj.n); 12345678910111213141516171819202122232425262728293031323334/* * 模块化开发： * 1, 团队协作开发的时候，会把产品按照功能板块进行划分，每一个功能板块有专人负责开发; * 2, 把各个板块之间公用的部分进行提取分装，后期再想实现这些功能，直接调取引用即可（模块封装）; */var utils = (function() &#123; return &#123; aa: function() &#123;&#125;; &#125;;&#125;;)();var skipRender = (function() &#123; var fn = function() &#123; &#125;; return &#123; init: function() &#123; &#125;; &#125;;&#125;)();skipRender.init();var weatherRender = (function() &#123; var fn = function() &#123; &#125;; return &#123; initi: function() &#123; fn(); //调取自己模块中的方法，直接调取即可； skipRender.fn(); //调取别人模块中的方法 &#125;; &#125;;&#125;)(); 12345/* * 工厂模式(factory pattern)： * 1, 把实现相同功能的代码进行封装，以此来实现“批量生产”（后期要实现这个功能，我们只需要执行函数即可） * 2, 低耦合高内聚：减少页面中的冗余代码，提高代码的重复使用率 */ oop面向对象JS是一门编程语言，具有编程思想【面向对象】js/java/php/c#/ruby/python/c++【面向过程】c面向对象编程需要掌握：对象、类、实例的概念 对象万物及对象 类对象的具体细分（按照功能特点进行分类，有大类，也有小类） 实例类中具体的一个事物（拿出类别中的具体一个实例进行研究，那么当前类别下的其他势力也具备这些特点和特征）; 整个JS就是基于面向对象设计和开发的语言，我们学习和实战的时候，也要按照面向对象的思想去体会和理解； JS中的内置类Object: Number,String, Boolean,Null,Undefined,Array,Date,Rex,…,HTMLCollection,NodeList,EventTagert(node(Element,),…) JS中创建值的两种方式1234567891011121314151617181920212223242526272829/* * 基于构造函数创建自定义类(constructor) * 1. 在普通函数执行的基础上\"new xxx()\",这样就不是普通函数执行了，而是构造函数执行，当前的函数名称之为“类名”，接收的返回结果是当前类的一个实例 * 2. 自己创建的类名，最好第一个单词首字母大写 * 3. 这种构造函数设计模式执行，主要用于组件、类库、插件、框架等的封装，平时编写业务逻辑一般不这样处理 */function Fn() &#123;&#125;;Fn(); //普通函数执行var f = new Fn(); //=&gt; Fn是类，f是类的一个实例var f2 = new Fn(); // f2也是Fn的一个实例，f2和f是独立分开的，互不影响/* * JS中创建值有两种方式 * 1 字面量表达式 * 2 构造函数模式 */var obj = &#123;&#125;; // 字面量方式var obj = new Object(); //构造函数模式// 不管是哪一种方式，创造出来的都是Object类的实例，而实例之间是独立分开的，所以var xxx=&#123;&#125;这种模式就是JS中的单例模式//基本数据类型值基于两种不同的方式创建出来的值是不一样的//基于字面量方式创建出来的是基本类型值，//基于构造函数创建出来的是引用类型值// num2是数字类Number的一个实例，num1也是数字类的实例，它只是JS表达数字的方式之一，都可以使用数字类提供的属性和方法var num1 = 12; // 12 numbervar num2 = new Number(12); // Number&#123;12&#125; object 构造函数机制 细节123456789101112131415161718192021function Fn() &#123; var n = 10; this.m = n; return '哈哈哈'; //这样执行，结束了代码执行，但是不会覆盖实例&#125;// 构造函数执行var f = new Fn();/* * 构造函数执行，浏览器会默认返回创建的实例 * return的是一个基本值，返回的依然是类的实例，没有影响，如果返回的是引用值，则会把默认返回的实例覆盖，此时接收到的结果就不再是当前类的实例 * 构造函数执行的时候，尽量减少return的使用，防止覆盖实例 */// new Fn === new Fn(); 在构造函数执行的时候，如果Fn不需要传参，我们可以省略小括号,意思还是创建实例（和加小括号没有区别）// instanceof: 检测某一个实例是否隶属于某个类 f instanceof Fn 实例 instanceof 类名// in ：检测当前对象是否存在某个属性 'm' in f, 不管当前这个属性是对象的私有属性还是公有属性，只要有，结果就是true. 'toString' in f 结果是true， toString是它的公有属性// hasOwnProperty用来检测当前属性是否为对象的私有属性： 不仅要有这个属性，还必须要是私有属性才可以f.hasOwnProperty('m'); // truef.hasOwnProperty('toString'); // false 这个是公有属性 思考：编写一个方法hasPubProperty，检测当前属性是否为对象的公有属性，和hasOwnProperty对应1234567function hasPubProperty(obj, attr) &#123; if (attr in obj &amp;&amp; obj.hasOwnProperty(attr) === false) &#123; return true; &#125;; return false;&#125;&#125; 原型和原型链 （prototype &amp; proto）1234567891011121314151617181920212223242526272829/* * [函数] * 普通函数、类（所有的类：包含内置类和自己创建的类） * [对象] * 普通对象、数组、正则、Math、实例（是对象类型，除了基本类型的字面量创建的值） * prototype的值，arguments * 函数也是对象类型…… * 1, 所有的函数数据类型都天生自带一个属性叫prototype(原型), 这个属性的值是一个对象，浏览器会默认给它开辟一个堆内存; * 2, 浏览器给prototype开辟的堆内存当中，有一个天生自带的属性，叫constructor,这个属性存储的值是当前这个函数本身； * 3, 每一个对象都有一个_proto_的属性，这个属性指向当前实例所属类的prototype（如果不能确定是谁的实例，都是Object的实例） */function Fn() &#123; var n = 100; this.AA = function () &#123; console.log('AA私有'); &#125;; this.BB = function () &#123; console.log('BB私有'); &#125;;&#125;;Fn.prototype.AA = function () &#123; console.log('AA公有');&#125;;var f1 = new Fn;var f2 = new Fn;console.log(f1.n); // undefined 没有这个属性// f1._proto_.AA === f2._proto_.AA = Fn.prototype.AA // TRUEf1.name = 'f1的私有属性';f1._proto_.name = 'f1原型上的公有属性'; // 每个实例都可以用这个公有属性 练习题12345678910111213141516171819202122232425262728293031var a = 4;function b(x, y, a) &#123; // arguments：函数内置的实参集合，不管是否设置实参，都存在；但是在非严格Js模式下，函数中的形参变量和arguments存在映射机制（映射：相互之间影响） console.log(a); arguments[2] = 10; console.log(a);&#125;;a = b(1, 2, 3); // 函数b并没有return,默认函数的返回值是undefinedconsole.log(a);// 3,10，undefinedfunction fn(x, y) &#123; /* * 形参： x=10, y=undefined // y也是私有变量，赋值为undefined * arg和形参之间的映射关系是以arg的索引为基础完成的，arg中有这个索引，浏览器会完成与对应的形参变量中的映射机制搭建，如果形参比arg中个数多，那么多出来的形参是无法和arg中对应的索引形成映射关系的。 映射机制在一开始就会建立 */ var arg = arguments; console.log(arg); console.log(arguments); arg[0] = 100; console.log(x); // 100 arg[1] = 200; console.log(y); // undefined console.log(arg); console.log(arguments);&#125;;fn(10);// 1234567891011121314151617181920212223242526272829303132// JS严格模式，在当前作用域的第一行加上 \"use strict\"即可，这样在当前作用域中，就开启了Js的严格模式// \"use strict\"; // 整个Js都开启了严格模式，只对当前这个JS文件中的代码生效，下一个JS文件需要开启严格模式，第一行还是需要再次编写use strict; 真实项目中我们一般都会把JS文件合并压缩成一个导入页面/*function fn() &#123; \"use strict\"; // 只在当前作用中使用严格模式&#125;*/// 1. 严格模式下不支持arguments.callee/arguments.callee.caller// 2. 严格模式下arguments和形参没有映射机制// 3. 严格模式下不允许给一个对象设置重复属性名的// 4. 严格模式下函数执行，如果没有明确指定执行的主体（函数前面没有点.,不再像非严格模式下指向window,而是让this指向undefined,代表没有执行主体）严格模式下有执行主体，this就是谁，没有执行主体，就是undefined.~ function () &#123; \"use strict\"; function fn(a) &#123; arguments[0] = 100; console.log(a); &#125; fn(10); //10 var obj = &#123; n: 10, n: 20 &#125; console.log(obj.n);&#125;();~ function () &#123; function fn(a) &#123; arguments[0] = 100; console.log(a); &#125; fn(10); //100&#125;(); 1234567891011121314151617181920212223242526// 逻辑与&amp;&amp;,逻辑或||//1.在条件判断当中 if(1===1 &amp;&amp; 2===2)//2.在赋值操作中，有时也会用到； var a=1 || 2; 首先验证1是真假，如果为真，1赋值给a,反之，将2赋值给a;// var b=1 &amp;&amp; 2; 先验证1的真假，为真，结果是2,反之，将1赋值给bfunction fn(x, y) &#123; //验证传递的参数值，如果没有传递实参，让其默认值为零； x = x || 0; // 这种赋值方式并不严谨，x传值为false时，依然赋值0;但是项目中却非常常用，因为简单。 y = y || 0;&#125;function fn(callback) &#123; /* if(typeof callback==='function')&#123; callback(); &#125;*/ callback &amp;&amp; callback(); //上面if判断的简写版：默认callback要不然传函数，要不然就不传&#125;//3.逻辑与和逻辑或的混合模式 // 优先级： 逻辑与的优先级高于逻辑或//0 || 1 &amp;&amp; 2 || 2 &amp;&amp; 0 = 1 || 2 || 0 = 1//4.逻辑或的实战应用：形参赋值默认值（初始化形参）//在ES6新语法规范中可以直接给形参设置默认值function fn(x = 0) &#123; //如果x没有传递值，默认值是零，一旦传递值，不管传递的是啥，都是按照传递的值处理 console.log(x);&#125; 123456789101112131415// 5 5 6 2var a = 9;function fn() &#123; a = 0; return function (b) &#123; return b + a++; // b + a之后a自身再累加 &#125;&#125;var f = fn();console.log(f(5));console.log(fn()(5));console.log(f(5));console.log(a); 123456789101112var ary = [1, 2, 3, 4];function fn(ary) &#123; //传递进来的堆内存地址相同，所以第一步修改的是同一个堆内存中的ary[0] ary[0] = 0; // ary = [0]; // 修改了堆内存地址，与外部的已经不是同一个堆内存 ary[0] = 100; return ary;&#125;var res = fn(ary);console.log(ary);console.log(res); 1234567891011function fn(i) &#123; return function (n) &#123; console.log(n + i++); &#125;&#125;var f = fn(10);f(20);fn(20)(40);fn(30)(50);f(30);// 30,60,80,41 1234567891011121314var i = 10;function fn() &#123; return function (n) &#123; console.log(n + (++i)); &#125;&#125;var f = fn();f(20);fn()(20);fn()(30);f(30);// 31,32,43,44 12345678910111213141516171819202122232425262728293031323334353637383940/* * 1 和 new Number&#123;1&#125; * 区别： * 前面是基本数据类型，后面是引用数据类型值 * 相同点： * 都是Number类的实例 *//* * 函数类型： * 普通函数 * 构造函数（类：内置类和自己创建的类） * 对象类型： * 普通对象 * Math\\Json * 类的实例（数组、正则、日期等） * prototype或者_proto_ * arguments或者元素集合等类数组 * 函数也是一种对象 * -&gt; 万物皆对象 *//* * 1. 每一个函数（类）都有一个prototype（原型）属性，属性值是一个对象，这个对象中存储了供实例调取和使用的公有属性和方法； * 2. 在浏览器默认给原型prototype开辟的堆内存中，有一个属性叫constructor,存储的是当前类的函数； * 3. 每一个对象（实例）都有一个_proto_（原型链）属性，这个属性指向当前实例所属类的原型（不确定所属的类，都指向Object.prototype）。 */function Fn() &#123; this.x = 100; this.y = 200; this.getX = function () &#123; console.log(this.x); &#125;&#125;Fn.prototype.getX = function () &#123; console.log(this.x);&#125;Fn.prototype.getY = function () &#123; console.log(this.y);&#125;var f1=new Fn();var f2= new Fn(); 12345678910111213141516171819202122232425262728/* * 1 为啥不行？ * 事件绑定是异步编程，当触发点击行为，绑定的方法执行的时候，外层循环已经结束；方法执行产生私有作用域，用到的变量i不是私有变量，按照作用域查找机制，找到的是全局变量i（此时全局的i已经成为循环最后一次的结果） * * 2 如何解决 * 自定义属性 * 闭包 * ES6 */var box = document.getElementById(\"box\");var btnList = box.getElementsByTagName('button');for (var i = 0; i &lt; btnList.length; i++) &#123; btnList[i].onclick = (function (i) &#123; return function () &#123; console.log(i + 1); &#125; &#125;)(i);&#125;//每一轮循环都执行自执行函数，形成一个私有作用域（不销毁），里面设定一个私有变量i，让存储后期需要用到的索引// 点击触发方法执行，用到变量i，向对应的上级作用域查找i的值，而上级作用域中存储的i就是我们需要的索引// 基于闭包解决非常占用内存//ES6和闭包的机制类似，ES6中使用let创建变量，会形成块级作用域，当前案例中，每一轮循环都会形成一个块级作用域，把后续需要用到的索引i存储到自己的作用域中for(let i=0;i&lt;btnList.length;i++)&#123; btnList[i].onclick=function()&#123; console.log(i);&#125;&#125; 12345678910111213// 你以为你以为的就是你以为的var fullName = 'language';var obj = &#123; fullName: 'javascript', prop: &#123; getFullName: function () &#123; return this.fullName; &#125; &#125;&#125;console.log(obj.prop.getFullName()); // undefinedvar test = obj.prop.getFullName;console.log(test()); // language 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * 在实际项目中，基于面向对象开发的时候（构造原型设计模式），我们根据需要，很多时候会重定向类的原型（让类的原型指向自己开辟的堆内存） * 【存在的问题】 * 1,自己开辟的堆内存中没有constructor属性，导致类的原型构造函数缺失 * 解决方案：自己手动在堆内存中增加constructor属性 * 2,当原型重定向后，浏览器默认开辟的堆内存会被释放掉，如果原来已经存储了一些属性和方法，这些东西都会丢失 * 所以内置类的原型不允许重定向到自己开辟的堆内存中，因为内置类的原型上自带了很多属性和方法，重定向后都没了，这样是不被允许的。 */// 在原型上批量开发方法的时候，使用原型重定向function Fn() &#123;&#125;Fn.prototype = &#123; constructor: Fn, aa: 12, bb: 13, cc: 14&#125;function fun() &#123; this.a = 0; this.b = function () &#123; console.log(this.a); &#125;&#125;fun.prototype = &#123; b: function () &#123; this.a = 20; console.log(this.a); &#125;, c: function () &#123; this.a = 30; console.log(this.a); &#125;&#125;var my_fun = new fun();my_fun.b(); //0console.log(my_fun.a);my_fun.c(); //my_fun._proto_.c // 30console.log(my_fun.a);// 私有属性：自己堆内存中存储的属性相对自己来说是私有的// 公有属性：自己基于_proto_属性找到的属性相对自己来说是公有的 123456789101112131415161718192021222324252627282930313233var ary = [12, 23, 12, 23, 34, 34, 45];// 为啥ary.sort可以执行：因为sort是array.prototype上内置的属性方法，而ary是它的一个实例，可以基于_proto_找到原型上的这个方法，然后调取使用ary.sort(function (a, b) &#123; return a - b;&#125;);/* * 基于内置类的原型扩展方法，供他的实例调取使用 * 1. 我们增加的方法最好设置“my”前缀(前缀可以随便定义)，防止把内置方法重写 */Array.prototype.kpUnique = function kpUnique() &#123; // 方法中的this一般都是当前的实例，也就是我们要操作的数组 // ary._proto_.kpUnique() IE浏览器中屏蔽了我们对_proto_的操作 // Array.prototype.myUnique() ;// 这种方法极少使用 var obj = &#123;&#125;; for (var i = 0; i &lt; this.length; i++) &#123; var item = this[i]; obj.hasOwnProperty(item) ? (this[i] = this[this.length - 1], this.length--, i--) : obj[item] = item; &#125;; obj = null; return this;&#125;/*var a = ary.kpUnique(); // this:ary, 我们操作this相当于操作ary，方法执行完成，就会修改原数组// 此时方法执行的返回值是undefined; 原数组改变console.log(a);console.log(ary);// 执行sort返回的是排序后的数组，执行reverse()返回的也是数组，执行pop返回的是返回的那一项ary.sort(function (a, b) &#123; return a - b;&#125;).reverse().pop(); // js中的链式写法：保证每一个方法执行返回的依然是当前类的实例，这样就可以继续调取方法使用了。*/var max = ary.kpUnique().sort(function (a, b) &#123; return a - b&#125;).pop();console.log(ary); 12345678910// document.parentNode 和 document.parentnode的区别// 怎么规避多人开发函数重名问题使用单例模式规避把当前模块的属性和方法放在一个命名空间中（笔试的时候不要写太详细，阐述题不会表达可以手写代码）// javascript如何实现面向对象中的继承// 你理解的闭包是什么，优缺点？","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://abluecup.github.io/tags/javascript/"}]},{"title":"Javascript基础知识一","slug":"Javascript基础知识一","date":"2019-04-02T03:19:50.000Z","updated":"2019-04-02T05:23:40.280Z","comments":true,"path":"2019/04/02/Javascript基础知识一/","link":"","permalink":"https://abluecup.github.io/2019/04/02/Javascript基础知识一/","excerpt":"JavaScript，通常缩写为JS，是一种高级的，解释执行的编程语言。 JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。 它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。","text":"JavaScript，通常缩写为JS，是一种高级的，解释执行的编程语言。 JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。 它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。 Jascript 基础知识JS: 轻量级的客户端脚本编程语言； 编程语言HTML + CSS是标记语言编程语言是具备一定逻辑的，拥有自己的编程思想（面向对象编程[oop]、 面向过程编程） 面向对象编程 java c++ php c# (.net) js.. 面向过程编程 c.. 目前的Js已经不仅仅是客户端语言了，基于Node可以做服务器端程序，所以js是全栈编程语言 js 包括三部分 ECMAscript（ES） js语法核心 DOM document object model 文档对象模型， 提供各种API供js获取和操作html元素（dom元素） BOM brower object model 浏览器对象模型，提供各种API供js操作浏览器 ECMAScript它是Js的语法规划，JS中的变量、数据类型、语法规范、操作语句、设计模式等等都是ES规定的 变量(variable)定义：它不是具体的值，只是一个用来存储具体值的容器或者代名词 存储的值可以改变，所以称为变量 基于ES语法规范，在js中创建变量有以下规范 - var (ES3) - function (ES3) 创建函数（函数也是变量，只不过存储的值是函数类型而已） - let (ES6) - const (ES6) 创建常量 - import (ES6) 基于ES6的模块规范导出需要的信息 - class (ES6) 基于ES6创建类 123456789101112/** *语法： var [变量名] = 值; / *let [变量名] = 值; / *const [变量名] = 值; *function 函数名()&#123;&#125;**/...var n = 13;n = 15;const m = 100; 创建变量的命名规范 严格区分大小写 遵循驼峰命名法：按照数字、字母、下划线命名，数字不能作为开头，命名基于英文单词，拼写成一个完整的名字（第一个单词字母小写，其余每一个有意义的单词首字母大写） 语义化强一些 不能使用关键字和保留字： 在js中有特殊含义的叫关键字，未来可能成为关键字的叫做保留字 数据类型数据值是一门编程语言进行生产的材料。JS中包含的值有一下数据类型： 基本数据类型 （值） 数字 number 字符串 string 布尔值 boolean null undefined 引用数据类型 对象object 普通对象 数组对象 正则对象 日期对象 … 函数 function ES6中新增加的一个特殊的数据类型Symbol(唯一的值) 12345678910111213141516171819202122[基本数据类型] 数字类型中有一个特殊的值，叫 NaN (not a number 代表不是一个有效的数字，但是属于number类型) JS中所有用单引号或者双引号包裹起来的都是字符串，里面的内容是当前字符串中的字符（一个字符串由0到多个字符自称） boolean: true false[引用数据类型]var o=&#123;name: &apos;name&apos;, age: 9&#125; =&gt; 普通对象 由大括号包裹起来，里面包含多组属性名和属性值（包含多组键值对） &#123;&#125; 空对象var array = [1,2,3]; // =&gt; 中括号包裹起来， 包含零到多项内容，这种是数组对象 []空数组var reg = /-?(d|[1-9]\\d+))(\\.\\d+)?/g; /=&gt; 由元字符组成一个完整的正则 //不是空正则 当行注释 ^=^function fn()&#123;&#125;[Symbol] 创建出来的是一个唯一的值 var a = Symbol(&apos;珠峰&apos;); var b = Symbol(&apos;珠峰&apos;); a==b =&gt; false; const a = Symbol(&apos;flag&apos;); a 是唯一且不能改变的量 扩展： JS代码如何运行以及运行后如何输出结果[如何被运行] 把代码运行在浏览器中，浏览器内核来渲染解析； 基于Node来运行（Node也是基于V8引擎渲染和解析JS的工具) [如何输出结果] alert： 在浏览器中通过弹框的方式输出（浏览器提示框）； 12345alert();// =&gt; window.alert()alert(1+1) =&gt; &apos;2&apos; 基于alert输出的结果都会转换成字符串：把值（如果是表达式先计算出结果）通过toString()这个方法转化成字符串，然后再输出alert([12,23]) =&gt; &quot;12,23&quot;alert(&#123;name:&apos;xx&apos;&#125;) =&gt; &apos;[object Object]&apos; 对象.toString()结果是[object Object] confirm 和alert用法一致，只不过提示的框中有确定和取消两个按钮，所以它是确认提示框 123456var flag = confirm(&apos;确定要退出吗&apos;);if(flag)&#123; // 用户点击的是确定按钮&#125;else&#123; //用户点击的取消按钮&#125; prompt 在confirm的基础上增加输入框 console.log :在浏览器控制台输出日志 Elements: 当前页面中的元素和样式在这里都可以看见，还可以调节样式修改结构等； Console: 控制台 可以在JS代码中通过.log输出到这里，也可以在这里直接编写JS代码； Source: 当前网站的源文件都在这里 …… console.dir 比log的输出更详细（尤其是输出对象数据值的时候） console.table: 把一个JSON数据按照表格的方式输出.. (更多的console输出方法) 数据类型的详细剖析number数字类型NaN： not a number， 但它是数字类型isNaN: 检测当前值是否不是有效数字，返回true 代表不是有效数字，返回false代表是有效数字12345678910111213141516171819202122232425262728293031323334isNaN([value])isNaN(&apos;13&apos;) =&gt; falseisNaN(&apos;AA&apos;) =&gt; trueisNaN(true) =&gt; falseisNaN(false) =&gt; falseisNaN(null) =&gt; falseisNaN(undefined) =&gt; trueisNaN(&#123;age:9&#125;) =&gt; trueisNaN([12,23]) =&gt; trueisNaN([12]) =&gt; falseisNaN(/DS/) =&gt; trueisNaN(function()&#123;&#125;) =&gt; true重要： isNaN检测的机制1、首先验证当前要检测的值是否为数字类型的值，如果不是，浏览器会默认的把值转换为数字类型； 把非数字类型转化为数字 -其他基本类型转换为数字： 直接使用Number这个方法； [字符串转化为数字] 如果当前字符串中出现任意一个非有效数字字符，结果为NaN Number(&apos;13&apos;) =&gt; 13 Number(&apos;13a&apos;) =&gt; NaN Number(&apos;13.5&apos;) =&gt; 13.5 可以识别小数点 [布尔转数字] Number(true) =&gt; 1 Number(false) =&gt; 0 [其他] Number(null) =&gt; 0 Number(undefined) =&gt; NaN - 把引用数据类型值转换为数字： 先把引用值调取toString转化为字符串，然后把字符串调取Number转化为数字 Number(&apos;&apos;) =&gt; 0 ([]).toString =&gt; &apos;&apos;; isNaN([]) =&gt; false 2、当前检测的值已经是数字类型，是有效数字返回false,不是返回true (数字类型中只有NaN不是有效数字，其余都是有效数字) parseInt parseFloat 等同于Number,也是为了把其他值转化为数字类型和Number的区别在于字符串转换分析上Number出现任意非有效字符，即为NaNparseInt: 把一个字符串中的整数部分解析出来parseFloat: 把一个字符串中的小数（浮点数）解析出来 123456parseInt(&apos;13.5px&apos;) =&gt; 13parseFloat(&apos;13.5px&apos;) = 13.5parseInt(&apos;w13.5&apos;) =&gt; NaNparseInt从字符串最左边字符开始查找有效数字字符，并且转化为数字，但是一旦遇到非有效数字字符，查找结束parseFloat多识别一个字符. parseFloat(&apos;.2p&apos;) =&gt; 0.2 NaN的比较123(NaN == NaN) =&gt; false NaN和谁都不相等，包括和自己也不相等` 思考题： 有一个变量，存储的值不知道，我想检测它是否为一个有效数字，下面的方案是否可以123if(Number(num) == NaN)&#123; // 条件永远不成立 alert(&quot;num不是有效数字&quot;);&#125; 只有一种方案 123if(isNaN(num))&#123; alert(&quot;num不是有效数字&quot;);&#125; 布尔类型 只有两个值 true/false如何把其他类型转化为布尔类型 Boolean123Boolean(1) =&gt; trueBoolean(0) =&gt; false数字里面只有0和NaN是false,其余都是true ! 1!&apos;st&apos; 非、取反，先把其他数据类型转化为布尔类型，然后取反 !! 1否定之否定，肯定 规律 在js中只有 0 null undefined NaN 空字符串 转化为布尔类型的false,其余都转化为true null &amp; undefined 都代表空null ：空对象指针undefined ：未定义 null 一般是意料之中的没有（通俗理解都是认为手动的设置为null, 后面的程序中我们会再次给它赋值）1var num = null; // =&gt;null 是手动赋值的, 预示着我会把num变量的值修改 undefined 代表着没有，一般都不是人为控制的，大部分都是浏览器自主为空，后面可以赋值，也可以不赋值； 12var num;// 此时num会被浏览器分配一个值 undefined, 后面可以赋值，也可以不赋值 string其他数据类型转化为string类型().toString() 基本数据类型转化为string类型，直接使用引号包裹住字符； 引用类型转化为string类型 function(){} 直接使用引号包裹 普通对象， [object Object] 数组 [] =&gt; ‘’; [12] =&gt; ‘12’; [12,23] =&gt; ‘12, 23’; 正则对象，日期对象，直接使用引号包裹； object对象数据类型分为四类 普通对象特点 - 由大括号包裹起来； - 由0到多组属性名和属性值（键值对）组成； 属性是用来描述当前对象特征的，属性值是对这个特征的描述；(属性：键[key] 属性值：值[value])1234567891011121314151617181920212223242526272829var obj = &#123; name: &apos;kyle&apos;, age: 9&#125;// 对象的操作：对键值对的增删改查[获取] 语法： 对象.属性名 / 对象[属性名]obj.nameobj[&apos;name&apos;] 一般来说属性名都是字符串格式，属性值不固定，任何格式都可以[增/改]js对象中属性名是不允许重复的，是唯一的。obj.name = &apos;xxx&apos;;// 原有对象中存在name属性，此处是修改属性值obj.sex = &apos;man&apos;; // 原对象中不存在sex属性，此处是新增属性obj[&apos;age&apos;] = 12;[删]彻底删除delete obj.age // delete obj[&apos;age&apos;] 对象中不存在age属性了假删除：并没有移除属性，只是让当前属性的值为空obj.sex = null;// obj[&apos;sex] = null;obj.class // undefined;在获取属性值的时候，如果当前对象有这个属性名，可以正常取值(哪怕是null),但是如果没有这个属性名，则获取的值是undefinedvar obj = &#123;name:&apos;kyle&apos;, age: 9&#125;var name = &apos;peng&apos;;obj.name =&gt; &apos;kyle;obj[&apos;name&apos;] =&gt; &apos;kyle&apos;;obj[name] =&gt; undefined; 此处的name是一个变量，我们要获取的并不是属性名叫name,而是储存在name中的值 &apos;peng&apos;; 一个对象中的属性名不仅仅是字符串格式，还有可能是数字格式,遇到其他格式的先转化为字符串格式 123456789// chrome控制台下shift+enter换行var obj = &#123; name: 'kyle', 0:9&#125;// 数字格式用obj[0]和obj['0'],但是不能用obj.0// SyntaxError 语法错误 当我们存储的属性名不是字符串也不是数字格式时，会调用.toString()转化为字符串格式后，再进行存储 null undefined boolean 引用类型都可以先转化为字符串再储存值obj[{}] = 300; obj = {‘[object Object]’:300}, 获取的时候也是先把{}转化为字符串，然后再获取值 数组对象（对象由键值对组成）var oo = {a:12}var ary=[12,23];//=&gt; 12,23都是属性值，属性名呢？通过观察结果：数组对象的属性名是数字，我们把数字属性名成为当前对象的索引。ary[0], ary[‘0’] 数组和对象的关系： 数组是一种特殊的对象，属性名是数字 浅分析js的运行机制1、当浏览器(他的内核/引擎)解析和渲染JS的时候，会提供一个供JS代码运行的环境，我们把这个环境称为全局作用域(global scope);2、代码自上而下执行（之前还有一个变量提升阶段） =&gt;基本数据类型的值会存储在当前作用域下 var a =12; 有三步操作 1）在当前环境下开辟一个空间存储12； 2）声明一个变量名 a; 3) 把声明的变量和值关联起来，赋值操作叫做定义 var b=a; 基本数据类型值也叫值类型，是按照值来操作的：把原有的值复制一份放到新的空间或位置上，和原来的值没有关系. 1) 在当前环境下开辟一个空间存储12； 2） 声明变量 b 3) b 和 12 关联； a 和 b 没有关系； b =23 1) 开辟空间存储13; 2) b和13关联 变量和基本类型数据是一一对应关系； =&gt; 引用数据类型的值不能存储在当前的作用域下，因为可能存储的内容过于复杂，我们需要先开辟一个新的空间，把内容存储到这个空间中 1）开辟一个新的空间，把对象中的键值对依次存储起来（为了保证后面可以找到这个空间，此空间有一个16进制的地址） 2）声明一个变量 3）让变量和空间地址关联在一起（把空间的地址赋值给变量） 引用类型不是按值操作，是按照引用的地址操作：把原来空间的地址赋值给新的变量，但是原来的空间没有被克隆。这样就会出现多个变量关联的是同一个空间，相互之间就会存在影响。 作用域叫栈内存，存储引用类型数据值的叫堆内存栈内存：本身就是供JS代码执行的环境，所有的基本类型值都会直接在栈内存中开辟一个位置；堆内存：独立于栈内存的内存，存储引用类型中的数据值；对象存储的键值对，函数存储的是代码字符串 隔三行变色123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!Doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;style&gt;.box&#123; margin: 20px auto; width:300px;&#125;.box li&#123; line-height: 35px; padding: 0 5px; border-bottom: 1px dash #aaa; text-overflow: ellipsis; white-space: nowrap; overflow: hidden;&#125;.bg0&#123; background-color:pink;&#125;.bg1&#123; background-color:lightGreen;&#125;.bg2&#123; background-color:lightBlue;&#125;.hover&#123; background-color: orange;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=\"box\" id=\"box\"&gt;&lt;li&gt;剴；开放日哦个人头&lt;/li&gt;&lt;li&gt;jk;;;ssd&lt;/li&gt;&lt;li&gt;受到攻击；哦哦人啊个今儿个‘&lt;/li&gt;&lt;li&gt;地方igoerg'e'a'eanj；反对党哦【思伽尔和&lt;/li&gt;&lt;li&gt;让他脚痛医脚他已经对方如何【&gt;&lt;/li&gt;&lt;li&gt;kl;'df 梵蒂冈阿尔贡哦哦人啊个&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;// var oBox = document.getElementById(\"box\");//var oList = oBox.getElementsByTagName(\"li\");//console.log(oList);//var arr = ['red', 'green', 'blue'], n;//for(var i=0;i&lt;oList.length; i++)&#123; /**n = i % 3; oList[i].style.backgroundColor = arr[n];*/ //oList[i].className = 'bg' + i%3; // oList[i].style.backgroundColor = i%3 == 0 ? 'lightBlue' : (i % 3 == 1 ? 'lightGreen': 'red');////&#125;function changeColor()&#123; var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); var arr = ['pink','lightGreen','lightBlue']; for(var i = 0; i&lt;oList.length; i++)&#123; oList[i].style.backgroundColor = arr[i % 3]; //oList[i]. &#125;&#125;function changeColor2()&#123; var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); var arr = ['pink', 'lightBlue', 'lightGreen']; for(var i=0; i&lt; oList.length;i++)&#123; if(!(i % 3))&#123; oList[i].style.backgroundColor='lightBlue'; &#125;else&#123; if(i%3 == true)&#123; oList[i].style.backgroundColor='lightGreen'; &#125;else&#123; oList[i].style.backgroundColor='pink'; &#125; &#125; &#125; &#125;function changeColor3()&#123; // 每次循环一组，但是会出现当前这一组不够三个，这样会报错 var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); for(var i=0;i&lt;oList.length;i+=3)&#123; oList[i].style.backgroundColor = 'red'; // if(i+1 &lt;= oList.length -1;) oList[i+1].style.backgroundColor = 'green'; // if(i+2 &lt;= oList.length - 2) oList[i+2].style.backgroundColor = 'blue'; &#125;&#125; changeColor();/**三种方案：1. 依次遍历每一个Li，通过索引除3的余数，设置当前行的样式；2.*/function highLight()&#123; var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); var arr = ['red', 'green','blue']; var arr1 = ['pink','lightGreen','lightBlue']; var n; for(var i=0;i&lt;oList.length;i++)&#123; //n = i % 3; //console.log(n); oList[i].myIndex = i;// 每一次循环的时候都给每一,个li设置一个自定义属性，属性值存储的是当前li的索引 oList[i].addEventListener('mouseover', function()&#123; // 有回调函数，一般是异步执行，放在任务队列里 this.style.background = arr[this.myIndex % 3]; &#125;); oList[i].addEventListener('mouseout', function()&#123; this.style.background = arr1[this.myIndex % 3]; &#125;);// 绑定方法的时候，还没有执行，存储的是字符串,当循环结束，我们手动去操作li的时候，方法才会才会执行，此时changTab(i)的变量i 已经是3了 &#125;&#125;// css 优先级： 行内，ID，样式类，标签highLight();/***css 我们把hover 放在bg的后面，当元素的class=\"bg hover\"的时候，元素呈现hover的样式鼠标滑过，新增样式类hover,鼠标离开，把新增的样式类移除**/&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS中的数据类型转换JS中的数据类型【基本数据类型】 数字 number 字符转 string boolean null undefined [引用类型数据] 对象 普通对象 数组对象 正则对象 日期对象 数学对象 … 函数 function 真实项目中，根据需求，我们往往需要把数据类型之间进行转换（规则和规则之间是相互独立的） 把其他数据类型转化为number类型1. 发生的情况 isNaN检测的时候，当检测的值不是数字类型，浏览器会自己调用Number方法把它转化为数字类型，然后再检测是否为非数字； 123isNaN('3') =&gt; falseNumber('3') =&gt; 3isNaN(3)=&gt; false 基于parseInt / parseFloat 去手动转化为数字； 数学运算 + - * / (+ 不仅仅是数学运算，还可能是字符串拼接) 1234567893 -1 =&gt; 2Number(3) =&gt; 3'3PX -1' =&gt; NaN'3PX' + 1 =&gt; 3PX1var i = '3';i+1 =&gt; '31'i += 1 =&gt; '31'i++ =&gt; 4 i++就是单纯的数学运算，已经摒弃掉字符串拼接的规则 基于 “==” 比较的时候，有时候也会把其他值转化为数字类型 … 2. 转化规律 //=》 转换的方法： Number(浏览器自行转换都是基于这个方法完成的) 12345678910111213141516【把字符串转化为数字】只要遇到一个非有效数字，结果就是NaN; ''变成数字类型是0' '=&gt; 0;' '=&gt;0;'\\n' =&gt; 0; 换行符（多个空格）'\\t' =&gt; 0; 制表符（一个tab键是四个空格）【布尔类型】true =&gt; 1false =&gt; 0;[把没有转换为数字]null =&gt; 0;undefined =&gt; NaN[引用类型转换为数字]首先转换为字符串（toString()）,然后再转换为数字（Number） 把其他类型值转换为字符串1. 发生的情况 基于alert / confirm / prompt /document.write等方法输出内容的时候，会把输出的值转换为字符串，然后再输出 1alert(1) =&gt; '1' 基于 + 进行字符串拼接的时候 把引用值转换为数字类型值的时候，首先会转换为字符串，然后再转换为数字 给对象设置属性名，若属性名不是字符串，先转换为字符串，然后再当作字符串存储到对象中（对象的属性名只能是字符串或者数字） 手动调用toString/toFixed/join/String等方法的时候，也是为了转换为字符串 1234var n = Math.PI; // 圆周率n.toFixed(2) // '3.14'var ary = [12,23,34]ary.join('+') // 12+23+34; … 2. 转换规律123456789101112// 浏览器默认调用的方法都是 toString()[除了对象，都是你理解的转换，也就是直接加引号]1 // '1';null =&gt; 'null'[] =&gt; '';[12] =&gt; '12';[12,23] =&gt; '12,23'(function()&#123;&#125;).toString() // \"function()&#123;&#125;\"【对象】&#123;name:'xxx'&#125; =&gt; '[object Object]'&#123;&#125; =&gt; '[object Object]'不管是什么样的普通对象，最后结果都一样 把其他值转为布尔类型值1.发生的情况 基于!/!!/Boolean()方法转换； 条件判断中的条件最后都会转换为布尔类型 …123456if(n)&#123; // 把n的值转换为不二验证条件的真假&#125;if('3px' + 3)&#123; // 先计算表达式的结果'3px3',把结果转换为布尔类型值true,&#125; 2.转换规律除了 ‘’（空字符串）， null， undefined， 0， NaN转换为boolean是false外，其他都是true. 特殊情况：数学运算和字符串拼接 “+”123456789当表达式中出现字符串，就是字符串拼接，否则就是数学运算1+ true // 2 数学运算\"1\" + true // \"1true\" 字符串拼接[12] + 10 // '1210' 虽然现在没看到字符串，但是引用类型转换为数字，会先转换为字符串，所以变为了字符串拼接（&#123;&#125;）+ 10 // \"[object Object]10\"[] + 10 // '10'&#123;&#125; + 10 // 10 这个和以上说的没有任何关系，因为他根本就不是数学运算，也不是字符串拼接，他是两部分代码 &#123;&#125;代表一个代码块（块级作用域），+10才是我们的操作；严格来说应该分成两部分：&#123;&#125;;+10; 1234512 + true + false + null + undefined + [] + 'hello' + null +undefined + [] + true // \"NaNhellonullundefinedtrue\"13 + NaN = NaNNaN +[] = \"NaN\"12+[]// '12' 特殊情况：&quot;==&quot;在进行比较的时候，如果左右两边数据类型不一样，则先转换为一样的类型，再进行比较。 对象 == 对象；不一定相等，因为对象操作的是引用地址，地址不相同，则不相等 12345&#123;name:'xx'&#125; == &#123;name:'xx'&#125; //falsevar obj1=&#123;&#125;;var obj2 = obj1;obj2 == obj1 //true 对象==数字，把对象转换为数字，然后再比较； 对象==布尔：把对象转换为数字，把布尔也转换为数字； 对象==字符串：把对象转化为数字，把字符串也转化为数字 字符串 == 数字： 字符串转化为数字 字符串== 布尔： 都转化为数字 布尔==数字：把布尔转换为数字1234567不同类型值的比较，都是把其他值转换为数字类型值，在进行比较null == undefined //truenull === undefined //falsenull 和 undefined 和其他值都不相等NaN == NaN //false以上需要特殊记忆的 123456789101==true // true2==true //false 两个情况比较的时候，都转化为数字，这里是把true变为1，而不是把2变为true[] == [] // false 同类型之间直接比较，对象的引用地址不一样，所以是false![]==[]// ![]是false,类型不一样，转化为数字是0，[]转化为数字是0 ，结果是true[]==false// true 0 == 0[] == false // true 都转化为数字 0==0[]==true // false![] == false; // 先算![] == false; false == false ; 结果是true![]==true;// false 操作数组的常用方法数组也是对象数据类型的，也是由键值对组成的123456789101112 var ary =[12,23,34];/***结构* 0： 12* 1：23* 2：34*length:3*/1.以数字为索引，从零开始递增；2、有一个length属性存储的是数组的长度ary[0]// 获取第一项ary[2] ary[ary.length-1] // 获取最后一项 数组中每一项的值可以是任何数据类型的12345// 多维数组var ary = [ &#123;name:&apos;xx&apos;,age:9&#125;, &#123;name:&apos;yy&apos;,age:10&#125;]; 数组当中的常用方法 按照四个维度记忆： 方法的作用 方法的参数 方法的返回值 原有的数组是否改变 push 向数组 末尾 追加新的内容 \\参数：追加的内容，可以是一个，也可以是多个\\返回值： 新增后数组的长度\\原有数组改变 1234567var ary = [12,23,34]ary.push(100); // 4ary // [12,23,34,100]ary.push(200,300);//6ary //[12,23,34,100.200.300]ary.push(&#123;name:'xx'&#125;)//7ary // [12,23,34,100,200,300, &#123;name:'xx'&#125;] pop 删除数组最后一项\\无\\返回值： 被删除的那一项内容\\原有数组改变 123var ary = [12,23,34];ary.pop(); // 34ary // [12,23] shift 作用：删除数组中的第一项\\参数：无\\返回值：被删除的那一项\\原数组改变 基于shift删除数组中的第一项，第一项被删除后，原有后面的每一i选哪个的索引都要向前提一位 unshift 作用：向数组开始位置追加新内容给\\参数：新增的内容\\返回值：新增后数组的长度\\原有数组改变 splice 基于splice可以对数组进行很多操作：删除指定位置的内容，向数组指定位置增加内容，还可以修改指定位置的内容 删除 12345语法：ary.splice(n,m) // 从索引n开始删除m个内容参数：n -&gt; 索引； m -&gt; 要删除的个数返回值： 把删除的部分以一个新数组返回原有数组改变m不写的话或者删除的个数大于最大长度，是指从索引开始删除到数组末尾 新增 1234ary.splice(n,0,x,...)从索引n开始删除0项，把x或者更多内容存放到数组中索引n的前面返回值： [] 因为一项都没有删除原有数组改变 修改 123ary.splice(n,m,x,...)修改的原理就是把原有的内容删除掉，然后把新的内容放入数组返回值是删除内容组成的数组 12345678910需求扩展1、删除数组最后一项，有几种办法： ary.pop();ary.splice(ary.length-1);ary.length--;// 不建议基于delete删除，虽然内容没有了，但是数组的length没有改变1、向数组末尾追加新的内容，有几种办法；ary.push();ary.splice(ary.length,0,x); // x是要添加到索引的前面，所以不能是ary.lengthary[ary.length] = x; slice作用：在一个数组中，按照条件查找出其中的部分内容；参数： 两个参数 n,m; 从索引n开始找到索引m处，但是不包含m; m不写的话，查到数组末尾返回值： 以一个新数组存储查找的内容；原有数组不会改变； ary.slice(0);ary.slice(); // 数组克隆数组 concat作用：实现多个数组（或者值）的拼接参数：数组或者值返回值：拼接后的新数组原有数组不变ary1.concat(ary2,’kyle’,ary3)[].concat(ary1,ary2,’kyle’,ary3) 可以基于空数组作为拼接的开始，再括号中排列拼接的顺序 toString作用：把数组转化为字符串参数：无返回值：数组中每一项用逗号分隔的字符串原有数组不变 join作用：和toString类似，也是把数组转化为字符串，但是可以设置变为字符串之后每一项和每一项之间的连接符参数：指定的连接符返回：字符串原有数组不变 reverse作用：把数组倒过来排列参数：无返回值：排列后的新数组原有数组改变 sort作用：给数组排序参数：无或者是个函数返回值：排序后的新数组原有数组改变 sort在不传递参数的情况下只能处理10以内的排序在真实项目中，基于sort排序，我们都需要传递参数123ary.sort(function(a, b)&#123; return a-b; //升序 return b-a 降序&#125;) indexOf / lastIndexOf这两个方法不兼容IE低版本浏览器(IE678)作用：返回当前项在数组中第一次和最后一次出现的索引参数：要检测的索引返回：索引原有数组不变1234// 验证数组中是否含有某一项if(ary.indexOf(100) &gt; -1)&#123;// 验证数组中是否含有100&#125; 第一阶段我们不深入研究这些方法，搞懂这些方法需要了解OOP/作用域/回调函数等，第二阶段再去研究 数组去重123456789101112131415161718192021/*** 1. 定义一个空对象；* 2. 将数组中的值以当作属性名和属性值存入obj中，之前要先判断obj中是否含有此属性名， typeof ,有则删除，没有则赋值*/var ary = [1, 3, 5, 4, 3, 34, 56, 43, 34];var obj = &#123;&#125;;for (var i = 0; i &lt; ary.length; i++) &#123; var item = ary[i]; if (typeof obj[item] !== 'undefined') &#123; // 存在删除 //ary.splice(i, 1, ary[ary.length - 1]); // 为避免因数组过长而引起的数组塌陷，我们将数组末尾的值赋值给当前值，因为当前值已经在obj中存在，所以没有必要再替换，直接删除最后一项即可； ary[i] = ary[ary.length - 1]; ary.length--; i--; // 当前项已经不是原来的值了，要重新检测当前值，所以i--; continue; &#125; else &#123; obj[item] = item; &#125;&#125; 字符串中的常用方法JS中关于JS的一些细节知识 在JS中所有用单引号或者双引号包起来的都是字符串，每一个字符串是有0到多个字符组成；12345var str = 'kylepeng';str.length // 字符串长度str[100] -&gt; undefined;字符串中的每一个字符都有一个自己对应的索引，也有类似于数组一样的length代表自己的长度 字符串是基本类型数据，字符串的每一次操作都是值直接的进行操作，不想数组一样是基于空间地址来操作的，所以不存在原有字符串是否改变这一说，肯定都是不变的 常用方法charAt/charCodeAt作用：charAt根据索引获取指定位置的字符； charCodeAt不仅仅获取字符，它获取的是字符对应的Unicode编码值（ASC II码值）参数：索引返回值：字符或者对应的编码123456789 var str = 'sdfsdfse'; str.charAt(0) // s str.charAt(100) // ''空字符串 str[100] // undefined //当索引不存在的时候，str[x]获取的值和数组一样，结果是undefined;str.charCodeAt(0) //115 得到的编码是ASC II中对应的十进制编码'你'.charCodeAt() //20320 中文也有对应的编码//String.fromCharCode(122) // 'z' 通过编码找到对应的字符 indexOf/lastIndexOf获取当前字符在字符串中第一次出现或最后一次出现的索引，用以判断字符串中是否包含某个字符，有这个字符，返回索引，没有这个字符，返回-1 slice作用：str.slice(n,m)从索引n开始到索引m止，不包含m,把找到的字符当作新字符串返回 substring和slice语法一摸一样唯一的区别在于，slice支持负数索引，substring不支持负数索引str.substring(-3,-1) // “”str.substring(-3,1) // “s” substr也是字符串截取的方法str.substr(n,m) 从索引n开始，截取m个字符支持负数索引，负数索引指的是字符串总长度+负数索引和substring一样，第二个参数不写，截取到末尾，但是支持第一个索引为负数 toUpperCase / toLowerCase实现字符大小写的转化 split和数组中的join相对应，join是把数组中的每一项按照指定的连接符变成字符串，split是把字符串按照指定的分隔符，拆分成数组中的每一项。 replace把字符串中的原有字符进行替换参数： 原有字符， 要替换的新字符返回值： 替换后的字符串// =》在不使用正则的请情况下，每执行一次replace,只能替换一次 真实项目需求时间字符串格式化有一个时间字符串 ‘2018-4-4 16:6:8’, 我们想基于这个字符串获取到”04月04日 16时06分” 123456789101112131415161718192021222324252627282930313233343536// 2018-4-4 16:6:8 =&gt; 04月04日 16时06分 var str = '2018-4-4 16:6:8'; var ary = str.split(' '); var ary1 = ary[0].split('-'); var ary2 = ary[1].split(':'); var month = ary1[1], date = ary1[2], hour = ary2[0], minute = ary2[1]; function addZero(n) &#123; if (n &lt; 10) &#123; n = '0' + n; &#125; return n; &#125; var newStr = addZero(month) + '月' + addZero(date) + '日 ' + addZero(hour) + '时' + addZero(minute) + '分'; console.log(newStr); // 正则方法 ~ function(pro) &#123; pro.formatTime = function(template) &#123; template = template || '&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒'; var ary = this.match(/\\d+/g); template = template.replace(/\\&#123;(\\d+)\\&#125;/g, function() &#123; var n = arguments[1]; val = ary[n] || '0'; val &lt; 10 ? val = '0' + val : null; return val; &#125;); return template; &#125; &#125;(String.prototype); console.log(str.formatTime()); console.log(str.formatTime('&#123;1&#125;月&#123;2&#125;日')); URL地址问号传参解析12345678910111213141516171819202122232425262728/** *https://www.zhufeng.cn/stu/?lx=1&amp;name=aa&amp;sex=man#teacher // #后面的成为哈希值HASH,这个值可能有，可能没有，我们需*要处理，有的话我们需要过滤掉 * 1、先找到问号，把问号后面的信息截取下来即可 * A、首先我们需要验证是否存在#哈希值，存在我们从问号开始截取到#，不存在我们直接截取到字符串末尾 * 2、以&amp;进行拆分（数组） * 3、 遍历数组中的每一项，把每一项按照=拆分，把拆分后的第一项作为对象的属性名，第二项作为属性值进行存储即可 */function getURL(url) &#123; //var str = url.substring(str); var indexASK = url.indexOf('?'); var indexWell = url.indexOf('#'); var str; // # 可能有，可能没有 if (indexWell &gt; -1) &#123; // # 存在 str = url.substring(indexASK+1,indexWell); &#125; else &#123;// 截取到末尾 str = url.substr(indexASK+1); &#125; var ary = str.split('&amp;'); var obj=&#123;&#125;; for(var i=0;i&lt;ary.length;i++)&#123; var item =ary[i], itemAry = item.split('='); obj[itemAry[0]]=itemAry[1]; &#125; return obj;&#125;console.log(getURL('https://www.zhufeng.cn/stu/?lx=1&amp;name=aa&amp;sex=man#teacher')); JS中的MathMath称为数学函数，但是它属于对象类型的之所以叫做数学函数，是因为Math这个对象中提供了很多操作数字的方法 Math.abs取绝对值 Math.ceil / Math.floor向上或者向下取整 Math.round四舍五入 Math.round(-10.5) =&gt; -10; Math.round(-10.51) =&gt; -11 Math.sqrt开平方 pow取幂 n的m次方Math.pow(2,10) =&gt; 1024 max/min获取最大值和最小值 Math.PI圆周率 Math.random()获取0到1之间的随机小数Math.ceil(Math.random()10); // 1-10之间的随机整数Math.floor(Math.random()(m-n)+n);获取n-m之间的随机整数 JS中的判断语句 if/else if/else在JS中检测数据类型的方式： typeofinstanceofconstructorObject.prototype.toString.call() 1234567typeof value //检测value的数据类型返回值：使用typeof检测出来的结果是一个字符串，字符串中包含着对应的数据类型：\"number\",'string','object','undefined','function','boolean'typeof null // object null代表空对象指针，没有指向任何的内存空间typeof // 检测数组/正则/对象，返回结果都是object,也就是基于这种方式无法细分对象 typeof // 是逻辑运算符，不是方法 三元运算符语法： 条件？成立做的事：不成立做的事；12345678910 if(num&gt;10)&#123;num++&#125;else&#123;num--&#125;num&gt;10? num++ : num--;//如果三元运算符当中，如果有一步步需要做任何处理，我们用 null/undefined/void 0占位即可if(num&gt;10)&#123;num++&#125;num&gt;10? num++ : null;// 如果需要执行多项任务，用小括号括起来，每条操作语句之间用逗号隔开num&gt;10? (num++, num+=10):null; switch case用于变量或者表达式等在不同之情况ia的不同操作，每一种case结束后都要加break(结束整个判断)12345678910111213141516171819202122switch(n)&#123; case x: ... break; case y: ... break; default: z; &#125;// switch case 中每一种case情况的比较都是基于 === 绝对相等来完成的。//不加break，后面的条件不管是否成立，都会被执行，利用此机制，我们可以完成一些特殊的处理，例如：如果num等于10和5，都做同一种事情,那么不用加break,写在一块即可。switch(num)&#123; case 10: case 5: num++; break; default: num=0; &#125;// 真实项目中，我们基本使用===,保证代码的严谨性 函数函数在js中，函数就是一个方法（一个功能体），基于函数一般都是为了实现某个功能；函数诞生的目的就是为了实现封装：把闪现一个功能的代码封装到一个函数中，后期想要实现这个功能，只需要把函数执行即可，不必要再次编写重复的代码，起到了 低耦合，高内聚（减少页面中的冗余代码，提高代码的重复使用率）的作用 语法：ES3 标准创建函数function 函数名([参数]){ 函数体；实现功能的代码} 函数名(); 执行函数 ES6标准：创建箭头函数let 函数名(变量名) = ([参数]) =&gt; { 函数体}函数名();123let fn=()=&gt;&#123; //...&#125; 函数作为引用类型的一种，它也是按照引用地址来操作的 函数的运行机制 函数也是引用类型，首先会开辟一个新的堆内存，把函数体中的代码当作字符串存储到内存中（对象向内存中存储的是字符串） 把开辟到堆内存的地址赋值给函数名； 此时我们输出fn代表当前函数本身，fn()是执行函数fn,所以是否加()是两种不同本质的操作； 【函数执行】目的：把之前存储在堆内存中的字符串变为真正的JS代码自上而下执行，从而实现应用的功能；1.函数执行，首先会形成一个私有作用域：一个供代码执行的环境，也是也个栈内存；2.把之前在堆内存中存储的代码字符串复制过来，变为真正的JS代码，在新开辟的栈内存中自上而下执行 【函数中的参数】参数：是函数的入口，当我们在函数中封装一个功能，发现一些原材料不确定，需要执行函数的时候用户传递进来才可以，此时，我们就基于参数的机制，提供出入口即可。12345678function sum(a, b) &#123; //此处的参数叫形参，形参变量 // a , b分别对应两个数字； return a + b;&#125;sum(1, 2); // 1,2是实参，是具体的数据值sum(10) // a =10, b = undefined;sum() // a= undefined b=undefined;sum(1, 2, 3); // a=1,b=2;3没有形参变量接收,实参一定是具体的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .tabBox &#123; width: 500px; margin: 20px auto; &#125; .tabBox ul &#123; position: relative; top: 1px; /* 相对自己之前的位置向下移动1px;*/ &#125; .tabBox ul li &#123; display: inline-block; margin-right: 10px; padding: 0 10px; line-height: 33px; border: 1px solid #aaa; cursor: pointer; &#125; .tabBox ul li.active &#123; font-weight: bold; border-bottom-color: #fff; /* 当前Li的下边框覆盖了div的边框，我们让li的下边框的颜色是白色，这样看上去没有边框了*/ &#125; .tabBox div &#123; display: none; line-height: 148px; text-align: center; border: 1px solid #aaa; &#125; .tabBox div.active &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"tabBox\" id=\"tabBox\"&gt; &lt;ul&gt; &lt;li class=\"active\"&gt;新闻&lt;/li&gt; &lt;li&gt;电影&lt;/li&gt; &lt;li&gt;音乐&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"active\"&gt;金三胖来华访问&lt;/div&gt; &lt;div&gt;红海行动&lt;/div&gt; &lt;div&gt;fadden&lt;/div&gt; &lt;/div&gt; &lt;script&gt; /* * [思路] * 1. 给所有的Li绑定点击事件，当点击任何一个Lide时候，都做第二步骤 * 2. 可以先让所有的li &amp; div的class（className = ''）都为空，再让 当前点击的这个li和对应的div有active这个样式类即可 */ var tabBox = document.getElementById('tabBox'); var tabList = tabBox.getElementsByTagName('li'); var divList = tabBox.getElementsByTagName('div'); for (var i = 0; i &lt; tabList.length; i++) &#123; // tabList[i] : 每一轮循环当前要操作的对象 tabList[i]['myIndex'] = i; tabList[i].onclick = function() &#123; //事件绑定：给当前元素的某一个事件绑定一个方法，绑定的时候方法没有执行（属于创建一个方法），挡在页面中手动触发点击事件的时候绑定的方法才会执行 // tabList[i] // this代表当前的li changeTab(this.myIndex); &#125; &#125; /* * 自定义属性方案 obj.属性名 = 属性值 */ //=&gt; 封装一个方法，完成页卡切换 function changeTab(n) &#123; // n是形参，当执行这个方法的时候，会把当前点击的这个li的索引传递过来 //=&gt; 1. 所有都没有选中样式 for (var i = 0; i &lt; tabList.length; i++) &#123; tabList[i].className = ''; divList[i].className = ''; &#125; //=&gt; 2. 当前点击的有选中样式 tabList[n].className = 'active'; divList[n].className = 'active'; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 隔行变色12345678910111213141516171819 /* nth-child(N) : 当前容器所有子元素的第N个 .box li:nth-child(1): box容器中所有子元素中的第一个并且标签名是Li // 先获取第一个，在验证第一个是不是Li nth-of-type(n): 先给当前容器按照某一个标签名进行分组，获取分组中的第n个 .box li:nth-of-type(1) 先获取box中所有的li,再获取Li中的第一个 even 是偶数 odd 是奇数 */ ul.box &#123; list-style: none; &#125;/* .box li:nth-of-type(even) &#123; background-color: #0b5d81; &#125;*/ 1234567891011121314151617181920212223242526272829303132333435/* * document.getElementById 在整个文档中，通过元素的id获取元素对象 * getElementById 是获取元素的方法，document限定了获取元素的范围，我们把这个范围称之为：“上下文”[context] * class一般都是设置样式，id一般都是供js获取元素 * 1. 通过getElementById获取的元素是一个对象数据类型的值（里面包含内置的属性）typeof oBox =&gt; 'object' * 2. 分析包含的属性： * className:存储的是一个字符串，代表当前元素的样式类名； * id:存储的是当前元素的id值，也是字符串类型 * innerHTML: 存储当前元素中所有的内容，包含html标签 * innerText: 存储当前元素中所有的文本内容，不包含html标签 * onclick: 元素的一个事件属性，基于这个属性，可以给当前对象绑定事件 * onmouseover(鼠标滑过) onmouseout（鼠标离开） * style: 存储当前元素的 行内样式值 ；获取和操作的都只能是标签上的行内样式，写在样式表中的样式，无法基于这个属性获取到 */var oBox = document.getElementById('box');/* * 想要修改元素样式，有两种方法： * 1. 通过style修改行内样式 * 2. 基于className属性修改box的样式类，从而改变样式；oBox.className += \" bgColor\"; *//* * [context].getElementsByTagName ： 在指定上下文中，通过元素的标签名获取一组元素集合，上下文是我们自己来指定的 * 1. 获取的结果是一个元素集合(HTMLCollection)，它也是对象数据类型，结构和数组相似（数字索引，length代表长度），但是不是数组，我们把它叫做“类数组”； * 2. 通过索引获取到具体的某一个li即可， oList.length代表长度； * 3. 集合中的每一项存的值又是一个元素对象，包含很多内置属性，例如id/className */var oList = oBox.getElementsByTagName('li');//console.log(typeof oList);for (var i = 0; i &lt; oList.length; i++) &#123; if (i % 2 !== 0) &#123; // oList[i].style.backgroundColor = 'lightblue'; oList[i].className += 'bgColor'; &#125;&#125; 扩展：除自定义属性外，还有 let方案 柯里化 惰性函数123for(let i=0;i&lt;tabList.length;i++)&#123; changeTab(i); &#125; 函数执行的时候，都会形成一个全新的私有作用域（私有栈内存），目的是： 把原有堆内存中存储的字符串表为JS执行 保护里面的私有变量不受外界的干扰（和外界是隔离的）我么把函数执行的这种保护机制，称为闭包； 函数的入口：形参函数的出口：返回值 return 把函数运行的结果（或者函数体中的部分信息）拿到函数外面去使用return 返回的永远是一个值，即函数处理的结果fn(10,20) =&gt; 代表的是函数执行（不仅如此，他还代表函数执行后，返回的结果）如果当前函数没有return, 或者return啥也没有返回，则函数执行的结果是undefinedreturn 还有一个作用，类似与循环中的break,能强制结束函数体中的代码的执行 arguments形参是有自己的局限性的，我们需要具体的知道也难怪乎执行的时候传递实参数量、顺序等，才可以使用形参变量定义对应的入口arguments:函数内置的实参集合（内置：函数天生就存在的机制，不管你是否设置了形参，也不管你是否传递了实参，arguments都有，始终存在） arguments 是类数组（不是数组，不能使用数组中的方法） 即使设置形参变量，形参该是什么值还是什么值，但是arg始终存储的是所有的传递进来的实参 argumnents.callee 存储的是当前函数本身 arguments.callee === fn1234567891011// 任意值求和 function sum() &#123; //console.log(arguments); var total = null; for (var i = 0; i &lt; arguments.length; i++) &#123; total += (isNaN(Number(arguments[i])) ? null : Number(arguments[i])); &#125; return total; &#125; console.log(sum(1, 2, '6')); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; #codeBox &#123; display: inline-block; width: 80px; height: 35px; line-height: 35px; border: 1px solid #aaa; text-align: center; font-size: 18px; letter-spacing: 5px; &#125; #link &#123; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"codeBox\"&gt;&lt;/div&gt; &lt;a id=\"link\" href=\"javascript:;\"&gt;看不清楚，换一张&lt;/a&gt; &lt;!--阻止a标签跳转--&gt; &lt;script&gt; /* * 生成一个四位随机验证码 * =&gt; 数字+字母 * =&gt; 照图片 * =&gt; 滑动拼图 * =&gt; 问答类 * =&gt; 点击汉字拼成语 * =&gt;把倒着的文字或者图片正过来 */ var codeBox = document.getElementById('codeBox'), link = document.getElementById('link'); //=&gt;编写一个生成四位随机验证码的方法 function queryCode() &#123; // 准备验证码获取的范围 //2.我们只需要准备四个索引，即可在codeare中通过charAt方法获取到四个字符，把四个字符拼接成字符串就是我们需要的验证码 var str = ''; for (var i = 0; i &lt; 4; i++) &#123; var char = codeArea.charAt(Math.floor(Math.random() * codeArea.length)); if (str.indexOf(char) &gt; -1) &#123; i--; continue; &#125; str += char; &#125;; return str; &#125;; function queryCode2() &#123; var codeArea = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890'; var result = ''; while (result.length &lt; 4) &#123; var n = Math.floor(Math.random() * 62); var char = codeArea.charAt(n); if (result.indexOf(char) === -1) &#123; result += char; &#125; &#125; return result; &#125; link.onclick = function() &#123; codeBox.innerHTML = queryCode(); &#125; codeBox.innerHTML = queryCode(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM及常用方法DOM树（DOM tree）当浏览器加载HTML页面的时候，首先就是DOM结构的计算，计算出来的DOM结构就是DOM树（把页面中的HTML标签像树状结构一样，分析出之间的层级关系）；window -&gt; document -&gt;htmlDOM树描述了标签和标签之间的关系，我们只要知道任何一个标签，都可以依据DOM中提供的属性和方法，获取到页面中任意一个标签或者节点 JS中获取DOM元素的方法getElementById通过元素的id获取指定的元素对象 document.getElementById,此处的document限定了获取元素的范围，我们称之为上下文context getElementById的上下文只能是document; 严格意义上一个页面中的id是不能重复的，浏览器规定在整个文档中即可以获取这个唯一的id 2.如果页面中的id重复了，我们基于这个方法，只能获取到第一个元素，后面相同的id元素，无法获取3.在IE67浏览器中能够，会把表单元素input的name属性值当作Id来使用（建议：以后使用表单元素的时候，不要让Name和id有冲突）[context]getElementsByTagName在指定的上下文中，根据标签名获取一组元素集合（HTMLCollection）；1.获取的元素集合是类数组，不能直接使用数组中的方法；2.它会把当前上下文中子子孙孙（后代）层级内的标签都获取到（获取到的不仅仅是子集元素）；3.基于这个方法，获取到的永远都是一个集合（不管里面是否有内容，也不管具体有多少项，他都是一个容器或者集合），如果想操作集合中的具体的某一项，需要基于索引获取才可以。[context]getElementsByClassName在指定的上下文中，基于元素的样式类名（class=’xxx’）获取到一组元素集合真实项目中，我们经常基于样式类来给元素设置样式，所以在JS中，我们也会经常基于样式类来获取元素，但是此方法在IE678下不兼容getElementsByName1.上下文只能是document,在整个文档中，基于元素的name值获取一组节点集合（也是一个类数组）2.在IE浏览器中（IE9及以下版本），只对表单元素的name属性起作用（正常来说，我们项目中只会给表单元素设置name,给非表单元素设置name,其实是一个不太合规范的操作）querySelector[context].querySelector()在指定的上下文中，基于选择器（类似于css选择器），获取到指定的节点对象（获取的是一个元素，哪怕选择器匹配了多个，我们只获取第一个）1document.querySelector('#id, .className,div'); querySelectorAll在querySelector的基础上，我们获取到选择器匹配到的所有元素，结果是一个节点集合；querySelector/querySelectorAll都是不兼容IE6-8(不考虑兼容的情况下，我们能用byid或者其他方式获取的，也尽量不要用这两个方法，这两个方法性能消耗大);document.head获取head元素对象document.body获取body元素对象document.documentElement获取html元素对象123// 获取浏览器一屏幕的宽度和高度（兼容所有浏览器）document.documentElement.clientWidth || document.body.clientWidthdocument.documentElement.clientHeight || document.body.clientHeight 面试题：获取当前页面中所有ID为haha的(兼容所有浏览器)123456789101112131415// 因为要兼容所有浏览器，不能使用querySelectorAll// 思路：1，获取当前文档中所有的Html标签// 2，依次遍历这些元素对象，谁的id等于haha,我们就把谁存储起来即可 function queryAllById(id) &#123; var nodeList = document.getElementsByTagName('*'); // 基于通配符*获取到所有的Html标签 // 遍历集合中的每一项，把元素ID和传递ID相同的这一项存储起来 var ary = []; for (var i = 0; i &lt; nodeList.length; i++) &#123; var item = nodeList[i]; id === item.id ? ary.push(item) : null; &#125; return ary; &#125;// 也可以直接使用 console.log(id), 因为浏览器中，JS默认会把元素的id设置为变量，不需要自己设置，而且id重复的话，获取的结果就是一个集合，包含所有ID项，不重复，就是元素对象 节点（node）在一个HTML文档中，出现的所有东西都是节点（标签、文字、注释） 元素节点(html标签) 文本节点（文字内容） 注释节点（注释内容） 文档节点（document） … 每一种类型的节点都会有一些属性区分自己的特性和特征 nodeType 节点类型 nodeName 节点名称 nodeValue节点值 元素节点nodeType: 1nodeName: 大写标签名nodeValue: null 文本节点nodeType: 3nodeName: ‘#text’nodeValue: 文本内容 在标准浏览器中，会把空格、换行都当作文本节点 注释节点nodeType: 8nodeName: ‘#comment’nodeValue: 注释内容 文档节点nodeType: 9nodeName: ‘#document’nodeValue: null 描述节点之间关系的属性parentNode获取当前节点唯一的父亲节点 childNodes获取当前节点的所有子节点（只获取儿子级别的,包含元素节点、文本节点等） children获取当前当前元素的元素子节点（在IE6-8下会把注释节点也当作元素节点，所以兼容性不太好） previousSibling获取当前节点的上一个节点（可能是元素，也可能是文本、注释等） previousElementSibling 获取当前节点的上一个元素节点（不兼容IE6-8） nextSibling获取当前节点的下一个节点 nextElementSibling 获取当前节点的下一个元素节点（不兼容IE6-8） firstChild获取当前节点的第一个节点 firstElementChild 获取第一个元素子节点（不兼容IE6-8） lastChild获取当前节点的最后一个节点 lastElementChild 获取当前元素的最后一个元素子节点（不兼容IE6-8） 需求一：获取当前元素的所有元素子节点 基于children 不兼容IE低版本浏览器，会把注释当作元素节点1234567891011121314151617/* * children: Get all the element nodes of the current element * @parameter: * curEle: [object]current element * return: [array] all the element nodes * by author on 2019/04/01 17:39 * update xx on xxxxx */function children(curEle) &#123; // 1获取当前元素下所有的子节点，2 遍历所有子节点，筛选出nodeType = 1的元素节点 var nodeList = curEle.childNodes, result = []; for (var i = 0; i &lt; nodeList.length; i++) &#123; nodeList[i].nodeType == 1 ? result.push(nodeList[i]) : null; &#125; return result;&#125; 需求二：获取当前元素的上一个元素节点123456789101112131415161718192021/* * prev ： Get prvious element node of the current node * @parameter * curEle: [object] current element * @return * [object] * by xx onxx */function prev(Ele) &#123; //先找当前元素的哥哥节点，看是否为元素节点，不是的话，基于该节点，找上一个节点，直到找到元素节点，或者找完为止（说明我是老大） var pre = Ele.previousSibling; while (pre &amp;&amp; pre.nodeType !== 1) &#123; /* * pre &amp;&amp; pre.nodeType !== 1 * pre是验证还有没有，这样写代表有，没有pre是null * pre.nodeType !== 1表示不是元素类型 */ pre = pre.previousSibling; &#125; return pre;&#125; 扩展： next下一个弟弟节点元素节点， prevAll获取所有哥哥元素的节点，nextAll获取所有弟弟元素节点， sibling获取所有兄弟元素节点，index获取当前元素的索引next下一个元素节点123456789101112131415/* * next ： Get next element node of the current node * @parameter * curEle: [object] current element * @return * [object] * by xx onxx */function next(Ele) &#123; var next = Ele.nextSibling; while (next &amp;&amp; next.nodeType !== 1) &#123; next = next.nextSibling; &#125; return next;&#125; prevALL所有的哥哥元素节点1234567891011121314151617/* * prevAll ： Get all the previous element nodes of the current node * @parameter * curEle: [object] current element * @return * [array] * by xx onxx */function prevAll(Ele) &#123; var ary = [], pre = Ele.previousSibling; while (pre) &#123; pre.nodeType === 1 ? ary.unshift(pre) : null; pre = pre.previousSibling; &#125; return ary;&#125; nextAll1234567891011121314151617/* * nextAll ： Get all the next element nodes of the current node * @parameter * curEle: [object] current element * @return * [array] * by xx onxx */function nextAll(Ele) &#123; var ary = [], next = Ele.nextSibling; while (next) &#123; next.nodeType === 1 ? ary.push(next) : null; next = next.nextSibling; &#125; return ary;&#125; 12345678910111213141516171819202122/* * sibling ： Get all the sibling element nodes of the current node * @parameter * curEle: [object] current element * @return * [array] * by xx onxx */function sibling(Ele) &#123; var pre = Ele.previousSibling; var ary = []; while (pre) &#123; pre.nodeType === 1 ? ary.unshift(pre) : null; pre = pre.previousSibling; &#125; var next = Ele.nextSibling; while (next) &#123; next.nodeType === 1 ? ary.push(next) : null; next = next.nextSibling; &#125; return ary;&#125; index12345678910111213141516171819/* * index ： Get index of the current node * @parameter * curEle: [object] current element * @return * number * by xx onxx */function index(Ele) &#123; var pre = Ele.previousSibling; var ary = []; while (pre) &#123; pre.nodeType === 1 ? ary.unshift(pre) : null; pre = pre.previousSibling; &#125; return ary.length;&#125; DOM的增删改createElement, createTextNode,appendChild, insertBefore,clone,removeChild,set/get/removeAttribute createElement创建一个元素标签/元素对象语法：document.createElement(标签名) appendChild把一个元素对象插入到指定容器的末尾[container].appendChild([newEle]); insertBefore把一个元素对象插入到指定容器中某一个元素标签之前[container].insertBefore([newEle],[oldEle]); cloneNode把某一个节点进行克隆[curEle].cloneNode(); 浅克隆，只克隆当前标签[curEle].cloneNode(true); 深克隆，当前标签及里面的内容都克隆过来 removeChild在指定元素对象中删除指定元素[container].removeChild([curEle]); set/get/removeAttribute设置/获取/删除当前元素的某一个属性1234567891011121314var newP = document.createElement('p'); newP.innerHTML = 'I am p'; document.body.appendChild(newP); var newA = document.createElement('a'); newA.innerHTML = 'I am a' document.body.insertBefore(newA, newP); // 把创建的a克隆一份放到body末尾 var cloneA = newA.cloneNode(); document.body.appendChild(cloneA); var cloneAB = newA.cloneNode(true); document.body.appendChild(cloneAB); document.body.removeChild(newP); var oBox = document.getElementById('box'); oBox.myIndex = 10; 把元素当作一个对象，在对象对应的堆内存中新增一个自定义属性oBox.myIndex =10// 设置 oBox[‘myIndex] // 获取delete oBox[‘myIndex] // 删除 // =&gt;基于attribute等DOM方法完成自定义属性的设置oBox.setAttribute(‘mycolor’,’red’);oBox.getAttribute(‘mycolor’);oBox.removeAttribut(‘mycolor); 上下两种机制属于独立的运作体制，不能互相混合使用第一种是基于对象键值对操作方式，修改当前元素的堆内存空间来完成第二种是直接修改页面中的HTML标签的结构来完成（此种办法设置的自定义属性可以在结构上呈现出来） 基于setAttribute设置的自定义属性值都是字符串 需求：解析一个URL字符串问好传参和HASH值部分1234567891011121314151617181920212223242526function queryURLParameter(str) &#123; //1.创建一个a标签，把需要解析的地址当作a标签的href赋值 var link = document.createElement('a'); link.href = str; //页面中不需要展示a，我们只是想要利用它的属性而已，所以无需添加到页面当中 //2.a元素对象的HASH和search两个属性，分别存储了哈希值和参数值 var search = link.search.substr(1), hash = link.hash.substr(1); // 3. 分别解析出HASH和参数即可 var obj = &#123;&#125;; hash ? obj.HASH = hash : null; if (search) &#123; //先按照&amp;拆分， search = search.split('&amp;'); for (var i = 0; i &lt; search.length; i++) &#123; var itemAry = search[i].split(\"=\"); obj[itemAry[0]] = itemAry[1]; &#125; &#125; return obj;&#125;var str = 'https://wwww.zhufengpeixun.cn/stu?lx=1&amp;name=AA&amp;age=20#teacher';var obj = queryURLParameter(str);console.log(obj); 扩展：原生JS获取元素样式ele.style获取元素的行内样式，这个必须是写在行内的style属性里面的才能获取到，卸载其他地方（比如&lt;head&gt;&lt;/head&gt;中的&lt;style&gt;&lt;/style&gt;里面或者引入的css样式表里面就无法获取到） getComputedStyle()获取当前元素所有css属性的方法。语法： window.getComputedStyle(‘元素对象’[，’伪类’]);12var obj = document.getElementById('id');var cssStyleCollectiion = window.getComputedStyle(obj, null); getPropertyValue()获取css样式某一属性的值，只可读，需要与getComputedStyle结合使用123var obj = document.getElementById('id');var cssStyleCollection = window.getComputedStyle(obj, null);var bgColor = cssStyleCollection.getPropertyValue('background-color');","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://abluecup.github.io/tags/javascript/"}]},{"title":"NPM GIT概念解析","slug":"NPM Git","date":"2019-03-13T01:35:00.000Z","updated":"2019-04-02T05:19:39.188Z","comments":true,"path":"2019/03/13/NPM Git/","link":"","permalink":"https://abluecup.github.io/2019/03/13/NPM Git/","excerpt":"","text":"node并不是一门语言，它是一个工具或者环境， 基于V8引擎（webkit）渲染和解析JS的； 单线程； 无阻塞I/O操作； 事件驱动之所以把node称为服务器端语言，是因为node基于JS操作服务器端的能力：我们在服务器端安装node,使用JS完成服务器端需要处理的一些事情，最后把写好的js代码交给Node环境运行即可； 在node环境中把JS代码执行 REPL命令（Read - Evaluate -Print -Loop:输入-求职-输出-循环） // 先执行node 基于node xxx.js命令执行 基于WB这类编辑工具直接执行 常用DOS命令ping www.baidu.com -t : 测试网速Ctrl + c : 结束当前正在运行的操作exit: 退出当前窗口ipconfig -all ：查看当前电脑的Ip地址 物理地址 子网掩码 DNS等信息cls: 清屏cd + 详细目录地址： 切盘 （win里面不能切磁盘，切磁盘的时候直接E: 打磁盘名称加:）cd .. 返回上级目录cd ./ 当前目录cd / 根目录dir 查看当前目录下文件mkdir 创建目录copy con xx.xx 创建文件 ctrl + c 保存并退出del xx.xx 删除文件rmdir xx 删除目录 NPM模块管理安装完成Node之后，基本上自带npm模块管理器我们需要一个第三方（别人写的）模块、插件、类库、框架等，需要提前下载安装才可以使用 百度搜索，找到下载地址，然后基于浏览器下载即可（资源比较混乱，不好搜索） 也可以基于npm等第三方包管理器下载（yarn bower …都是第三方模块管理器） npm下载资源都是在http://www.npmjs.com/中下载的npm install xxx：把资源或者第三方模块下载到当前目录下npm install xxx -g (--global): 把资源或者第三方模块安装到全局环境下（目的：以后可以基于命令来操作一些事情）npm uninstall xxx: 从本地卸载 基于npm的一些细节点 需要联网（基于npm是从国外服务器上下载资源，所以下载速度较慢） 下载成功后，当前目录中多增加一个node_modules文件夹，在这个文件夹中找到我们安装的模块 一般来说，下载下来的内容包含源码和最后宫开发者使用的压缩版本 解决下载慢的问题 123456789101112131. 基于nrm切换到国内下载源（一般是淘宝镜像） 1&gt; 安装nrm到全局环境（因为我们需要使用命令） npm install nrm -g 2&gt; 安装完成之后，我们可以使用nrm命令 nrm ls 查看当前可用源 nrm use xx 使用某个源 // nrm use taobao 切换源还是基于npm安装2.可以基于yarn来安装 1&gt; 安装yarn到全局环境中,然后基于yarn安装我们需要的模块 ,只能安装到本地，不能安装到全局 yarn add xx yarn remove xx 安装了一个新的模块管理器3 基于cnmp淘宝镜像来处理 安装了一个新的管理器 3.解决版本安装问题 1)首先查看当期那模块的历史版本信息 npm view jquery &gt; jquery.version.json 把当前模块的历史信息输出到具体的某个文件中（文件名自己随便起） 2） 安装指定的版本 npm install jquery@1.11.3 @后面 + 版本号 yarn add jquery@1.11.3 课后扩展： bower是从github下载安装，熟悉下它的使用； 在全局中安装less/babel-cli githubgithub是一个提供代码管理的公共平台，我们以及众多开发者会把自己生产的组件、类库、插件、框架等托管到这个平台中，供别人使用和研究。github中，我们可以创建仓库来管理自己的项目文件，而github支持开发者通过git操作，把本地的项目代码推送到指定的仓库中，它还提供静态的web页面的发布等。国内有一个和github类似的网站：coding，和github类似，也是提供代码管理的平台。 基于github创建仓库，管理代码 Git基础管理 git是一个分布式代码版本管理控制系统 记录当前产品代码的所有版本信息，而且方便快速回退到某一个具体的版本； 方便团队协作开发，能够检测代码冲突，能够合并代码等； 123svn: 在git诞生前就已经存在的版本控制系统，不过他是集中式管理git: 是分布式代码管理系统 1） 集中式版本控制系统 中央服务器：版本信息记录，和最新代码管理都在这；每次开发前，需要从中央服务器把代码拉取下来；本地开发完成后，在提交到中央服务器上（但是没提交之前，本次内容不是一个新的版本） 提交一次，记录一个新的历史版本（当前版本的代码就存储起来了，以后可以对比或者回滚到这个版本）2） 分布式版本控制系统 每个开发者的本地都是一个git仓库，在本地就可以生成历史版本 集中服务器用来(github) 本地仓库：自己的代码和版本信息同步或推送到中央服务器 CDN加速 地域式服务器分布管理 git的工作管理和基础操作 在本地创建git仓库,管理本地代码 初次使用git,先在本地配置一些基础信息 12345$ git config -l $ git config --global user.name xxx$ git config --global user.eamil xxxx# 配置用户名和用户邮箱和gitHub保持一致（这样以后在本地想gitHub推送内容的时候，能够展示出是谁推送的） 1$ git init // 初始化目录，创建仓库 会在当前目录中创建一个空的仓库，文件目录中生成一个.git的隐藏文件，这个文件和重要，我们本地仓库的版本信息 在当前目录(git仓库根目录)创建一个 ‘.gitignore’文件. 这个文件中存储了当git提交的时候所忽略的文件 可以基于WB创建基于Linux命令 $touch .gitignore 1234567891011121314151617181920212223# dependenciesnode_modules# testing/coverage# production/build# misc.DS_Store.env.local.env.development.local.env.test.local.env.production.local# npm or yarnnpm-debug.log*yarn-debug.log*yarn-error.log*# webStorm.idear 12345678910111213141516171819//数据交换var a=1;var b=2;var c = a;a = b;b =c;var e =10;var f =20;e = e + f;f = e -f;e = e -f;var m = 100;var n =200;[m,n] = [n,m];console.log(m);console.log(n); GIT工作原理及操作当我们在本地创建一个git仓库后，我们可以基于这个仓库管理我们的代码； git的工作流程 每一个git仓库都划分为三个区 工作区：编辑代码的地方 暂存区：临时存储要生成版本代码的地方 历史区： 存储是的生成的每一个版本代码 123456789101112131415161. 工作区到暂存区$ git status 查看文件的状态，按颜色区分：红色表示当前文件在工作区，还没有提交到暂存区；绿色表示文件在暂存区，还没有提交到历史区；如果没有文件，表示三个区域代码已经同步；$ git add .gitignore$ git add -A // 所有$ git add . // 所有工作区提交到暂存区，暂存区提交到历史区。暂存区始终存放提交的内容，并不消失。以后工作区有内容修改，会和暂存区做对比，以此来判断哪些是新处理的。2. 暂存区到历史区$ git commit这样执行后，会弹出一个提交文本输入界面，需要我们编写本次提交到离市区，给当前版本填写备注信息；$ git commit -m &apos;自己需要编写的备注信息&apos;; git和github同步1.让本地仓库和远程仓库建立关联12345678$ git remote -v查看所有关联信息$ git remote add xx [远程仓库git地址] 建立关联$ git remote remove xxx移除关联 我们远程仓库关联在一起的名字默认是： origin， 当然自己可以随意修改 把本地的代码推送到远程仓库上，或者从远程仓库上拉去最新的信息到本地仓库 我们本地推送和拉取的信息，既有代码也有版本信息，所以说与其说是推送和拉取，不如说是和远程仓库保持信息的同步； 123456在同步之前，我们都应该先拉取$ git pull origin (这个名字就是和远程仓库管理啊的名字，以自己设置的为主) master从远程仓库master分支拉取信息；$ git push origin master把本地信息推送到远程仓库master分支下。 以上是操作知识点，真实项目开发流程如下：1.LEADER会首先创建一个远程仓库（这个仓库可能是空的，也可能是包含了项目需要的基础的结构信息）； 作为开发者我们需要在本地创建一个本地仓库，还需要让当前本地的仓库与远程仓库保持关联 123456原始做法：git initgit remote add origin [git 仓库地址]简单做法：git clone [远程仓库地址]（克隆后的名字，可以不设置，默认是仓库名） 在本地开发产品，需要同步的时候，我们首先把工作区内容放到历史区，生成版本信息（git add . / git commit -m ‘’ ），再把本地试试去的信息推送到远程仓库上： （git pull/ git push） 在团队协作开发的时候，leader会在自己的github账号下创建一个远程仓库，那么团队其他成员在向这个远程仓库推送信息的时候，使用自己的账号是没有推送权限的，我们需要把当前这个远程仓库，在github中创建工作群组，让更多人用自己的账号也有操作权限小组成员在自己的邮箱中收到一份邀请邮件，确认参加；","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://abluecup.github.io/tags/git/"}]},{"title":"日常总结","slug":"日常总结","date":"2018-12-12T05:55:38.000Z","updated":"2019-03-12T09:42:01.578Z","comments":true,"path":"2018/12/12/日常总结/","link":"","permalink":"https://abluecup.github.io/2018/12/12/日常总结/","excerpt":"此处是工作中遇到的小问题的总结：","text":"此处是工作中遇到的小问题的总结： 1、a标签的选择问题需要修改带class的a标签的hover的文字颜色，方式如下 123456&lt;style&gt; a.egHyperlink:hover&#123; color:red; &#125;&lt;/style&gt;&lt;a href=&quot;#&quot; class=&quot;egHyperlink&quot;&gt;smile&lt;/a&gt; 2、hr分割线需要一条粉红色的分割线，宽度1px 12345678&lt;style&gt; hr&#123; height:2px; border:none; border-top:1px solid #00BFFF; &#125;&lt;/style&gt;&lt;hr&gt; 展示效果如下： 3、图片环绕文字 12345&lt;div&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/10/1634933fa3100474?w=1039&amp;h=579&amp;f=png&amp;s=16869&quot; width=&quot;50%&quot; style=&quot;float:left;border:1px solid #00BFFF;margin:0 10px 0 0;&quot;/&gt;&lt;p&gt;What I want to accomplish is for the text to be aligned with the top and left side of the floated img and to wrap immediately underneath with no margin. When I comment out the padding in &apos;p&apos; the image has no bottom margin, but I want the padding property to be active in my stylesheet.What I want to accomplish is for the text to be aligned with the top and left side of the floated img and to wrap immediately underneath with no margin. When I comment out the padding in &apos;p&apos; the image has no bottom margin, but I want the padding property to be active in my stylesheet.&lt;/p&gt;&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 效果如下： What I want to accomplish is for the text to be aligned with the top and left side of the floated img and to wrap immediately underneath with no margin. When I comment out the padding in ‘p’ the image has no bottom margin, but I want the padding property to be active in my stylesheet.What I want to accomplish is for the text to be aligned with the top and left side of the floated img and to wrap immediately underneath with no margin. When I comment out the padding in ‘p’ the image has no bottom margin, but I want the padding property to be active in my stylesheet. 4、颜色的值，遇到过几次需要使用颜色而又不是特别严格要求使用某一种颜色的问题，这个时候可以自己选择，今天先更新一个，以后遇到就记下来 #00BFFF rgb(2, 221, 223) 文字颜色，rgb(75,75,75) 5、@media screen问题总是遇到需要使用@media screen来区分设备的问题，却总是忘记代码，脑子啊，css样式要写在{}内 1234567891011# Mobile@media screen and (min-width: 480px)&#123;&#125;# Tablet@meida screen and (min-width: 768px)&#123;&#125;# Desktop@media screen and (min-width: 992px)&#123;&#125;# Huge@media screen and (min-width: 1280px)&#123;&#125; 或者 12345678# Phone@media screen and (max-width:320px)&#123;&#125;# Tablet@media screen and (min-width:321px) and (max-width:768px)&#123;&#125;# Desktop@media screen and (min-width:769px)&#123;&#125;","categories":[],"tags":[]},{"title":"在Github搭建博客（二）","slug":"config-theme","date":"2018-06-05T08:45:35.000Z","updated":"2018-06-07T09:35:36.608Z","comments":true,"path":"2018/06/05/config-theme/","link":"","permalink":"https://abluecup.github.io/2018/06/05/config-theme/","excerpt":"选择主题我们搭建好博客后，会选择其他的主题而不是hexo自身携带的主题。网上可以搜索到许多的主题，可以击这里查看。我最初选择的是yilia，后来因为嫌字体太大（16px),想修改字体的大小，弄了半天也没弄好，干脆就放弃了，选择了next(它的字体是14px)。 安装next","text":"选择主题我们搭建好博客后，会选择其他的主题而不是hexo自身携带的主题。网上可以搜索到许多的主题，可以击这里查看。我最初选择的是yilia，后来因为嫌字体太大（16px),想修改字体的大小，弄了半天也没弄好，干脆就放弃了，选择了next(它的字体是14px)。 安装next next的地址README中详细地介绍了next的安装方法，我之前在windows10中安装了git，所以选择的方法是在git bash控制台切换到blog目录下输入命令1git clone https://github.com/iissnan/hexo-theme-next themes/next 之后在目录 blog/theme/下会看到目录 next,里面包含了next的主题文件。我们此时打开blog的 _config.yml 文件，找到theme那一行，主题修改为next，如下图所示在cmd控制台依次运行命令123hexo generatehexo server 在浏览器中输入 localhost:4000就可以查看了 next配置的选择建议先阅读整篇文档，尤其是里面的英文注释，有助于帮助理解。在这里，我写下自己做的配置 布局样式的选择四个布局样式都很不错，简洁大方，选择比较随意。 social的选择 menu 的选择 遇到的问题的解决方法标签和分类页面打不开安装和配置好next后，点击标签页和分类页，都出现了Error.原因是找不到页面。在menu的选择图中可以看到，我们将标签和分类的路径设置为 /tags/和/categories/，但是实际上这两个路径并不存在，这就需要我们新建这两个路径,在blog根目录下输入下面的命令行123hexo new page &quot;tags&quot;hexo new page &quot;categories&quot; 路径建好了，我到相应的路径下找到对应的页面进行修改，tags的页面中，要添加type: &quot;tags&quot;,categories的页面中，要添加type: &quot;categories&quot;,如下图所示 如何插入图片图片可以使用本地图片，也可以使用网络服务器上的图片，储存图片的服务器，叫图床。（图柜也比图床好理解吧） 修改hexo的配置文件_config.yml,找到post_asset_folder,将它的值改为true. 这样，当你hexo new &quot;post&quot;的时候，会生成与文件名相同的目录 安装hexo-asset-image插件，它是一个图片路径转换的插件， 1npm install https://github.com/CodeFalling/hexo-asset-image --save 之后就可以将图片放入相应的文件目录中，使用Markdown语法插入图片了 1![alt name](name.png) 这里有一个需要注意的地方就是，图片格式的大小写要一致，比如png不能写成PNG，至于为什么，还不清楚","categories":[{"name":"系统","slug":"系统","permalink":"https://abluecup.github.io/categories/系统/"}],"tags":[{"name":"搭建环境","slug":"搭建环境","permalink":"https://abluecup.github.io/tags/搭建环境/"}]},{"title":"vim的使用","slug":"vim的使用","date":"2018-06-04T09:00:52.000Z","updated":"2018-06-14T08:19:44.888Z","comments":true,"path":"2018/06/04/vim的使用/","link":"","permalink":"https://abluecup.github.io/2018/06/04/vim的使用/","excerpt":"参考链接http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/https://coolshell.cn/articles/5426.html上面的博客无论是原文还是翻译都比较有趣，本文是对这两篇博客的阅读笔记。 vim是什么？Vim is a highly configurable text editor for efficiently creating and changing any kind of text. It is included as “vi” with most UNIX systems and with Apple OS X.官网上的解释如上，翻译下就是： Vim 是高度可配置的编辑器，用于高效创建和修改各类文本。它包含在UNIX系统和苹果 OS X 系统的 vi中。","text":"参考链接http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/https://coolshell.cn/articles/5426.html上面的博客无论是原文还是翻译都比较有趣，本文是对这两篇博客的阅读笔记。 vim是什么？Vim is a highly configurable text editor for efficiently creating and changing any kind of text. It is included as “vi” with most UNIX systems and with Apple OS X.官网上的解释如上，翻译下就是： Vim 是高度可配置的编辑器，用于高效创建和修改各类文本。它包含在UNIX系统和苹果 OS X 系统的 vi中。 学习VIM的四个阶段（Survive）存活 i 进入insert模式（插入模式），按Esc回到Normal模式（普通模式）；x 删除当前光标所在的一个字符；:wq w(存盘) q(退出)；dd 删除当前行；p 粘贴hjkl 按照左下上右的顺序移动光标:help 命令的说明 (Feel Comfortable) 感觉舒适1、Insert mode variations（插入字符或行的命令）: a -&gt; 在光标后插入字符；o -&gt; 在当前行下插入新的一行；O -&gt; 在当前行上插入新的一行；cw -&gt; 删除当前光标所在位置的字符到一个单词结尾的字符 2、(Basic moves) 基本的移动命令 hjkl-&gt; 左下上右0 -&gt;(数字0) 移动到当前行的第一个字符；$ -&gt; 移动到当前行的最后一个字符；^ -&gt; 移动到不是blank的第一个字符；g_ -&gt;移动到不是blank的最后一个字符；/pattern -&gt;寻找字符pattern 3、(copy/paster)复制粘贴 yy -&gt; 复制；p -&gt; 粘贴； 4、(Undo/Redo)撤销/重复 u 撤销之前一步的动作；ctr-r 重复之前的命令 5、Load/Save/Quit/Change File (Buffer)下载/保存/退出/改变 文件（缓冲），即对已经完成的文件和正在修改的文件操作的命令 :e&lt;path/to/file&gt; 打开一个文件:saveas &lt;path/to/file&gt; 文件另存为:w 保存但是不退出;:x ZZ :wq 保存并退出:q! 退出但是不保存；:qa! 强制退出:bn :bp 展示下一个文件（同时打开多个文件的时候使用） (Better. Stronger. Faster.)更好 更强 更快Better . (点)重复上一个命令N 重复命令N次举例说明: 2dd 删除两行3p 粘贴文本3次100idesu[ESC] 写一百遍desu. 再写一百遍desu 再写3遍desu Stronger N(G) 光标移动到行Ngg 光标移动到第一行G 光标移动到最后一行Word moves w 移动到下一个word的首字母e 移动到本word的结尾W(大写) 定义WORD是一组word,以blank隔开，移动到下一个WORD的开头E 移动到本WORD的结尾 和 # ，移动到光标所在word相匹配的下一个word,或者上一个word * 下一个，# 上一个% 匹配括号移动，包括 (, {, [.(不理解什么意思) Faster一般的命令格式 &lt;command命令&gt;&lt;结束位置&gt;举例说明0y$ 0 表示光标移动到本行的开始位置；y 开始复制$ 复制到本行结束 另外附加的三个命令v 可视化gU 变成大写gu 变成小写 Vim SuperPowers(Vim超级编辑器)Move on current line (0 ^ $ g_ f F t T , ;) 在当前行移动命令(0 ^ $ g_ f F t T , ; 0 → go to column 0^ → go to first character on the line$ → go to the last columng_ → go to the last character on the linefa → go to next occurrence of the letter a on the line., (resp. ;) will find the next (resp. previous) occurrence.t, → go to just before the character ,.3fa → find the 3rd occurrence of a on this line.F and T → like f and t but backward.","categories":[{"name":"系统","slug":"系统","permalink":"https://abluecup.github.io/categories/系统/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://abluecup.github.io/tags/vim/"}]},{"title":"在Github上搭建博客","slug":"在Github上搭建博客","date":"2018-05-30T07:04:47.000Z","updated":"2018-06-07T09:03:59.911Z","comments":true,"path":"2018/05/30/在Github上搭建博客/","link":"","permalink":"https://abluecup.github.io/2018/05/30/在Github上搭建博客/","excerpt":"写在前面 为什么自己搭建博客？ 知乎上有关于这个问题的很详尽的回答？链接：https://www.zhihu.com/question/19916345。 我搭建博客用了多久? 大概一下午的时间，当然要感谢找到了一个比较清楚的资料，附上链接：教你免费搭建个人博客。也要感谢16年的时候，学习了linux系统的知识,阅读和操作起来都比较容易。 系统 windows 10 64位，编辑器：sublime text3，控制台：cmd","text":"写在前面 为什么自己搭建博客？ 知乎上有关于这个问题的很详尽的回答？链接：https://www.zhihu.com/question/19916345。 我搭建博客用了多久? 大概一下午的时间，当然要感谢找到了一个比较清楚的资料，附上链接：教你免费搭建个人博客。也要感谢16年的时候，学习了linux系统的知识,阅读和操作起来都比较容易。 系统 windows 10 64位，编辑器：sublime text3，控制台：cmd 搭建博客使用 hexo+Github 什么是hexo?Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。官方文档 什么是Github?GitHub is a development platform inspired by the way you work. From open source to business, you can host and review code, manage projects, and build software alongside millions of other developers. (GitHub是一个受你工作方式启发的开发平台。 从开源到商业，您可以托管和查看代码，管理项目，并与数百万其他开发人员一起构建软件。) click me 准备工作 配置 Github首先，你需要有一个Github的账号。在Github网站上注册账号，并记住自己的Username。我的Username是abluecup。登录，在网页左上方找到 New repository 按钮，点击创建名称为username.github.io的仓库。我的是username是abluecup,我创建的仓库名称就是abluecup.github.io 环境搭建 安装Node.js https://nodejs.org/en/ 安装 Git https://github.com/waylau/git-for-winNode.js和Git的安装，我都是全部默认安装的。当然，你可以根据自己的需要安装。关于Git的教程，推荐廖雪峰的教程。在这里给自己刨个坑，自己以后也会写关于Git的博客。-安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，打开界面：输入 123git config --global user.name &quot;username&quot;git config --global user.email &quot;your email&quot;# username是你注册Github的username,your email是你注册Github时的email 安装Hexo打开cmd, 安装hexo,输入命令然后等待hexo安装完成： 1npm install -g hexo-cli 初始化博客 新建目录test. 进入gitbash控制界面，切换目录到test目录下，输入： 123hexo init blog# 成功提示INFO Start blogging with Hexo! 初始化完成之后，切换目录到blog下，输入命令： 1$ hexo generate 12345# 启动本地服务器$ hexo server# 在浏览器输入 http://localhost:4000/就可以看见网页和模板了INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问 http://localhost:4000/ ，我们会看到网站初始的模样 设置秘钥现在我们可以暂时关闭hexo的本地服务，在git的管理界面输入以下命令:1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一路按Enter键过来就好，最后会得到信息： 1Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. 找到该文件，打开（sublime text），Ctrl + a复制里面的所有内容，然后进入Sign in to GitHub：https://github.com/settings/sshNew SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key 配置博客在blog目录下，用sublime打开_config.yml文件，修改参数信息特别提醒，在每个参数的：后都要加一个空格修改网站相关信息12345678# Sitetitle: 卡而的博客subtitle:副标题description: 描述keywords:关键词author: 作者language:zh-CNtimezone:Asia/Shanghai 配置部署（我的是abluecup，修改成自己的）1234deploy: type: git repo: http://github.com/ABlueCup/ABlueCup.github.io branch: master 发布文章1hexo deploy 后续更新：MarkDown语法链接 遇到的问题： 执行 hexo deploy时，出现错误 error deployer not found:git执行如下代码 1npm install hexo-deployer-git --save 执行 hexo clean , hexo generate , hexo server , hexo deploy等命令时，当前目录必须是在博客根目录下，即 blog/ 文件夹 blog里面","categories":[{"name":"系统","slug":"系统","permalink":"https://abluecup.github.io/categories/系统/"}],"tags":[{"name":"搭建环境","slug":"搭建环境","permalink":"https://abluecup.github.io/tags/搭建环境/"}]}]}