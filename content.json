{"meta":{"title":"积步堂","subtitle":"不积跬步，无以致千里；不积小流，无以成江海。","description":"珠峰学习笔记和日常记录","author":"卡而","url":"https://abluecup.github.io"},"pages":[{"title":"","date":"2020-04-14T04:03:42.495Z","updated":"2020-04-14T04:03:42.495Z","comments":true,"path":"about/index.html","permalink":"https://abluecup.github.io/about/index.html","excerpt":"","text":"关于我 body{ background-color: rgb(135, 176, 165); } article{ position: relative; margin: .4rem auto; width: 90%; padding: .2rem; margin: .6rem auto; background-color: #fff; text-align: center; font-size: .18rem; color: #555; box-shadow: 0 0 .6rem #999; } ~function(){ let computedSize = function computedSize() { let windowWidth = document.documentElement.clientWidth; let designWidth = 640; if (windowWidth > designWidth) { document.documentElement.style.fontSize = '100px'; return; } document.documentElement.style.fontSize = windowWidth/designWidth *100 +'px'; } computedSize(); window.addEventListener('resize', computedSize); }(); 定风波 苏轼 （三月七日沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉。已而遂晴，故作此 ）。 莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？ 一蓑烟雨任平生。 料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。"},{"title":"categories","date":"2018-06-07T05:48:59.000Z","updated":"2018-06-07T05:49:48.722Z","comments":true,"path":"categories/index.html","permalink":"https://abluecup.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-15T05:37:41.684Z","updated":"2020-05-15T05:37:41.684Z","comments":true,"path":"about/404.html","permalink":"https://abluecup.github.io/about/404.html","excerpt":"","text":"404"},{"title":"tags","date":"2018-06-07T05:45:29.000Z","updated":"2018-06-07T05:46:17.308Z","comments":true,"path":"tags/index.html","permalink":"https://abluecup.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6","slug":"ES6","date":"2020-06-12T06:46:19.000Z","updated":"2020-07-09T06:18:33.244Z","comments":true,"path":"2020/06/12/ES6/","link":"","permalink":"https://abluecup.github.io/2020/06/12/ES6/","excerpt":"本篇是对ES6的讲解","text":"本篇是对ES6的讲解 声明方式 var 不支持封闭作用域，会声明到全局作用域上 let const基本一致 let 和{}配合可以产生一个作用域 let 支持块级作用域，声明的变量只会声明在当前作用域，可以解决作用域污染问题和局部作用域问题 在同一个作用域下，var可以多次声明变量，但是let不可以，只能声明一次。 域解释问题，变量提升 var存在，但是let不存在 暂存死区, 如果作用域内定义了一个变量，那么该作用域内的变量就被绑定了，不会再向上查找。 通过const声明的变量不能被修改,不能被修改引用空间 解构赋值 声明和赋值放在一起 解构，表示等号左右两边结构类似 12let&#123;length&#125;=[&apos;kyle&apos;,29]; console.log(length); 对象解构时名字必须相同 想设置某个属性的默认值，必须使用=1234let &#123;name, age, defautl:d&#125; = &#123;name:'xx', age:9, default:'cc'&#125;let [&#123;address:[,a]&#125;]= [&#123;name:'xx'&#125;,&#123;age:9,address:[1,2,3]&#125;];let [name='kyle', age=30] = ['cc', 99]; 模板字符串可以支持换行， 可以支持取值 如何自己实现一个类模板字符串的功能 padStart, padEnd 补全 箭头函数，写起来简单，而且可以解决this问题1，没有function关键字2，小括号和大括号之间有一个箭头3，如果参数是一个可以省略小括号4，如果只有return,可以省略大括号5，如果直接返回的是对象类型，需要小括号包含 保留要操作的this1, var that = this;2, .bind(this); 对象不是作用域，let声明的变量不会和window建立映射关系 箭头函数中没有argumentslet fn = (,…args)=&gt;{ args是一个数组} 函数可以赋值默认值 …1, 深拷贝和浅拷贝浅拷贝只拷贝指针，深拷贝拷贝堆栈…也是浅拷贝 1.1 深拷贝的实现12345678910111213141516let deepClone = function deepClone(obj) &#123; if (typeof obj !== 'object') return obj; if (obj === null) return null; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); let o = new obj.constructor(); for (const key in object) &#123; o[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]; &#125; return o;&#125;console.log(deepClone(null));console.log(deepClone(new Date()));console.log(deepClone(1));console.log([1,&#123;name:'kyle'&#125;,[2,3]]); 数组的常见方法1, map()返回原数组的每一项经过处理后的新数组2, reduce() 收敛|叠加返回的结果是叠加后的结果3,for of4, Array.from() 类数组转化成数组常见的类数组: htmlCollection arguments123function a()&#123; Array.from(arguments).join('+');&#125; 对象object1, Object.assign(); 合并对象2, proto被方法Object.setPrototypeOf(obj1, obj2) 相当于 obj1.proto = obj2;获取 Object.getPrototypeOf(obj1)3, super 表示父级 类 类得三种属性公有属性，私有属性，静态方法(静态属性) 继承2.1 继承公有属性 2.2 继承私有属性 2.3 继承公有属性和私有属性 2.4 Object.create()12345678910111213141516171819202122232425function Parent() &#123; //构造函数中得this，通过new调用，this指的是实例 this.name = 'parent';&#125;Parent.prototype.eat = function () &#123; console.log('eat');&#125;let parent = new Parent();// parent.__proto__.eat();function Child() &#123; this.age = 9; Parent.call(this); //继承私有属性&#125;Child.prototype.smoking = function () &#123; console.log('smoking');&#125; // Child.prototype.__proto__ = Parent.prototype; //只继承公有属性// Object.setPrototypeOf(Child.prototype, Parent.prototype); //只继承公有属性Child.prototype = Object.create(Parent.prototype);//只继承公有属性,但是抛弃了自己所属类的原型let child = new Child(); child.eat();// child.smoking();console.log(child.name); 123Child.prototype = Object.create(Parent.prototype);// 创建一个空函数，让Child.prototype = Fn.prototype, 让Fn.prototype = Parent.prototype;// 这样能继承到Parent上得公有属性，但是Child.prototype被抛弃了，无法再实现 类得编译123456789101112131415161718192021222324252627282930313233343536class Parent&#123; constructor()&#123; this.familyName = 'peng'; &#125; static b()&#123; return 2; &#125; eat()&#123; console.log('eat'); &#125;&#125;class Child extends Parent&#123; constructor()&#123; super(); this.age=9;//私有属性 &#125; static a()&#123; //类上的方法 return 1; &#125; smoking()&#123; //原型上的方法 console.log('smoking'); &#125;&#125;let child = new Child();console.log(child.age);child.smoking();console.log(Child.a());//公有私有和静态方法都能够继承console.log(child.familyName);child.eat();console.log(Child.b());console.log(child);// 父类得构造函数中返回了一个引用类型，会把这个值作为子类得this Promisegenerator async await Promise是一种异步流程的控制手段 回调地狱，代码难以维护. Promise是链式调用 Promise支持多个并发请求，获取并发请求中的数据 Primise可以解决异步问题，本身不能说PROMISE是异步的 Promise的关键字: resolve 表示成功， reject 失败 pending 等待. 一旦promise成功了就不能失败，相反也是一样。只有状态是等待的状态时，才可以转化状态。 事件环 如果返回的是promise 那么会取这个promise结果，成功会走外层的下一个then的成功，并将数据传递过去。Promise实现链式调用返回的并不是this, 而是promise12345678910111213//promise只有一个参数，叫excutor执行器，默认new时会调用//每一个promise的实例上都有一个then方法，方法上有两个参数，一个参数叫成功的参数，一个叫失败的参数let p = new Promise((resolve, reject) =&gt; &#123; //默认promise中的executor是同步执行的 console.log(1); // throw new Error(); resolve('buy');&#125;);p.then(value =&gt; &#123; console.log(value,'resolve');&#125;, err =&gt; &#123; console.log(err, 'reject');&#125;);console.log(2); ES6相关自带严格模式 变量必须先声明再使用 函数的参数不能有同名属性，否则报错 不能用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进位制，否则报错 不能删除不可删除的属性 不能删除变量 delete pro,只能删除属性 eval不会再它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反应函数参数的变化 不能使用arguments.callee 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字(比如protected, static, interface) 数组遍历的方法 forEach map find findIndex filter every some reduce 从左向右累计 reduceRight 从右向左累计12345let ary = [1,2,3,4,5];let result = ary.reduce(function(accumulator, currentValue)&#123; return accumulator + currentValue;&#125;,10);console.log(result); set &amp; mapset1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// set是类数组，可以去除重复项let set = new Set([1, 1, NaN, 'aa', 'aa', true, undefined]);//console.log(set);//只有value,没有indexlet arr = [1,1,2,2,3,5,5];arr = [...new Set(arr)];//属性 size,表示长度//方法let res=undefined;// add, 重复的添加不上,返回操作后的setset.add(1);res = set.add(3);console.log(res);// delete 删除一项，返回true / false 是否删除成功 res = set.delete(2);console.log(res); // false//has 判断有没有, 返回true/falseres = [1,2,NaN].includes(NaN);console.log(res);//clear 清空// res = set.clear();// console.log(res, set); // undefined, Set(0)&#123;&#125;//forEach, set只有value,所以只能遍历value值set.forEach((value1,value2, set)=&gt;&#123; // console.log(value1, value2, set);&#125;);//keys, values,entiresconsole.log(set.keys()); // SetIterator &#123;1, NaN, \"aa\", true, undefined, …&#125;console.log(set.values()); // SetIterator &#123;1, NaN, \"aa\", true, undefined, …&#125;console.log(set.entries());//SetIterator &#123;1 =&gt; 1, NaN =&gt; NaN, \"aa\" =&gt; \"aa\", true =&gt; true, undefined =&gt; undefined, …&#125;// 额外， for of// console.log(arr);// for (const item of arr) &#123;// console.log(item);// &#125;// for (const key of arr.keys()) &#123;// console.log(key); // &#125;// for (const entry of arr.entries()) &#123;// console.log(entry);// &#125; Map12let map = new Map([[true,true],[&#123;&#125;,&#123;&#125;],[[],[]],[null,null]]);console.log(map); 123456789101112131415161718192021222324252627282930//数组中的每一项都是数组，第一项是key,第二项是valuelet map = new Map([[true,true],[&#123;&#125;,&#123;&#125;],[[],[]],[null,null]]);// console.log(map);//set(key, value),添加一个属性， 返回值是这个Maplet res = map.set(NaN, NaN);// console.log(res);//get(key),返回对应的value//has(key),返回布尔值//clear, delete// forEach keys values entriesmap.forEach((value,key,map)=&gt;&#123;&#125;);for (const key of map.keys()) &#123; console.log(key); &#125;for (const value of map.values()) &#123; console.log(value);&#125;for (const entry of map.entries()) &#123; console.log(entry); // [] &#125; Symbol 基本数据类型通过函数执行得到，不能通过new执行 唯一值 不能进行运算不可以转数字，可以转成字符串，但是不可以进行字符串拼接 可以转布尔 true12345678910111213141516171819202122232425let sy = Symbol(2); //通过Symbol()得到的值都是唯一的let sym = Symbol(2);console.log(sy == sym); //falselet s = sy.toString()console.log(s);console.log(typeof s);// 参数表示对当前Symbol值的描述// 为了可读性和好区分console.log(Boolean(Symbol()));let d = Symbol(\"symbol值是唯一的\");let obj = &#123;a:'b',[d]:'2'&#125;;console.log(obj);console.log(obj[\"Symbol()\"]); // undefined, 获取不到for (const key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; const element = obj[key]; console.log(key, element); //a,b 获取不到Symbol() &#125;&#125;console.log(Object.getOwnPropertySymbols(obj));//[Symbol()]console.log(Object.keys(obj)); // [\"a\"]获取不到Symbol//综上所述，别没事用Symbol()当属性名 Iteration接口 &amp; for of可遍历的对象都有一个Symbol(Symbol.iterator)方法，此方法执行后会返回一个Array Iterator{} 对象，这个对象的proto上有一个方法next, next()执行，会返回一个普通对象{value:xx, done:false|true}, value表示当前遍历到的值，done表示当前是否没有遍历到值，没有则表明遍历结束。123456789let ary = [1,2,3]; console.log(ary); console.log(ary[Symbol.iterator]); let iterator = ary[Symbol.iterator](); console.log(iterator); console.log(iterator.next()); console.log(iterator.next()); 我们想让一个对象可以遍历，就要给它添加Symbol.iterator方法，可以直接添加在对象上，也可以添加在对象的proto上12345678910111213141516let o =&#123; 0:'aa', 1:'AA', 2:'bb', 3:'cc', length:4&#125;console.log(o);;o[Symbol.iterator] = Array.prototype.values;for (const item of o) &#123; console.log(item); &#125;console.log(o); Iteration使用场合 解构赋值 扩展运算符 Set Map for…of Array.from() Promise.all() Promise.race() proxy &amp; defineProperty12345678910111213141516171819202122let obj = &#123; name: 'kyle' &#125;; let proxy1 = new Proxy(obj, &#123; // 想代理的方法 get(target, prop) &#123; //获取属性名或者属性值就会触发这个get console.log(1); return target[prop]; &#125;, set(target, prop, value) &#123; target[prop] = value; &#125; &#125;); console.log(obj.name); obj.age = \"20\"; console.log(obj); console.log(Object.getOwnPropertyDescriptor(obj, \"name\"));/* &#123; value: \"kyle\", writable: true, enumerable: true, configurable: true &#125; value: \"kyle\" writable: true 是否可修改 enumerable: true 是否可枚举 configurable: true 是否可配置 __proto__: Object */ proxy &amp; definePropertyproxy1234567891011121314151617181920212223242526272829303132333435363738394041424344// proxy 代理let obj = &#123; name: 'zf', age: 9&#125;;// new Proxy(target, &#123;代理的方法&#125;) let proxy1 = new Proxy(obj, &#123; get(target, prop) &#123; // 获取属性名的属性值的时候就会触发代理方法 return target[prop]; &#125;, set(target, prop, value) &#123; target[prop] = value; &#125;&#125;)proxy1.name = 'c';// console.log(obj.name);console.log(proxy1.name, proxy1.age);console.log(Object.getOwnPropertyDescriptor(obj,'name')); // 得到属性的值和相关属性/* &#123;value: \"c\", writable: true, enumerable: true, configurable: true&#125; configurable: true 可删除enumerable: true 可枚举value: \"c\"writable: true 可修改__proto__: Object */// definePropertyObject.defineProperty(obj,\"name\",&#123; value:'a', configurable:false, enumerable:false, writable:false&#125;)console.log(obj);console.log(Object.getOwnPropertyDescriptor(obj, \"name\"));/* &#123;value: \"a\", writable: false, enumerable: false, configurable: false&#125;configurable: falseenumerable: falsevalue: \"a\"writable: false__proto__: Object */","categories":[],"tags":[]},{"title":"vue","slug":"vue","date":"2020-06-09T04:59:37.000Z","updated":"2020-07-09T09:23:15.360Z","comments":true,"path":"2020/06/09/vue/","link":"","permalink":"https://abluecup.github.io/2020/06/09/vue/","excerpt":"本篇是对VUE的介绍","text":"本篇是对VUE的介绍 vue双向数据绑定原理的实现v-model 实现双向数据绑定1，获取所有的节点，所有符合条件()和标签中v-model的属性，把它们的值设为预设的值;2, 当变量的值改变的时候，循环所有节点，修改该值3，使用Object.defineProperties定义对象和对象中的属性，当属性的值修改的时候，触发set方法，我们在set方法中设置方法取修改页面中所有相关的值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"name\"&gt; &lt;input type=\"text\" v-model=\"name\"&gt; &lt;input type=\"text\" v-model=\"age\"&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; let data = &#123; name: 'zf', age: 10 &#125;; let app = document.getElementById(\"app\"); let inputs = app.getElementsByTagName('input'); let nodeList = [...app.children].filter(item =&gt; &#123; //获取app下面所有非input的子元素节点 return item.nodeName != 'INPUT'; &#125;); let cloneNodeList = nodeList.map(item =&gt; &#123; return item.cloneNode(true); &#125;); console.log(nodeList); for (const item of inputs) &#123; if (item.getAttribute(\"v-model\")) &#123; item.value = data[item.getAttribute(\"v-model\")] &#125; item.oninput = function () &#123; data[this.getAttribute(\"v-model\")] = this.value; &#125; &#125; nodeList.forEach(item =&gt; &#123; if (/\\&#123;\\&#123;\\w+\\&#125;\\&#125;/g.test(item.innerHTML)) &#123; item.innerHTML = item.innerHTML.replace(/\\&#123;\\&#123;(\\w+)\\&#125;\\&#125;/g, (...arg) =&gt; &#123; console.log(arg); return data[arg[1]] &#125;); &#125; &#125;); Object.defineProperties(data, &#123; name: &#123; set(val) &#123; //属性值被修改的时候会访问该函数 console.log(\"name被修改了\"); for (const item of inputs) &#123; if (item.getAttribute(\"v-model\") === \"name\") &#123; item.value = val; &#125; cloneNodeList.forEach((item, index) =&gt; &#123; nodeList[index].innerHTML = item.innerHTML.replace(/\\&#123;\\&#123;name\\&#125;\\&#125;/g, () =&gt; val); &#125;); &#125;; &#125;, get() &#123; //访问该属性的时候会访问该函数 console.log(\"name被访问到了\"); &#125; &#125;, age: &#123; &#125; &#125;);&lt;/script&gt; 指令和事件指令1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;!-- v-text 只看作文本，不识别标签 --&gt; &lt;p v-text=\"text\"&gt;&lt;/p&gt; &lt;!-- v-html识别标签 --&gt; &lt;p v-html=\"html\"&gt;&lt;/p&gt; &lt;input type=\"text\" v-model=\"a\"&gt; &lt;!-- v-once只变化一次 --&gt; &lt;p v-once&gt;&#123;&#123;a&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"./vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; let vm = new Vue(&#123; el:'#app', data:&#123; text:\"&lt;a&gt;11&lt;/a&gt;\", html:\"&lt;a href='#'&gt;00&lt;/a&gt;\", a:'999' &#125; &#125;); &lt;/script&gt; 事件绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;div id=\"app\"&gt; &lt;!-- 绑定事件 @click=fn() 如果没有参数，()可以不写 --&gt; &lt;!-- 事件修饰符 .stop 阻止冒泡 .prevent 阻止默认行为 .capture 捕获阶段发生 .self 自己作为事件源的时候才会发生 .once 只执行一次 .passive 键盘事件修饰符：表示点击这些键的时候触发这些方法 .enter 点击enter键的方法 .tab 点击tab键的方法 .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right --&gt; &lt;div @click=\"fn(3)\"&gt;00 &lt;i @click.stop=\"fn\"&gt;ii&lt;/i&gt; &lt;input type=\"text\" @keydown.enter=\"write\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=\"./vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; let vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; fn(n)&#123; console.log(n,event); &#125;, write()&#123; console.log(\"enter\"); &#125; &#125; &#125;);&lt;/script&gt;","categories":[],"tags":[]},{"title":"NODE","slug":"NODE","date":"2020-04-26T06:49:21.000Z","updated":"2020-05-15T05:21:36.686Z","comments":true,"path":"2020/04/26/NODE/","link":"","permalink":"https://abluecup.github.io/2020/04/26/NODE/","excerpt":"本片是对node基础概念的介绍","text":"本片是对node基础概念的介绍 NODE介绍1.什么时node? 基于V8引擎(谷歌浏览器的引擎)渲染JS的工具或者环境 -&gt;安装NODE -&gt;把JS代码放到NODE环境中执行 2.安装NODENODE安装完成后，-&gt; 当前电脑上自动安装了NPM(Node Package Manager：一个JS模块管理的工具)，基于NPM，可以安装下载JS模块(所有封装好可以供其他人调取使用的都可以称之为模块或者包)。-&gt; 它会生成一个node执行命令(可以在DOS窗口或者终端命令中执行)：node xxx.js 3.如何在NODE中渲染和解析JS REPL(READ - EVALUATE - PRINT - LOOP， 输入-求值-输出-循环) 直接基于NODE来执行JS文件 4.之所以把NODE作为后台语言，是因为：1）node可以安装在服务器上2）我们可以把编写的JS代码放到服务器上，通过NODE来执行（我们可以使用JS来操作服务器，即使用JS来实现服务器端的一些功能操作。说NODE是后台语言，其实想表达的是JS是后台语言。所以JS是全栈编程语言） 5.NODE作后台的优势和特点 传统后台语言： JAVA/PHP/PYTHON/GO/C#(.NET)/ 单线程的 基于V8引擎渲染：快 异步无阻塞的IO操作( IO: INPUT OUTPUT, 对文件的读写) event-driven事件驱动，类似于发布订阅或者回调函数 6.在vscode中开启node内置方法的代码提示123456npm install -g typings在开发的项目中输入typings init, 当前目录下会出现typings.json的文件然后安装js插件的提示文件：：typings install dt~node --global--save 这个如果不行，可以使用 typings install @types/node --global --save NPM的应用目前工程化开发/自动化开发（不一定是写后台），都是基于NODE环境，基于NPM管理模块，基于WEBPACK实现模块之间的依赖打包，部署上线。1234567npm的常规命令：npm install xxx 把模块安装在当前目录下npm install xxx -global 把模块安装在全局目录下npm uninstall xxxnpm uninstall xxx -gnpm install xxx@xxx 安装指定版本号的模块npm view xxx&gt;xxx.version.txt 查看模块的版本号 NPM的默认安装源 https://www.npmjs.com, 在国内安装下载速度较慢，想要下载速度快些，我们可以做如下处理：1.切换到淘宝镜像上 安装CNPM，后期都是基于cnpm安装管理 12npm install cnpm -gcnpm install zepto 安装nrm切源工具，基于nrm把源切换到淘宝源上 12345npm install nrm -gnrm ls 查看当前源nrm use xxx 使用某个源这样处理完成后，后期模块的管理依然基于npm即可 2，基于YARN安装：它也是模块管理工具，类似于NPM，但是安装管理的速度比NPM快好多1234npm install yarn -gyarn add xxxyarn remove xxxx使用yarn只能把模块安装在当前目录下，不能安装到全局环境下 3，bower也是类似于npm的包管理器，只不过它是从github上下载12npm install bower -gbower install xxx 1.在本地项目中基于NPM/YARN安装第三方模块第一步：在本地项目中创建一个package.json的文件 作用：把当前项目中所有依赖的第三方模块信息(包含：模块名称以及版本号等信息)都记录下来，可以在这里配置一些可执行的命令脚本等； 基于YARN安装会默认生成一个“配置清单”，只是信息没有手动创建的全面。 npm init -y 或者 yarn init -y 创建配置清单的时候，项目目录中不要出现中文和特殊符号，这样有可能识别不了。第二步：安装 开发依赖：只有在项目开发阶段以来的第三方模块 less webpack… 生产依赖：项目部署实施的时候，也需要以来的第三方模块 jquery zepto… [npm] npm install xxx –save –save-dev 保存到开发依赖中 [yarn] yarn add xxx 默认就是保存到生产依赖中 –dev / -D 保存到开发依赖中第三步：部署的时候跑环境 不需要自己一个个的安装，只需要执行 npm install 或者 yarn install 即可，npm会自己先检测目录中是否有package.json文件，如果有的话，会按照文件中的配置清单依次安装。 == 开发一个项目，我们生成一个配置清单package.json, 当我们安装第三方模块使用的时候，把安装的模块信息记录到配置清单中，这样以后不管是团队协作开发还是项目部署上线，我们都没有必要把modules上传给别人，只需要把配置清单传递给其他人即可。其他人拿到配置清单，按照清单中的依赖项及版本号重新安装即可(重新安装：就叫“跑环境”)package.json{ “name”: “node”, 模块名称 “version”: “1.0.0”, 版本号 “description”: “”, 描述 “main”: “index.js”, 当前模块的主入口文件 “scripts”: { //可执行脚本 “test”: “echo \\”Error: no test specified\\” &amp;&amp; exit 1” }, “keywords”: [], “author”: “”, “license”: “ISC” “dependencies”: { 生产依赖 “jquery”: “^3.5.0”, “zepto”: “^1.2.0” } “devDependencies”: { 开发依赖 “less”: “^3.11.1” }} 2.安装在本地和全局的区别安装在全局的特点： a. 所有的项目都可以使用这个模块(容易导致版本冲突，安装在全局的模块，不能基于CommonJS模块规范调取使用,即不能通过require调取使用) 安装在本地的特点： a. 只能当前项目使用这个模块(不能直接使用命令操作，安装在全局可以使用) 为什么安装在全局可以使用命令？npm root / npm root -g 查看本地环境下或者全局环境下，NPM的安装目录安装在全局目录下的模块，大部分都会生成一个xxx.cmd的文件，只要有这个文件，那么xxx就是一个可执行的命令。(例如yarn.cmd, yarn就是一个可执行的命令)1234567@IF EXIST &quot;%~dp0\\node.exe&quot; ( &quot;%~dp0\\node.exe&quot; &quot;%~dp0\\node_modules\\yarn\\bin\\yarn.js&quot; %*) ELSE ( @SETLOCAL @SET PATHEXT=%PATHEXT:;.JS;=;% node &quot;%~dp0\\node_modules\\yarn\\bin\\yarn.js&quot; %*) 能否既安装在本地，也使用命令？ 可以，但是需要配置packagr.json中的 1.把模块安装在本地，如果是支持命令操作的(会在node_modules中的bin中生成xxx.cmd的命令文件，只不过这个文件无法再全局下执行，不能直接使用命令) 2.在package.json的scripts中配置需要执行的命令脚本 123&quot;scripts&quot;: &#123; &quot;kp&quot;:&quot;lessc --version&quot;&#125; 属性名自己设置即可，属性值是需要执行的命令脚本，根据需要自己编写(可以配置很多命令) 3.npm run kp / yarn kp 这样的操作就是把配置的脚本执行 -&gt; 首先到配置清单的scripts中查找 -&gt; 找到把后面对应的属性值执行 -&gt; 执行脚本的时候，会到本地node_modules中的.bin文件查找，没有的话，再向NPM安装的全局目录下查找 NODE入门1.NODE本身是基于CommonJS模块规范设计的，所以模块是NODE的组成 - 内置模块： NODE天生提供给JS调取使用的 - 第三方模块： 别人写好的，我们可以基于NPM安装使用 - 自定义模块： 自己创建的一些模块 CommonJS模块化设计思想 (AMD/CMD/ES6 MODULE都是模块化设计思想)1234567891011121314151617181.CommonJS规定，每一个JS文件都是一个单独的模块(模块是私有的，里面涉及的值和变量以及函数都是私有的，和其他JS文件是不冲突的)2.CommonJS中可以允许模块中的方法互相调用 B模块中想要调取A模块中的方法 -&gt; A导出 -&gt; B导入 [导出] CommonJS给每一个模块都设置了内置的变量/属性/方法 module: 代表当前这个模块对象 module.exports: 模块的这个属性用来导出属性和方法 exports: 是内置的一个变量，也是用来导出当前模块的属性和方法的，虽然和module.exports不是一个东西，但是对应的值是同一个(modules.exports:exports, 值都是对象) [导入] require: CommonJS提供的内置变量，用来导入模块的(其实导入的就是module.exports导出的东西)，导入的值也是对象 exports.fn = fn; // 或者 module.exports.fn = fn let temp1 = require(&apos;./temp1&apos;); ./ 指当前目录中的某个模块，.js可以忽略 require导入的时候，首先把TEMP1中的代码自上而下执行，把exports对应的堆内存导入进来，所以接收到的结果是个对象。require是一个同步操作：只有把导入的模块代码执行完成，才可以获取值，然后继续执行本模块下面的代码 此时的temp1是一个对象&#123;fn:...&#125; temp1.fn(2); 执行temp1中的fn方法 特点： 1.所有代码都运行在模块作用域，不会污染全局作用域。每一个模块都是私有的，包括里面所有的东西也都是私有的，和其他模块不会产生干扰； 2.模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果，想要让模块再次运行，必须清除缓存。(为了保证性能，减少模块代码重复执行的次数) 3.模块加载的顺序，按照其在代码中出现的顺序。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 exports={} 是无法导出内容的，默认和module.exports是同一个堆内存，但是这种操作让exoprts指向了新的堆内存，而module.exports不受影响， require导入的是module.exports对应的堆内存，而不是exports的 默认module.exports = exports， 所以我们在导出的时候，不能直接写module.exports={}或者exports={},这样会使两者指向的堆内存不同。 require 导入规则 require(‘./xxx’); 查找当前目录下的自定义模块 require(‘xxx’)首先到当前项目的node-module中查找是否存在这个模块，不存在着node提供的内置模块 _dirname: 模块中这个内置变量是当前所在的绝对路径_filename: 包含绝对路径的文件名称 _dirname[a.js] 内置模块FS实现IO操作123456789let fs = require(&apos;fs&apos;);1. fs.mkdir / fs.mkdirSync 创建目录, 有Sync的是同步创建，没有是异步。想要实现无阻塞，我们一般都使用异步操作完成要处理的事情。2. fs.readdir / fs.readdirSync: 读取文件目录中的内容, 返回的结果是一个数组3. fs.rmdir / fs.rmdirSync :删除目录，但是如果目录中有文件，无法删除，会报错4. fs.readFile: 读取文件中的内容5. fs.writeFile: 向文件中写入内容(覆盖式写入：原有的内容都没了)6. fs.appendFile: 追加写入内容，原有内容还在7. fs.copyFile: 复制文件到新的目录下8. fs.unlink: 删除文件 PATH1234let path = require(&apos;path);path.resolve(); 返回当前的绝对地址(不包含模块名)path.resolve(__dirname, &apos;less/tt&apos;) 可以把一个相对路径拼接到绝对路径上，第一个参数是绝对路径，第二个是相对的，如果都是绝对路径，以后一个为主 __dirname是当前模块所在的绝对路径，跟模块在哪里执行没有关系。path.resolve() 当前模块中的方法在哪个模块中执行的，那么对应的绝对路径是执行模块的绝对路径。 URL1, url.parse(url[, flag]) 把一个url地址进行解析，把地址中的每一部分按照对象键值对的方式存储起来，第二个参数默认是false，设置为true可以把?传参的部分也解析为键值对的方式Url { protocol: ‘https:’, 协议 slashes: true, 是否有双斜线 auth: null, host: ‘www.zhufengpeixun.cn&#39;, 主机 port: null, 端口 hostname: ‘www.zhufengpeixun.cn&#39;, 域名 hash: ‘#video’,哈希值 search: ‘?form=qq&amp;lx=stu’, ？传参 query: ‘form=qq&amp;lx=stu’, ?传参不包含? pathname: ‘/main/guide/index.html’, 请求的资源路径名称 path: ‘/main/guide/index.html?form=qq&amp;lx=stu’, href: ‘https://www.zhufengpeixun.cn/main/guide/index.html?form=qq&amp;lx=stu#video&#39;} Url { protocol: ‘https:’, slashes: true, auth: null, host: ‘www.zhufengpeixun.cn&#39;, port: null, hostname: ‘www.zhufengpeixun.cn&#39;, hash: ‘#video’, search: ‘?form=qq&amp;lx=stu’, query: [Object: null prototype] { form: ‘qq’, lx: ‘stu’ }, // 区别就是query的值是一个对象 pathname: ‘/main/guide/index.html’, path: ‘/main/guide/index.html?form=qq&amp;lx=stu’, href: ‘https://www.zhufengpeixun.cn/main/guide/index.html?form=qq&amp;lx=stu#video&#39; } HTTPlet server = http.createServer(); //创建服务server.listen(); //监听端口 注意：基于NODE创建后台程序，我们一般都创建一个server模块，在模块当中实现创建WEB服务，和对于请求的处理(并且我们一般都会把server模块放在当前项目的根目录下) 1234567891011121314151617let http = require(&apos;http&apos;);// 创建WEB服务let server = http.createServer();server.listen(&apos;8989&apos;, ()=&gt;&#123; // 服务创建成功，并且端口号已经监听成功后，触发的回调函数 console.log(&apos;server is successful, listen on 8989&apos;);&#125;);// listen EACCES 0.0.0.0:8989 这种错误是端口号被占用了，我们需要重新修改端口号// 当服务创建成功，命令行中会一直存在光标闪烁，证明服务器正在运行中(一定要保证服务是运行的), 按 ctrl + c 可以结束正在运行的服务// 客户端如何向服务端发送请求，// 对应协议、域名、端口号等信息，在浏览器中或者AJAX中发送请求即可// http://localhost:8686/... 服务在当前电脑上// http://ip:8989/..IP做域名访问，如果是内网IP，相同局域网下的用户可以访问这个服务，如果是外网IP,所有能联网的都可以访问这个服务， 局域网下访问需要互相关掉防火墙// 把请求的URL地址中：路径名称&amp;问号传参分别解析出来 createServer((req, res)=&gt;{ req: request 请求对象，包含了客户端请求的信息 req.url 存储的是请求资源的路径地址及问号传参（没有哈希值） req.method 客户端请求方式 req.headers 客户端的请求头信息，是一个对象 res: response 相应对象，包含了一些属性和方法，可以让服务器端返回给客户端的内容 res.write() 基于这个方法，服务器端可以向客户端返回内容 res.end 结束响应 res.writeHead 重写响应头信息 。。。}) 123456789101112let http = require('http'),url = require('url');let count=0;let handle = function handle(req, res)&#123; &#125;let server = http.createServer(handle);server.listen('8989', ()=&gt;&#123; // 服务创建成功，并且端口号已经监听成功后，触发的回调函数 console.log('server is successful, listen on 8989');&#125;); 创建静态资源服务器服务器上有一堆代码，这对项目代码中即可能有服务器端的程序代码，也可能有客户端的程序代码，而客户端的程序代码我们一般都放到static这个目录下static 都是服务器端需要返回给客户端，由客户端浏览器渲染和解析的(前端项目：包括页面、CSS、JS、图片等)server.js 都是需要在服务器端基于NODE执行的(后端项目，一般只有JS)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// let http = require(&apos;http&apos;),// url = require(&apos;url&apos;);// let &#123; readFile &#125; = require(&apos;./utils/fsPromise&apos;);// let handle = function handle(req, res) &#123;// //客户端请求资源文件(PATH-NAME),服务器端都是到STATIC这个目录下进行读取，根据客户端请求的路径名称，服务器端基于FS读取文件中内容的时候，直接加上./static即可// let &#123; method, headers: requestHeaders &#125; = req,// &#123; pathname, query &#125; = url.parse(req.url, true);// readFile(`./static$&#123;pathname&#125;`).then(result =&gt; &#123;// //读取成功，文件在// res.writeHead(200);// res.end(result);// &#125;).catch(error =&gt; &#123;// // 读取失败，文件不存在，客户端请求的地址是错误的，我们应该响应的内容是404// res.writeHead(404,&#123;// &apos;content-type&apos;:&apos;text/plain;charset=utf-8&apos;// &#125;);// res.end(&apos;NOT FOUND&apos;);// &#125;);// &#125;// let server = http.createServer(handle);// server.listen(&apos;8989&apos;, () =&gt; &#123;// // 服务创建成功，并且端口号已经监听成功后，触发的回调函数// console.log(&apos;server is successful, listen on 8989&apos;);// &#125;);let http = require(&apos;http&apos;), url = require(&apos;url&apos;), mime = require(&apos;mime&apos;), &#123; readFile &#125; = require(&apos;./utils/fsPromise&apos;) ;let handle = function handle(req, res) &#123; let &#123; pathname, query &#125; = url.parse(req.url, true), pathREG = /\\.([a-zA-Z0-9]+)$/i; //捕获后缀名的正则 readFile(`./static$&#123;pathname&#125;`).then(result =&gt; &#123; //根据请求资源的文件类型，设置相应内容的MIME(多用途互联网扩展类型) // let suffix = pathREG.exec(pathname)[1]; res.writeHead(200, &#123; &apos;content-type&apos;: `$&#123;mime.getType(suffix)&#125;;charset=utf-8` &#125;); res.end(result); &#125;).catch(error =&gt; &#123; res.writeHead(404, &#123; &apos;content-type&apos;: `text/plain;charset=utf-8` &#125;); res.end(&apos;NOT FOUND&apos;); &#125;);&#125;http.createServer(handle).listen(8989, () =&gt; &#123; console.log(&quot;server is successful&quot;);&#125;); 我们创建的WEB服务需要处理两类请求1.静态资源文件的请求处理：想要文件2.API接口的请求处理，想要数据区别：第一类请求的地址中有后缀名，第二类没有 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115let http = require('http'), url = require('url'), mime = require('mime'), qs = require('qs'), &#123; readFile, writeFile &#125; = require('./utils/fsPromise') ;// 公共方法let responseResult = function responseResult(res, returnVal) &#123; res.writeHead(200, &#123; 'content-type': 'application/json;charset=utf-8;' &#125;); res.end(JSON.stringify(returnVal));&#125; ; let readUser = function readUser() &#123; return readFile('./json/USER.JSON').then(result =&gt; &#123; return JSON.parse(result); &#125;); &#125; ; let readVote = function readVote() &#123; return readFile('./json/VOTE.JSON').then(result =&gt; &#123; return JSON.parse(result); &#125;); &#125;let handle = function handle(req, res) &#123; let &#123; pathname, query &#125; = url.parse(req.url, true), pathREG = /\\.([a-zA-Z0-9]+)$/i; //捕获后缀名的正则 if (pathREG.test(pathname)) &#123; //静态资源处理 readFile(`./static$&#123;pathname&#125;`).then(result =&gt; &#123; //根据请求资源的文件类型，设置相应内容的MIME(多用途互联网扩展类型) // let suffix = pathREG.exec(pathname)[1]; res.writeHead(200, &#123; 'content-type': `$&#123;mime.getType(suffix)&#125;;charset=utf-8` &#125;); res.end(result); &#125;).catch(error =&gt; &#123; res.writeHead(404, &#123; 'content-type': `text/plain;charset=utf-8` &#125;); res.end('NOT FOUND'); &#125;); return; &#125; // API接口请求处理 //GET-USER:根据传递的ID获取指定的用户信息 if (pathname === '/getUser' &amp;&amp; req.method === 'GET') &#123; //传递的信息都在QUERY中存储着 let &#123; userId = 0 &#125; = query, returnVal = &#123; code: 1, message: 'no match any data', data: null &#125;; readUser().then(result =&gt; &#123; let data = result.find(item =&gt; parseFloat(item['id']) === parseFloat(userId)); if (data) &#123; returnVal = &#123; code: 0, message: 'ok', data &#125;; responseResult(res, returnVal); return; &#125; throw new Error(''); //没有数据的时候，让其执行CATCH中的操作，这样我们只需要让THEN中的方法中有异常信息即可 &#125;).catch(error =&gt; responseResult(res, returnVal)); return; &#125; //注册数据 if (pathname === '/register' &amp;&amp; req.method === 'POST') &#123; //接收客户端请求主体传递的内容, ondata:正在接收请求主题内容，可能会被触发执行很多次 let pass = ``; req.on('data', chunk =&gt; &#123; //chunk获取的都是本次接收的BUFFER格式的数据 ‘’+chunk会转化成字符串 pass += chunk; &#125;); req.on('end', () =&gt; &#123; //请求主体内容已经接收完了,pass是一个urlencoded的字符串，我们需要把它解析为对象 pass = qs.parse(pass); readUser().then(result =&gt; &#123; // FORMAT-PASS 格式化pass数据 let maxId = result.length &lt;= 0 ? 0 : parseFloat(result.length-1); pass.password = pass.password.substr(4, 24).split('').reverse().join(''); let newData = &#123; id: maxId++, name: '', picture: `img/$&#123;pass.sex == 0 ? `man` : `woman`&#125;.png`, phone: \"\", sex: 0, password: \"\", bio: \"\", time: new Date().getTime(), isMatch: 0, matchId: \"000\", slogan: \"\", voteNum: 0, ...pass //展开运算符覆盖原有的项 &#125;; //把NEWDATA追加到RESULT末尾 result.push(newData); return writeFile('./json/USER.JSON', result); &#125;).then(result =&gt; &#123; responseResult(res, &#123; code: 0, message: 'ok' &#125; ); &#125;) .catch(error =&gt; &#123; console.log(error); //展示错误信息 responseResult(res, &#123; code: 1, message: 'no' &#125;); &#125;); &#125;); return; &#125; //请求的都不是以上接口 res.writeHead(404); res.end('');&#125;http.createServer(handle).listen(8989, () =&gt; &#123; console.log(\"server is successful\");&#125;); JS中的同步异步编程 浏览器是多线程的，JS是单线程的，(因为浏览器只分配一个线程来执行JS).进程大线程小，一个进程中包含多个线程，例如在浏览器中打开一个HTML页面，就占用了一个进程。加载页面的时候浏览器分配一个线程去计算DOM结构，分配其他的线程去加载对应的资源文件，。。。再分配一个线程去自上而下执行JS 同步：在一个线程上(主栈|主任务队列)，同一个时间只能做一件事情，当前事情完成才能进行下一个事情(先把一个任务进栈执行，执行完出栈，再把下一个任务进栈……) 异步：在主栈中执行一个任务，但是发现这个任务是一个异步的操作,我们会把它移出主栈，放到等待任务队列中(此时浏览器会分配其他线程监听异步任务是否到达指定的执行时间)。如果主栈执行完，监听者会把到达时间的异步任务重新放到主栈中执行…… 定时器 事件绑定 AJAX 回调函数 progress.nextTick Promise(async/await) node中fs可以进行异步的I/O操作 所以JS中的异步编程仅仅是根据某些机制来管控任务的执行顺序，不存在同时执行两个任务这一说法。 1234567891011new Promise((resolve, reject)=&gt;&#123; // new Promise的时候会立即把Excutor函数(也就是传递的回调函数)执行，所以Promise本身可以认为是同步的 console.log(2); resolve(); //执行resolve, 会把之前基于THEN存放的方法执行&#125;).then(()=&gt;&#123; //执行完成Excutor，紧接着执行then，执行then的时候会把传递的回调函数放到指定的容器中等待触发自行 console.log(3); &#125;);console.log(4);// 1 ，2 ，4 ，3 Promise并不是完全同步的，挡在Excutor中执行resolve或者reject的时候，此时是异步操作，会先执行then/catch等，当主栈完成后，才会再去掉用resolve/reject，把存放的方法执行12345678910111213141516171819202122//ES7中新增加对PROMISE操作的新语法： async/await(使用await必须保证当前方法是基于async修饰的)function AA() &#123; console.log(1); return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; Math.random() &lt; 0.5 ? reject(100) : resolve(200); &#125;, 0); &#125;);&#125;;async function fn()&#123; console.log(2); let res = await AA(); //先把AA执行，等待AA中的PROMISE完成(无论成功失败)，把最后的处理结果获取到，赋值给res,拿到后再执行后面的代码，(有人说await是把异步的操作同步化？) console.log(3); &#125;fn();console.log(4);// 2, 1, 4,3 await并不是同步，// 1,先把AA执行，返回一个PROMISE// 2, 它会暂时跳出正在执行的函数，也就是await后面的代码暂时先不执行(把后面的代码从主栈中移除，放到等待区域中)// 3， 主栈空闲，执行后面的任务// 4， 当主栈中的其他任务执行完成，主栈空闲，并且AA中的PROMISE也已经计算完成最后的结果，再把之前第二步移到等待区域的内容，重新拿回到主栈中去执行 宏任务(macro task) &amp; 微任务(micro task)宏任务(macro task) 定时器 事件绑定 AJAX 回调函数 node中fs可以进行异步的I/O操作 微任务(micro task) progress.nextTick Promise(async/await) 执行顺序SYNC =&gt; MICRO =&gt; MACRO1234567891011121314151617181920212223242526272829303132async function async1()&#123; console.log('async1 start'); await async2(); console.log('async1 end'); // 等待队列2，&#125;;async function async2()&#123; console.log('async2'); &#125;console.log('script start');setTimeout(function()&#123; console.log('setTimeout'); // 等待队列 1， &#125;,0);async1();new Promise(function(resolve)&#123; console.log('promise1'); resolve();&#125;).then(function()&#123; console.log('promise2'); // 等待队列3&#125;);console.log('script end');/** * * script start * async1 start * async2 * promise1 * script end * promise2 | async1 end 它们的顺序根据不同的V8版本，顺序是不一样的 * setTimeout */ node中独有的异步操作API12345678910111213setImmediate(()=&gt;&#123; //也是定时器，但是不设置时间，也是异步编程(宏任务),它会在其他定时器之前执行(现在又改了，)&#125;);setTimeout(()=&gt;&#123; console.log(1); &#125;,0);setImmediate(()=&gt;&#123; console.log(2); &#125;);// 2，1 现在跟其他定时器一样了，相当于后面没写0 process.nextTick把当前任务放到主栈的最后执行,并不是放在等待区12345678910setTimeout(()=&gt;&#123; console.log(1); &#125;,10);process.nextTick(()=&gt;&#123; console.log(2); &#125;);console.log(3);// 3,2,1 progress.env.NODE_ENV全局环境变量，用途：真实项目中我们基于WBEPACK打包配置的时候，往往需要区分不同环境下的不同操作，例如有开发环境，测试环境，生产环境……，而我们一般都是基于环境变量来区分打包配置的。12345678&#123; &quot;script&quot;:&#123; &quot;dev&quot;:&quot;cross-env NODE_ENV = dev node index.js&quot;, // 兼容、设置环境变量、执行index.js &quot;pro&quot;:&quot;cross-env NODE_ENV = dev node index.js&quot;, &quot;test&quot;:&quot;cross-env NODE_ENV = dev node index.js&quot; &#125;&#125;安装cross-env模块，以兼容于windows系统 Promise A+12345678910111213141516171819202122new Promise((resolve, reject)=&gt;&#123; // RESOLVE &amp; REJECT 是自己任意执行的，但是大家约定成功执行RESOLVE, 失败执行REJECT // EXCUTOR函数(执行函数)中，可以不管控异步操作(但是不管控异步，没有意义，一般都需要管控) resolve(100);&#125;).then(result=&gt;&#123; //RESOLVE执行的时候会触发第一个回调函数 console.log(1); return 100;//会把这个值传递给下一个THEN,如果返回的是PROMISE，则等到PROMISE处理完成，把处理完成的结果传递给下一个THEN&#125;, reason=&gt;&#123; //REJECT执行的时候会触发第二个回调函数 console.log(2); &#125;).then(result=&gt;&#123; //需要保证执行THEN方法返回的依然是PROMISE实例，这样才可以实现链式调用 //上一个THEN中管控的两个方法只要任何一个不报错，都会执行这个THEN方法，如果报错，会执行此THEN中的第二个回调函数&#125;).catch(reason=&gt;&#123; //相当于THEN中的第二个方法&#125;);console.log(3);Promise.all([Promise1, Promise2,...]).then(res=&gt;&#123; //等待所有的PROMISE都成功，执行THEN，反之只有有一个失败就执行CATCH&#125;); Promise的封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class Promise &#123; constructor(excutorCallback) &#123; this.status = 'pending'; this.value = undefined; this.fulfilledAry = []; this.rejectedAry = []; //执行 let resolveFn = result =&gt; &#123; let timer = setTimeout(() =&gt; &#123; clearTimeout(timer); if (this.status !== 'pending') return; this.status = 'fulfilled';// 当前状态成功 this.value = result; this.fulfilledAry.forEach(item =&gt; &#123; item(this.value); &#125;); &#125;, 0); &#125; let rejectFn = reason =&gt; &#123; let timer = setTimeout(() =&gt; &#123; clearTimeout(timer); if (this.status !== 'pending') return; this.status = 'rejected';// 当前状态失败 this.value = reason; this.rejectedAry.forEach(item =&gt; &#123; item(this.value); &#125;); &#125;); &#125; // try &#123; excutorCallback(resolveFn, rejectFn); &#125; catch (err) &#123; //有异常信息按照REJECT状态处理 rejectFn(err); &#125; &#125;; //执行THEN返回一个新的PROMISE实例 then(fulfilledCallback, rejectedCallback) &#123; typeof fulfilledCallback !== 'function' ? fulfilledCallback = result =&gt; result : null; typeof rejectedCallback !== 'function' ? rejectedCallback = reason =&gt; &#123; throw new Error(reason instanceof Error ? reason.message: reason); &#125; : null; return new Promise((resolve, reject) =&gt; &#123; this.fulfilledAry.push(() =&gt; &#123; try &#123; let x = fulfilledCallback(this.value); x instanceof Promise ? x.then(resolve, reject) : resolve(x); resolve(x); &#125; catch (error) &#123; reject(err); &#125; &#125;); this.rejectedAry.push(() =&gt; &#123; try &#123; let x = rejectedCallback(this.value); if (x instanceof Promise) &#123; x.then(resolve, reject); return; &#125; reject(x); &#125; catch (error) &#123; reject(err); &#125; &#125;); &#125;); &#125; // catch(rejectedCallback) &#123; return this.then(null, rejectedCallback); &#125; // Promise.all([]).then(res=&gt;&#123;所有的都成功走这里，res中存储了每一个实例返回的结果，而且和数组的顺序是一样的&#125;).catch(()=&gt;&#123;只要有一个失败就执行这个，失败后不再执行后面的操作&#125;) static all(promiseAry = []) &#123; //添加私有属性 return new Promise((resolve, reject) =&gt; &#123; //循环数组中的每一项 let count = 0, result = [], step = 0; // count记录成功的数量，result记录成功的结果,step记录处理的个数 for (let i = 0; i &lt; promiseAry.length; i++) &#123; // promiseAry[i], 每一个需要处理的promise实例 promiseAry[i].then(() =&gt; &#123; count++; result[i] = val; //索引需要和promiseAry一一对应，保证结果的顺序 if (count === promiseAry.length) &#123; resolve(result); &#125; &#125;, reason =&gt; &#123; reject(reason); &#125;); &#125; &#125;); &#125;&#125;module.exports = Promise; 本地存储 &amp; 服务器存储本地存储：把一些信息存储到客户端本地(主要目的有很多，其中有一个实现多页面之间的信息共享) -&gt; manifest 离线缓存 H5处理离线缓存还是不够完善，所以真实项目中一般还是传统的NATIVE APP来完成这件事 -&gt; LocalStorage / SessionStorage H5中新增加的API，基于这个API可以把一些数据缓存到本地(常用) -&gt; IndexDB / webSQL: 本地数据库存储 -&gt; Cookie 本地信息存储(常用) -&gt; CacheStorage / ApplicationCache 本地缓存存储 ... 用到本地存储的地方： 【页面通信】页面之间信息的通信 A存信息，B页面可以获取 登录 记住用户名密码 购物车 跳转到其他页面，返回上级页面的时候停留在之前最后一次点击的位置 … 【做一些性能优化】 把一些不经常改变的数据，在第一次从服务器端获取到之后，存储到客户端本地，(记录一个存储时间，假设我们设置有效存储时间是10分钟，那么十分钟以内，我们再刷新页面就不用再向服务器发请求了，直接从本地数据中获取展示即可，超过十分钟，重新向服务器发送请求，请求回来的数据参考第一次，也一样存储到本地 ，减轻服务器压力 ，对于不经常更新的数据我们可以把存储周期设置的长一点，有助于页面的第二次加载的时候，渲染的速度变快(移动端经常做这些事情) ) LocalStorage &amp; Cookie[cookie] 1, 兼容所有浏览器 2，有存储的大小限制，一般一个源(域)下，只能存储4KB内容 3，cookie有过期时间，当然我们自己可以手动设置这个时间 4, 杀毒软件都可能会把cookie信息强制清除掉 5，在隐身模式下，是不记录cookie 6，cookie不是严格的本地存储，因为要和服务器之间来回传输[localstorage] 1, 不兼容IE低版本(IE8及以下) 2，也有存储的大小限制，一个源下最多存储5MB 3，本地永久存储，只要不是手动删除，就永远存储在本地(但是我们可以基于API： removeItem/clear 手动清除一些自己想要删除的信息) 4，杀毒软件暂时不会清除localstorage(新版本谷歌浏览器会清除storage) 5, 在隐身模式下，是记录localstorage的 6，localstorage和服务器没有关系 真实项目中使用本地存储来完成一些需求的情况不是很多，一般都是基于服务器的session或者数据库存储完成的(服务器的session和本地的cookie是有关联的)，如果不考虑兼容，想基于本地存储来完成一些事情，那么一般都是用localstorage的(尤其是移动端开发) localStorage.setItem([key],[value]); value必须是字符串格式的(即使写的不是字符串，也会默认转换成字符串)localStorage.getItem([key]); 通过属性名获取存储的信息localStorage.removeItem([key]); 删除指定的存储信息localStorage.clear(); 清除当前域下存储的所有信息localStorage.key([index]); 基于索引获取指定的KEY名 document.cookie=’’; // 设置cookie Express参考文档 https://www.expressjs.com.cn/4x/api.html 中间件EXPRESS里面的中间件是在API接口请求处理之前，把一些公共的部分进行提取，中间件中就是先处理这些公共的内容，处理完成后，再继续执行接口请求即可123456789app.use(); //使用中间件app.use('/xxx', (req, res, next)=&gt;&#123; //请求的PATH地址中是以/user开头的，例如： '/user', '/user/add'... next(); //不执行NEXT是无法走到下一个中间件或请求中的,(next就是执行下一个)&#125;)app.use((req, res, next)=&gt;&#123; //所有的请求都会走这个中间件，而且中间件执行的顺序是按照书写的先后顺序执行&#125;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677let express = require('express'), bodyParser = require('body-parser'), session = require('express-session'), app = express();let port = 8686;app.listen(port, () =&gt; &#123; console.log(`Server is successful on $&#123;port&#125;!`);&#125;);//静态资源文件处理app.use(express.static('./static'));//API处理// body-parse，如果是POST/PUT请求，会把基于请求主体传递的信息预先截获// 如果传递的是JSON格式的字符串，基于bodyParser.json()会把它转换为JSON格式的对象// 如果传递的是URL-ENCODED格式的字符串，会基于bodyParser.urlencoded()把它转换为对象键值对的方式//。。。// 把转换后的结果挂载在req.body属性上app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));// EXPRESS-SESSION这个中间件是供我们后续操作SESSION的，基于这个中间件，我们可以设置客户端COOKIE的过期时间，也即SESSION在服务器存储的时间，当中间件执行完成后，会在REQ上挂载一个SESSION的属性，用来操作SESSIONapp.use(session(&#123; secret: 'zfpx', saveUninitialized: false, resave: false, cookie: &#123; maxAge: 1000 * 60 * 60 * 24 * 30 &#125;&#125;));app.get('/getUser', (req, res) =&gt; &#123; /** * 当客户端向浏览器发送请求，如果请求方式是GET，请求路径是/getUser，就会把回调函数执行，里面有三个参数，req, res, next * req:request 它不是我们之前原生NODE中的REQ,它是EXPRESS框架封装处理的，但是也存储了很多客户端传递信息的对象 * REQ.PARAMS 存储了路径参数信息 * REQ.PATH 请求的路径名称 * REQ.QUERY 请求的问号传参(对象) GET请求一般都是这样传递信息的 * REQ.BODY 当请求的方式是BODY，我们基于BODY-PARSER中间件处理后，会把客户端请求主体中传递的内容存放到BODY属性上 * REQ.SEESSION 当我们基于EXPRESS-SESSION中间件处理后，会把SESSION操作放到这个属性上，基于这个属性可以操作SESSION信息 * REQ.COOKIES 当我们基于COOKIE-PARSER中间件处理以后，会把客户端传递的COOKIE信息存放到这个属性上 * REQ.GET() 获取指定的请求头信息 * REQ.PARAM() 基于这个方法，可以把URL-ENCODED格式字符串(或者路径参数)中的某一个属性名对应的信息获取到 * * res:response 也不是原生NODE中的RES,也是EXPRESS框架封装处理的，目的是为了提供一些属性和方法可以供服务器端向客户端返回内容 * RES.COOKIE() 通过此方法可以设置一些cookie信息，通过响应头set-cookie返回给客户端，客户端把返回的cookie信息种到本地 * RES.TYPE() 设置响应内容的mime类型 * RES.STATUS() 设置响应状态码 * RES.SET() 设置响应头 * * * RES.REDIRECT() 响应是重定向的，状态码是302 * RES.RENDER() 只有页面是需要服务器渲染的时候，我们才会用这个 * * * RES.JSON(), 向客户端返回json格式的字符串，但是允许我们传递JSON格式对象，方法会帮我们转化为字符串然后返回(执行此方法后会自动结束响应，也就是执行了res.end) * RES.SEND-STATUS() 结束响应，把状态对应的信息当作响应主体返回，我们一般都用status()，然后自己设置响应主体内容 * RES.SEND-FILE([PATH]) 首先把PATH指定的文件内容得到，然后把内容返回给客户端浏览器(完成了文件读取和响应两步操作)，也会自动结束响应 * RES.SEND() 你想返回啥随便(综合体) */ console.log(req.body); res.send(&#123; message: 'ok' &#125;);&#125;);app.post('/register', (req, res) =&gt; &#123; // GET请求接收问号传参的信息，可以使用 REQ.QUERY / REQ.PARAM() // POST请求，接收请求主体传递的信息，此时我们需要使用一个中间件body-parser // req.body 获取的是请求主体的内容 console.log(); req.session.xxx = 'xxx'; console.log(req.session.xxx); //获取SESSION &#125;);","categories":[],"tags":[]},{"title":"Git","slug":"Git","date":"2020-04-23T09:38:11.000Z","updated":"2020-06-02T06:23:38.366Z","comments":true,"path":"2020/04/23/Git/","link":"","permalink":"https://abluecup.github.io/2020/04/23/Git/","excerpt":"本篇是对Git的介绍","text":"本篇是对Git的介绍 Git 版本控制系统1.版本控制系统 开发中我们把每一次修改都有效的进行记录（记录成一个版本），后期如果需要回退到原有的某个版本或者是用当前的和某一个版本进行比较等，都可以有效的进行管理。 常用的版本控制系统：SVN(集中式) / Git(分布式)2.分布式版本管理系统的特点 3.Linux团队开发的Git,所以Git中的命令大部分都是linux命令 常用的Git命令后期我们更多的是基于命令完成Git管理，所以我们需要学习一些常用的Linux命令。 Windows操作系统：DOS窗口和DOS命令 LINUX服务器操作系统：LINUX命令（MAC终端使用的也是LINUX命令）常用的命令有：ls -l/-a 查看当前目录结构(-a是可以看见所有的：包含隐藏的)cd 切换到指定的目录中（进入的地址可以粘贴到对应的操作系统命令窗口中）cd ./ 当前目录cd ../ 上级目录cd / 根目录clear: 清屏mkdir: 创建目录touch: 创建文件vi: 想文件中插入或者管理一些内容 i 进入到插入模式 ESC+:wq: 退出内容胡插入模式，把刚才编辑的内容进行保存echo xxx &gt; xxx.txt 在指定的文件中，删除原来的内容，添加新的内容ehco xxx &gt;&gt; xxx.txt 向指定的文件末尾田间新的内容cp 拷贝、复制rm 删除文件 -r(递归删除) -f(强制删除)，一旦删除无法还原 Git的常规流程1.每一个GIT仓库都有三个区 工作区：写代码 暂存区：临时存放每一次修改的代码，但是并没有生成历史版本 历史区：存放所有历史版本的地方(提交到历史区，就会生成历史版本) 2.把暂存区胡某一个文件撤回到工作区1234$ git rm --cache [file] 删除暂存区的文件$ git rm --cache . -r 删除暂存区中所有提交的 如果在撤销过程中，发现从暂存区撤销的文件，在工作区已经被修改了，只有加上-f才能强制从暂存区把内容删除$ git rm --cache [file] -r -f 3.提交到暂存区一份，把工作区内容改了，但是改的东西不好，想把暂存区上次提交的内容撤回到工作区(覆盖工作区新写的内容)1$ git checkout [file] 把暂存区的内容覆盖工作区的内容，暂存区的内容并没有消失，只是把工作区的最新修改的内容更改了，工作区和暂存区保持了一致。 4123$ git diff [file] 比较暂存区和工作区的差别$ git diff --cached$ git diff master 比较工作区和历史区master的差别 一些细节问题1.如果是第一次使用git，生成历史版本的时候，需要提供身份认证需要在本地GIT全局作用域下设置一些信息12$ git config --global user.name 'xxx'$ git config --global user.email 'xxx@xx.com' 2.真实项目中并不是所有的文件都和项目有关系(例如.idea是WS生成的配置文件夹和项目没关系)，也不是所有的文件都提交(例如node_modules中的内容太大了，也不需要提交) .gitignore =&gt;git提交的忽略文件 3.查看历史版本信息1git log 代码回滚操作1234$ git checkout . 把暂存区内容回滚到工作区(一旦回滚，工作区内容无法恢复)$ git reset HEAD . 把当前暂存区的内容回滚到上一个暂存区，目的是为了把上一个暂存区的内容回滚到工作区$ git reset --hard 版本号 在历史区中回退到某一个版本(强制把暂存区和工作区都变成回退后的版本)$ history &gt; xx.txt 把历史操作步骤输出到xx.txt中 团队开发的工作流程; 1.基础流程 1) 首先创建中央仓库：可以基于github/codding来创建 把开发者都列入仓库的开发群组中，这样每一个开发者用自己的github账号都有权限操作这个仓库了(不这样做也可以，所有开发者用同一个账号也可以，为了防止不知道是谁提交的，我们需要让每一个客户端在本地的GIT全局配置中，设置和GITHUB相同的用户名和邮箱) 2) 创建客户端本地仓库(一个开发者就是一个单独的仓库)，还需要让本地的仓库和远程仓库保持关联，这样才可以实现后续的信息同步 $ git init 创建本地仓库 $ git remote add origin “远程仓库地址” 让本地仓库肯远程仓库保持连接 $ git remote -v 查看链接信息(origin是连接的名称，一般都用这个名字，当然自己可以随便设置) $ git remote rm origin 移除链接 $ git remote update origin 更新便捷通道 有更简单的方式，只要把远程仓库克隆到本地，就相当于创建本地仓库，而且自动建立了链接，并且把远程仓库的内容衣同步到了本地 $ git clone “远程仓库地址” “本地仓库目录名字（不写，默认椒仓库名）” 3) 各自和中央服务器同步信息 推送： $git push origin master (每次push之前最好pull一下,如果有冲突，在本地处理冲突，然后再提交); 拉取： $ git pull origin master 无分支管理模式 - 不是同一行代码冲突：在提示的冲突命令行中同意即可 ESC： wq(按下ENTER键即可) 然后提交 - 同一行代码冲突，需要手动把代码进行合并，然后重新提交 单独分支管理模式(分支管控的只是历史区，我们创建分支，就是创建不同的线路来管理历史版本) 1，每天第一件事就是把远程master拉取到本地的master上(提交之前也是) - 在本地仓库创建分支 `$ git branch [分支名字]` - git checkout dev 切换到dev分支上 - git checkout -b [分支] 创建屏切换到这个文件 - 分支创建完成，会自动把本地master分支上的内容同步到dev分支上 把dev的内容合并到到master分支上，合并完成之后推送到中央服务器 - git stash 暂存文件(分支有修改，不能直接切换分支，需要把修改的内容暂存) - 切换到master分支上 - git stash pop 还原暂时存储的内容 当工作去或暂存区还有没有提交的内容时，使用stash 或者 pop命令 - git merge dev(把dev分支合并到master分支上)","categories":[],"tags":[]},{"title":"Axios & Fetch","slug":"AXIOS","date":"2020-04-20T09:16:39.000Z","updated":"2020-04-23T05:03:14.651Z","comments":true,"path":"2020/04/20/AXIOS/","link":"","permalink":"https://abluecup.github.io/2020/04/20/AXIOS/","excerpt":"本篇是对Axios和Fetch的介绍：","text":"本篇是对Axios和Fetch的介绍： AXIOS是基于PROMISE管理的AJAX库12345678910111213141516171819202122232425262728293031323334353637 /** * axios: 它是一个类库，基于PROMISE管理AJAX库 * 1, 它提供了对应的请求方法使得方法（get/post/header/delete/put/options） * axios.get() 向服务器发送一个请求，基于GET方式 * 2, 支持的参数配置 * axios.get([URL],[OPTIONS]); * 3， 基于GET或者POST方法发送请求，返回的结果都是PROMISE实例 */console.log(axios);axios.get('temp.xml',&#123; //GET请求中，会把PARAMS中的键值对拼接成URLENCODED格式的字符串，然后以问号传参的方式传递给服务器，类似于JQ-AJAX中的DATA(或者自己基于URL后面拼接也可以，不用PARAMS) params:&#123; name:'zhufeng', age:9 &#125;&#125;);axios.post('temp.xml',&#123; //配置项中传递的内容都相当于基于请求主体传递给服务器，但是传递给服务器的内容格式是RAW（JSON格式字符串）,不是X-WWW-FORM-URLENCODED格式 name:'zhufeng', age:9&#125;);promise.then(result=&gt;&#123; console.log(result); //获取的结果是个对象 /** * data: 从服务器获取的响应头信息 * headers: 从服务器获取的响应头信息 * request: 创建的AJAX实例 * status: 状态码 * statusText: 状态码描述 * config：向AXIOS发送请求的时候做的配置项 */&#125;).catch(msg=&gt;&#123; console.log(msg); //请求失败的原因&#125;) 同时处理多个请求后再执行1234567891011121314// sendAry中存放三个AJAX请求的PROMISE实例let sendAry=[ axios.get('temp.json'), axios.post('temp.json'), axios.header('temp.json')];axios.all(sendAry).then(result=&gt;&#123; console.log(result); // 是一个数组，分别存储每一个请求的结果&#125;);// 三个请求都完成才做一些事情，可以基于ALL实现axios.all(sendAry).then(axios.spread((resA,resB,resC)=&gt;&#123; //RESA / B /C 分别代表三次请求的结果 // 原理是JS中的柯里化函数&#125;)); 常用的AXIOS中的配置123456789101112131415161718192021222324252627282930313233343536axios.defaults.baseURL= 'https://www.easy-mock.com/mock/09090/temp';axios.get('/list').then(result=&gt;&#123; ....&#125;);//自定义成功失败规则，成功执行resolve,失败执行reject(默认规则：状态码以2开头是成功)axios.defaults.ValidateStatus = function(status)&#123; return /^(2|3)\\d&#123;2&#125;$/.test(status);&#125;axios.defaults.timeout = 3000axios.defaults.headers=&#123;//自定义请求头， result中的headers是响应头中的信息 name:'zf'&#125;axios.defaults.params=&#123;&#125;//GET传参axios.defaults.data=&#123;&#125;//POST传参 一般参数我们不写在公共配置中axios.defaults.headers['Content-Type']='application/x-www-form-urlencoded'//设置POST请求下基于请求主体向服务器发送传送内容的格式，默认是RAWaxios.defaults.transformRequest=function(data)&#123; //data是请求主体中需要传递给服务器的内容（对象） let str = ``; for(let attr in data)&#123; if(data.hasOwnProperty(attr))&#123; str +=`$&#123;attr&#125;=$&#123;data[attr]&#125;&amp;` &#125; &#125; return str.substring(0, str.length-1);&#125;axios.interceptors.response.use(function success(result)&#123; return result.data;&#125;, function error()&#123; //失败我们一般不做处理&#125;)//设置响应头拦截器：分别在响应成功和失败的时候做一些拦截处理（在执行成功后设定的方法之前，先会执行拦截器中的方法）axios.post('/add', &#123; lx:12&#125;); FetchFetch不是AJAX，它诞生的目的是为了代替AJAX，它是JS中内置的API:基于FETCH可以实现客户端和服务器端的信息通信； 1，FETCH是ES2018规范中新增的API,所以浏览器的支持度不是特别好（可以基于babel的最新语法解析包，把它解析），想要兼容性好一些，需要使用 fetch polyfill 2, 使用FETCH发送请求 =&gt; GET/HEADER等请求不能设置BODY, POST中body中只支持字符串，a=1&amp;b=2,不支持对象，GET中只能在URL拼接 =&gt; 不管服务器返回的状态是多少，FETCH都不认为是失败（哪怕是4或者5开头的状态码），都执行的是THEN中的方法（需要我们自己进行一场抛出处理）123456789101112131415161718192021222324252627fetch('temp.json', &#123; method: 'get', headers:&#123;'content-type':'x-www-form-urlencoded'&#125;, credentials:'include' //不管同源还是跨域请求都带着COOKIE信息&#125;,).then(res=&gt;&#123; console.log(res); //res本身是一个对象 /** * headers:&#123;&#125; 响应头信息 * status: 状态码 * statusText: 状态码描述 * type: 'basic' / 'cors' * url: 请求的地址 * __proto__: 指向Response * arrayBuffer: * blob() * json() * text() * ... * 基于这些方法可以快速把从服务器获取的结果找到 */ // 不管成功还是失败都会走then，而不是catch&#125;).catch(msg=&gt;&#123; console.log(msg); &#125;); 真实项目中的写法123456789101112131415fetch('temp.json', &#123; method: 'get'&#125;).then(result =&gt; &#123; let &#123; status &#125; = result; if (/^(4|5)\\d&#123;2&#125;$/.test(status)) &#123; throw new Error('query data is error'); return; &#125; return result.json();&#125;).then(res =&gt; &#123; console.log(res);&#125;).catch(msg=&gt;&#123; console.log(msg); &#125;); 基于PROMISE封装AJAX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111; (function anonymous(window) &#123; //设置默认的参数配置项 let _default = &#123; method: 'GET', url: '', baseURL: '', headers: &#123;&#125;, dataType: 'JSON', data: null, //POST系列请求基于请求主体传递给服务器的内容 params: null, //GET请求基于问号传参传递给服务器的内容 cache: true &#125; //基于promise设置模式管理AJAX请求 let ajaxPromise = function ajaxPromise(options) &#123; //options中融合了默认配置信息，用户基于DEFAULTS修改的信息，用户执行GET/POST方法的时候传递的配置信息，越靠后的优先级越高 let &#123; url, baseURL, method, data, dataType, headers, cache, params &#125; = options; //把传递的参数进一步处理 if (/^(GET|DELETE|HEAD|OPTIONS)$/i.test(method)) &#123; //GET系列 if (params) &#123; url += `$&#123;ajaxPromise.check(url)&#125;$&#123;ajaxPromise.formatData(params)&#125;`; &#125;; if (cache === false) &#123; url += `$&#123;ajaxPromise.check(url)&#125;_=$&#123;+(new Date())&#125;`; &#125; data = null; // GET系列请求主体就是什么都不放，即使写了也要改为NULL &#125; else &#123; //POST系列 if (data) &#123; data = ajaxPromise.formatData(data); &#125; &#125; //基于PROMISE管理发送AJAX return new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest; xhr.open(method, url); // 如果headers存在，我们要设置请求头 if (typeof headers === 'object' &amp;&amp; headers !== null) &#123; for (let attr in headers) &#123; if (headers.hasOwnProperty(attr)) &#123; let value = headers[attr]; if (/[\\u4e00-\\u9fa5]/.test(value)) &#123; //value中包含中文，我们把它进行编码 encodeURIComponent / decodeURIComponent(解码) val = encodeURIComponent(value); &#125; xhr.setRequestHeader(attr, headers[attr]); &#125; &#125; &#125; xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (/^(2|3)\\d&#123;2&#125;$/.test(xhr.status)) &#123; let result = xhr.responseText; dataType = dataType.toUpperCase(); dataType === 'JSON' ? result = JSON.parse(result) : (dataType === 'XML' ? result = xhr.responseXML : null); resolve(result); return; &#125; reject(xhr.status); &#125; &#125; xhr.send(data); &#125;); &#125; //把默认配置暴露出去，后期用户在使用的时候可以自己设置一些基础的默认值（发送AJAX请求的时候按照配置的信息进行处理） ajaxPromise.defaults = _default; // ['get', 'delete', 'head', 'options'].forEach(item =&gt; &#123; ajaxPromise[item] = function anonymous(url, options = &#123;&#125;) &#123; options = &#123; ..._default, //默认值或者基于defaults修改的值 ...options, //用户调取方法传递的配置项 url: url, // 请求的URL地址：默认的配置项和传递的配置项中都没有，只能这样获取 method: item.toUpperCase() //以后执行肯定是ajaxPromise.head执行，不会设置METHODS这个配置项，我们自己需要配置 &#125;; return ajaxPromise(options); &#125; &#125;); ['post', 'put', 'patch'].forEach(item =&gt; &#123; ajaxPromise[item] = function anonymous(url, data = &#123;&#125;, options = &#123;&#125;) &#123; options = &#123; ..._default, //默认值或者基于defaults修改的值 ...options, //用户调取方法传递的配置项 url: url, // 请求的URL地址：默认的配置项和传递的配置项中都没有，只能这样获取 method: item.toUpperCase(), //以后执行肯定是ajaxPromise.head执行，不会设置METHODS这个配置项，我们自己需要配置 data: data &#125;; return ajaxPromise(options); &#125; &#125;); //把对象变成URLencoded字符串 ajaxPromise.formatData = function (obj) &#123; let str = ``; for (let attr in obj) &#123; if (obj.hasOwnProperty(attr)) &#123; str += `$&#123;attr&#125;=$&#123;obj[attr]&#125;&amp;`; &#125; &#125; return str.substring(0, str.length - 1); &#125; ajaxPromise.check = function (url) &#123; return url.indexOf('?') &gt; -1 ? '&amp;' : '?'; &#125; window.ajaxPromise = ajaxPromise;&#125;)(window);// ajaxPromise.get/post","categories":[],"tags":[]},{"title":"信息传输","slug":"信息传输","date":"2020-04-08T08:36:27.000Z","updated":"2020-04-23T05:10:10.639Z","comments":true,"path":"2020/04/08/信息传输/","link":"","permalink":"https://abluecup.github.io/2020/04/08/信息传输/","excerpt":"本篇内容主要讲述服务器相关内容","text":"本篇内容主要讲述服务器相关内容 客户端和服务器交互模型面试必问问题：打开浏览器，在地址栏输入一个地址，按下ENTER键，到看到页面，中间都发生了什么？ 【HTTP请求阶段：向服务器发送请求】1, 浏览器首先向DNS域名解析服务器发出请求；2，DNS反解析：根据浏览器请求中的地址，到DNS服务器中找到对应的服务器外网IP地址3，通过找到的外网IP，向对应的服务器发送请求（首先访问的是服务器的WEB站点管理工具：准确来说，是我们先基于工具在服务器上创建很多服务，当有客户端访问的时候，服务器会匹配出具体是请求的哪个任务）4，通过url地址中携带的端口号，找到服务器上对应的服务，以及服务所管理的项目源文件 【HTTP响应阶段：服务器把客户端需要的内容准备好，并且返回给客户端】5，服务器端根据请求地址中的路径名称、问好传参或者哈希值，把客户端需要的内容进行准备和处理6，把准备的内容响应给客户端（如果请求的是html或者css这样的资源文件，服务器返回的是资源文件中的源代码（不是文件本身）） 【浏览器渲染阶段】7，客户端浏览器接受服务器返回的源代码，基于自己内部的渲染引擎（内核）开始进行页面的渲染和绘制；-&gt;首先计算DOM结构，生成DOM TREE-&gt;自上而下运行代码，加载css等资源内容-&gt;根据获取的css开始渲染（绘制）页面：render tree（）-&gt; 开始渲染 1)我们把一次完整的 请求+响应 称之为“HTTP事务”事务是一次完成的操作，请求和响应缺一不可 2)一个页面完全加载完成，需要向服务器发起很多次HTTP事务操作 一般来说，首先把HTMl源代码拿回来，加载HTML的时候，遇到link/script/img[src]/iframe/video和audio[preload=’none’]。。。都会重新和服务器端建立HTTP事务交互 特殊情况：如果我们做了资源缓存处理（304），而且即将加载的资源在之前已经加载过了，这样的操作和传统的http事务有所不同，它们是从服务器和浏览器的缓存中读取数据，比传统的读取快很多 3）从客户端向服务器发送请求，以及服务器吧请求响应给客户端的时候，中间相互传递了很多内容（客户端把一些内容传递给服务器，服务器把一些内容传递给客户端，我们把传递的内容统称为 HTTP报文） 前端性能优化：1，减少HTTP请求的次数及请求内容的大小 一个完整的url的组成1，URL/URN/URI uri = url &amp; urn URI: 统一资源标识符 URL: 统一资源定位符 URN: 统一资源名称2，url的组成部分http://www.zhufengpeixun.cn:80/stu/index.html?name=xxx&amp;age=25#teacher 【http】传输协议：用来传输客户端和服务器端交互的信息的，类似于快递小哥，常用的有 http： 超文本传输协议（除了传递普通的文本，还可以传递文件流，或者进制编码等信息）是目前最常用的WEB传输协议 https: 基于SSL（Secure Sockets Layer 安全套接层）加密的传输协议，比http更加安全（涉及支付的网站一般都是基于https完成的） ftp: 文件传输协议，一般用来实现资源文件在服务器上的上传下载[www.zhufengpeixun.cn]域名 Domain Name 一级域名（顶级域名）www.qq.com 二级域名 sports.qq.com 三级域名 kbs.sports.qq.com .. .com 供商用的国际域名 .cn 供商用的中文域名 .net 用于网络供应服务商（系统类的经常使用net域名） .org 用于官方组织 .edu 教育机构 .gov 政府机构 【:80】端口号，用来区分同一台服务器上不同服务的标识（基于WEB服务管理工具创建服务的时候可以指定），不同服务之间一般是不能使用相同的端口号的http 80https 443ftp 21如果当前网站服务，采用的是协议对应的默认端口管理，那么当用户输入网址的时候可以不指定端口号，浏览器会默认把用户默认的端口传递给服务器 一台服务器上的端口号范围 0 ～ 65535之间 服务器上安装一款应用都可能会作为一个服务，占用一个端口号 [stu/index.html] 请求的路径名称 path pathname stu/index.html 一般都是请求当前服务对应的项目目录中stu目录下的index.html。但是也有特殊情况，就是当前的url是被“伪url重写”的，我们看到的URL请求不是真实的请求（例如 https://item.jd.com/4679424.html）,这个url是被重写的，他的真实地址有可能是 https://item.jd.com/details.jsp?id=4679424，其实就是跳转到详情页，通过问号传递的不同产品的编号，展示不同的产品信息，但是.jsp这种服务器渲染的动态页面不能被搜索引擎收录，不利于页面的SEO，所以我们会把动态页面静态化，这也就用到了url重写技术 /stu/info 这种没有任何后缀信息，一般都不是用来请求资源文件的，而是用于ajax数据请求的接口地址，如果后缀是.json类的，也是同理，但是有一种除外 /stu/info/这种很可能不是接口地址，而是没有指定请求的资源名称，服务器会请求默认的资源文件，一般都是index.html/default.html DHTML: 动态页面，泛指当前页面中的内容不是写死的而是动态绑定的，例如 .jsp/.php/.aspx,...这些页面中的数据都是基于AJAX或者后台编程语言处理，由服务器渲染，最后把渲染的结果返回给客户端呈现出来 [?name=xxx&amp;age=25#teacher]问号传参以及哈希在HTTP事务中，？传参是客户端把信息传递给服务器的一种方式（有可能是A页面渲染到B页面，也有可能是跳转到一个页面，把参数值传递给页面用来标识的）哈希值一般都跟客户端服务器交互没啥关系，主要用于页面中的锚点定位和哈希路由切换 HTTP报文起始行 ：请求起始行、响应起始行首部（头）：请求头、响应头、通用头主体：请求主体、响应主体 General 通用头Request URL: http://zhufengpeixun.com/ 请求地址Request Method: GET 请求方式 GET/POST/DELETE/PUT/HEAD/OPTIONStatus Code: 200 OK 响应的HTTP状态吗Remote Address: 123.57.243.166:80 主机地址（服务器外网IP地址）Referrer Policy: no-referrer-when-downgrade Request Headers 请求头 [客户端设置、服务器端接收]123456789101112GET / HTTP/1.1 起始行：（描述当前请求的一些基本信息，用的是1.1版本传输协议进行内容传输的）Host: zhufengpeixun.com Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3654.0 Mobile Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Cookie: pgv_pvi=3852008448; tencentSig=5939430400; _qddaz=QD.u3qz1b.ov06ek.k6g5okvq; IESESSION=alive; Hm_lvt_418b1c90fa35dc210dd5d2284d9f9f29=1586498727; pgv_si=s5373796352; __root_domain_v=.zhufengpeixun.com; _qdda=2-1.1; _qddab=2-u18pab.k8tsdoo6; _qddamta_2852156370=2-0; _qddamta_4001806960=2-0; Hm_lpvt_418b1c90fa35dc210dd5d2284d9f9f29=1586498744 cookie信息一般都是放到头文件中实现和服务器端的数据通信的If-None-Match: &quot;5c0cf3-fbaa-5a1a421dd2c9c&quot; If-Modified-Since: Wed, 25 Mar 2020 01:53:18 GMT 服务器端上次修改时间 Response Headers 响应头【服务器端设置、客户端获取】123456789101112HTTP/1.1 200 OK 起始行：（描述当前请求的一些基本信息，用的是1.1版本传输协议进行内容传输的）Date: Fri, 10 Apr 2020 06:12:53 GMT 服务器响应内容的时候的服务器时间（客户端获取这个时间的时候已经和真实时间产生误差了，因为服务器返回内容到客户端接收到也是需要时间的），而且这个时间是格林尼治时间Server: ApacheLast-Modified: Wed, 25 Mar 2020 01:53:18 GMT 服务器端上次修改时间ETag: &quot;5c0cf3-fbaa-5a1a421dd2c9c&quot;Accept-Ranges: bytesVary: Accept-Encoding,User-AgentContent-Length: 12936Content-Type: text/htmlVia: 1.1 cn-p-sh-bldg800-01Connection: Keep-AliveContent-Encoding: gzip Responds响应主体：服务器返回的是啥就是啥 Request Payload / Form Data [请求主体]1客户端发送给服务器短的内容 了解HTTP报文以及如何查看对未来工作开发和BUG调试至关重要，以后涉及到交互功能(前端《=》后台)出现问题，都按照如下方式查找问题原因；A: 打开控制台，在network中找到当前交互的请求地址，点击进去看详情B: 如果是传递给服务器的参数或者方式错误【前端问题】C: 如果服务器返回的信息错误或者和API规定的内容不一样【后台问题】D: 如果返回数据是对的，但是展示有问题【前端问题】确定是自己前端的问题后，基于断点（或者代码中的debugger）或者控制台输出等方式，开始逐步调试即可 3, 客户端和服务器端信息交互的方式 [客户端传递给服务器] A: ?传参 请求的url地址末尾通过问号传参的方式，把一些信息传递给服务器 B: 设置请求头 客户端把需要传递给服务器端的内容设置到请求头信息中（自定义请求头），服务器端可以通过接收请求头信息把内容得到 C: 设置请求主体 xhr.send([ajax send中传递的内容就是客户端设置的请求主体内容,服务器端可以接收到这些信息的]) 【服务器返回给客户端】 A: 设置响应头，例如把服务器时间通过响应头返回给客户端，客户端通过获取响应头信息得到这个时间（响应头返回的速度优先于响应主体） B: 设置响应主体 主要的返回信息都在响应主体当中 前端新能优化方案 减少HTTP 请求次数和请求大小 代码优化：有利于SEO，有利于扩展维护，有利于减少性能消耗 DNS及HTTP通信方式的优化 【js代码优化的108条建议】 [雅虎css优化的36条建议] 1，在JS中尽量减少闭包的使用（闭包会产生不销毁的栈内存）， A:循环给元素做事件绑定的时候，尽可能把后期需要的信息（例如索引）存储到元素的自定义属性上，而不是创建闭包存储 B:在最外层形成一个闭包，把一些后续需要的公共信息进行存储，而不是每一个方法都创建一个闭包（例如单例模式） C:尽可能手动释放，不被占用内存 null …2, 尽量合并css和js文件 把需要引入的css合并为一个，js也合并为一个，原理是减少http请求次数，尽可能把合并后的代码进行压缩，减少Http请求资源的大小 A:WEBPACK这种自动化构建工具，可以帮我们实现代码的合并和压缩（工程化开发） B:在移动端开发（或者追求高性能的PC开发【例如百度首页】），如果css或者js不是需要很多，我们可以选择把css和js搞成内嵌式，也就是代码直接写在html里面3，尽量使用字体图标或者SVG图标来代替传统的png等格式图片（因为字体图标等是矢量图，放大不会变形【基于代码编写出来的】，而且渲染速度快，相对比位图要小一些）4，减少对DOM的操作，主要是减少DOM的重绘和回流（重排）A：关于重排的分离读写（把设置操作写在一起）B: 使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）5，在JS中避免“嵌套循环”（这种会额外增加很多循环次数）和“死循环”6，采用图片的“懒加载”（延迟加载） 目的是为了减少页面第一次加载过程中HTTP的请求次数，让页面打开的速度变快 步骤：开始加载页面的时候，所有的真实图片都不去发送HTTP请求加载，而是给一张背景图，当页面加载完成，并且图片在可视区域内，我们再去做图片的加载7，基于浏览器和服务器端的缓存技术（304缓存）把一些不经常更新的静态资源文件做缓存处理，例如JS,CSS,静态图片都可以做缓存 原理也是为了减少HTTP请求的大小，让获取速度更快8，尽可能使用事件委托（事件代理），来处理事件绑定的操作，减少DOM的频繁操作，其中包括给每一个DOM元素做事件绑定9，尽量减少CSS表达式的使用 1width: expression(document.body.clientWidth - 110 + &apos;px&apos;) 10, css选择器解析规则是从右向左解析1234.container .link a&#123; 先找到所有的a，再筛选出在.link中的，在筛选出.container类中的， 先找到的是所有的a，操作起来很耗性能，我们在使用css选择器的时候尽可能减少对标签选择器的使用&#125; 11，css雪碧图技术（css sprite / css图片精灵） 把所有相对较小的资源图片汇总到一张大图上，后期我们只需要把大图加载下来，用背景定位的方式展示对应的小图即可 123456789.bg&#123; background:url(&apos;xx.png&apos;);&#125;.box1&#123; background-position:xx xx;&#125;.box2&#123; background-position:xx xx;&#125; 12，减少对于cookie的使用，最主要的是减少本地cookie存储内容的大小，因为客户端操作cookie的时候，这些信息总是在客户端和服务器端传来传去 13，页面中的数据获取采用异步编程和延迟分批加载 使用异步获取数据是为了降低HTTP通道堵塞，不会因为数据没有请求回来耽误下面信息的渲染，提高页面的打开速度 我们可以这样处理：需要动态绑定的区域，先隐藏，等数据返回并绑定完成后，再让其显示。 延迟分批加载是为了减少第一次页面加载的时候HTTP请求次数，类似于图片懒加载 14, 页面中出现音视频标签，我们不让页面加载的时候就去加载资源，不然页面加载速度特别慢 preload=’none’等到页面加载完成音视频播放的时候，我们再去加载资源 15,在客户端和服务器端进行交互的时候，对于多项数据，我们尽可能给予JSON格式来进行传送（JSON格式的数据处理方便，资源偏小） ===&gt; 相对于xml格式的传输才会有这个优势 16，尽可能实现JS的封装，低耦合、高内聚，减少页面中的冗余代码，减少HTTP请求资源的大小17，css中设置定位后，最好使用ZINDEX改变盒子层级，让所有的盒子不在相同的平面上，这样后续处理的时候，性能会有一丢丢的提高18，在基于AJAX的GET请求进行数据交互的时候，根据需求可以让其产生缓存（这个缓存不是304缓存） 这样下一次从相同的地址获取的数据是上一次缓存的数据（但是很少用，项目中一般可以清除这个缓存的时候偏多）19，尽量减少对于filter滤镜属性的使用（这个属性消耗性能较大一些）20，在css导入的时候，尽量减少使用@import导入式，因为@import是同步操作，只有把这个对应的css导入，才会向下加载，而link是异步操作21，使用window.requestAnimationFrame() 【JS中的帧动画】 代替传统的定时器动画22，减少递归的使用，避免由于递归导致的内存嵌套（建议使用尾递归）23，避免使用iframe，这个标签不仅不好管控样式，而且相当于在一个页面中加载了其他页面，非常消耗性能24，利用H5中提供的localstorage本地存储或者manifest离线缓存，做一些信息的本地存储，下次加载页面的时候直接从本地获取，减少HTTP请求次数25, 调取JS的时候，可使用defer或者async来异步加载26， 重量级优化：做CDN加速（不属于前端优化），烧钱机器，非常烧钱CDN是地域式分布，在热门地区设置服务器机组，附近的用户访问的都是离其最近的机组CMS 内容分发管理系统 =========额外技巧======1，我们一般都把css放在body上面，js放在body下面，让其先加载css，再加载js(保证页面渲染的过程中，元素是带着样式渲染的，而js一般都是用来操作DOM元素的，需要等待元素加载完成)2，能用css搞定的绝对不用JS，能用原生JS搞定的绝对不用插件，绝对不是用FLASH（除了音视频的低版本浏览器播放） css处理动画的性能优于JS，而且css中的transform还开启了硬件加速3,123for(var i=0, len = array.length; i&lt;len;i++)&#123;&#125;; 4，JS中尽量减少对eval的使用，因为JS合并压缩的时候，可能出现由于符号不完善，导致代码执行优先级错乱的问题，eval处理起来消耗的性能也偏大5，使用keep-alive实现客户端和服务器端的长连接6， 尽量使用设计模式管理代码 发布订阅、单例、构造、Promise7，开启服务器端的gzip压缩（这个压缩可以有效减少请求资源的大小），其实客户端的图片等资源也是可以压缩的（但是对于24位的位图，压缩后可能会变模糊） 8，页面中不要出现无效的链接（利于SEO优化），还有其他技巧，提高关键字曝光率、Img需要加alt、设置meta标签 9，避免使用with语句（非常耗性能） AJAX1,async javascript and xml 异步的javascript和xml在AJAX中的异步不是我们理解的同步异步编程，而是泛指“局部刷新”，但是我们在以后的AJAX请求中金肯呢个使用异步获取数据，（因为异步获取数据不会阻塞下面代码的执行）XML是一种文件格式（我们可以把html理解为XML的一种），可扩展的标记语言，它的作用是用自己扩展的一些语义标签来存储一些数据和内容，这样存储的好处是可以清晰的展现数据结构在很久以前，AJAX刚刚兴起的时候，客户端从服务器端获取数据，服务器为了清楚的表达数据结构，都是返回XML格式的内容，当下我们获取的数据一般都是JSON格式的内容，JSON相对于XML来说，也能清晰表达数据结构，而且访问里面数据的时候，操作起来比XML更简单（但是现在某些项目中服务器返回的数据不单纯是数据，而是数据和需要展示的结构拼接好的结果，类似于我们自己做的字符串拼接，也就是说服务器端把数据和结构拼接好了返回给客户端，此时返回的数据格式一般都是XML格式的字符串）12345678&lt;?xml version='1.0' encoding=\"utf-8\"?&gt;&lt;root&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;22&lt;/age&gt; &lt;english&gt;100&lt;/english&gt; &lt;/student&gt;&lt;/root&gt; 2，全局刷新和局部刷新 3，ajax操作1234567891011121314151617181920// 创建AJAX实例let xhr = new XMLHttpRequest(); //iE6中不兼容，使用的是 new ActiveXObject来实现// 打开请求：发送请求之前的配置项//HTTP METHOD请求方式： get/delete/head/options/trace/connect// post/put// 2,url,向服务器发送请求的API（Application Programing Interface）接口地址//3,async 设置请求的同步异步，默认是异步（true）,false是同步，项目中使用异步，防止阻塞// username,userpass 用户名和密码，一般不用xhr.open(&#123; [HTTP METHOD],[URL],[ASYNC],[USER-NAME],[USER-PASS]&#125;);//事件监听，一般监听的都是READY-STATE-CHANGE 事件（AJAX状态改变事件），基于这个事件可以获取服务器返回的响应头响应的主体内容xhr.onreadystatechange=function()&#123; if(xhr.readyState==4 &amp;&amp; xhr.status ==200)&#123; xhr.responseText; &#125;&#125;//发送AJAX请求，从这步开始，当前AJAX任务开始，如果AJAX是同步的，后续代码不会执行，要等到AJAX状态成功后再执行，反之异步不会xhr.send([请求主题内容]); 4, 关于HTTP请求方式的一点学习所有的请求都可以服务器端传递内容，也都可以从服务器端获取内容GET：从服务器端获取数据（给的少，拿得多）POST:(推送)，向服务器端推送数据（给得多，拿的少）DELETE:删除服务器端的某些内容（一般是删除一些文件）PUT:向服务器上存放一些内容（一般也是一些文件）HEAD:只想获取服务器返回的响应头信息，不要响应主体中的内容OPTIONS:一般使用它向服务器发送一个探测性请求，如果服务器端返回了信息，说明当前客户端和服务器端建立了连接，我们可以继续执行其他请求了（TRACE是干这件事的，但是AXIOX这个AJAX类库在基于cross domain进行跨域请求的时候，就是先发送options请求探测尝试，如果能连通服务器，才会继续发送其他请求）CONNECT:保留协议，暂时不用 GET VS POST【传递给服务器信息的方式不一样】 GET是基于URL地址 问号传参 的方式把信息传递给服务器 POST是基于请求主体把信息传递给服务器 (easy-mock) 1234[GET]xhr.open(&apos;get&apos;,&apos;url?xx=xxx&amp;xx=xxx&apos;)[POST]xhr.send(&apos;xx=xxx&amp;xx=xxx&apos;); GET一般应用于拿，给服务器的少一些，而POST给服务器的多，如果POST是基于问号传参的方式来搞，会出现一些问题，url会拼很长。浏览器对于URL的长度都有最大限度（谷歌是8KB,火狐是7kb,ie是2kb）,超过的部分浏览器就把它截下了 =&gt; 所以GET请求可以基于URL传参，而POST都是使用请求主体传递（请求主体理论上是没有限制的，但是真实项目中我们会自己做大小限制，防止上传过大信息，导致请求迟迟完不成） 【GET不安全，POST相对安全】 因为GET是基于问号传参把信息传递给服务器的，容易被骇客进行URL劫持，POST是基于请求主体传递的，相对来说不好被劫持。所以登录注册等涉及安全性的交互操作，我们都应该用POST请求。 【GET请求会产生不可控制的缓存，POST不会】 不可控：不是想要就要，想不要就不要的，这是浏览器自主记忆的缓存，我们无法基于JS控制，真实项目中，我们都会把这个缓存干掉 GET请求产生缓存是因为连续多次向相同的地址，并且连续多次传递的信息也是相同的，浏览器会把之前获取的数据从缓存中拿到返回，导致无法获取服务器最新的数据 POST不会 解决方案： 12xhr.open(&apos;get&apos;, &apos;/temp/list?id=1000&amp;lx=2000&amp;_=$(Math.random()));//保证每次请求的地址不完全一致：在每一次请求的末尾追加一个随机数即可（使用_作为属性名就是不想和其他的属性名冲突） 5，ajax状态 0 unsend 刚开始创建，还没有发送 1 opened 已经执行了open这个操作 2 headers_received 已经发送AJAX请求（AJAX任务开始），响应头信息已经被客户端接收了（响应头中包含了服务器的时间以及HTTP状态码） 3 loading 响应主体内容正在返回 4 done 响应主体内容已经被客户端接收 6，HTTP网络状态码（STATUS）根据状态码能够清楚的反映出当前交互的结果及原因 200 ok 成功（只能证明服务器成功返回信息了，凡是信息不一定是你业务需要的） 301 Move Permanently 永久转移（永久重定向） 域名更改：访问原始域名重定向到新的域名 302 Move Temporarily临时转移（临时重定向 =&gt; 307） 网站是基于https协议，如果访问的是HTTP协议，会基于307重定向到https协议上 302一般用作服务器负载均衡：当一台服务器达到最大并发数的时候，会把后续访问的用户临时转移到其他的服务器机组上处理 真实项目中，会把所有的图片放到单独的服务器上（图片服务器），这样减少主服务器的压力，当用户向主服务器访问图片的时候，主服务器都把它转移到图片服务器上处理 304 Not Modified 设置缓存 对于不经常更新的资源文件，例如css js html img等，服务器会结合客户端设置304缓存，第一次加载过这些资源就缓存到客户端了，下次再获取的时候，是从缓存中获取，如果资源更新了，服务器端会通过最后修改时间来强制让客户端从服务器重新拉取。基于CTRL+F5强制刷新页面，304缓存就没有了 400 Bad Request 请求参数错误 401 无权限访问 404 not found 找不到资源（地址不存在） 407 代理无权限 413 Request Entity Too Large 和服务器交互的资源超过服务器最大的限制 500 Internal Server Error 未知的服务器错误 503 Service Unavailabe 服务器超负荷 7, 关于XHR的属性和方法xhr.reponse 响应主体内容xhr.reponseText 响应主体内容是字符串（JSON或者XML格式字符串都可以）xhr.reponseXML 响应主体内容是XML文档 xhr.status 返回的HTTP状态码xhr.statusText 返回的状态码的描述 xhr.timeout 设置请求超时的时间 xhr.timeout = 3000 (毫秒) xhr.ontimeout = function(){“请求超时”} xhr.withCredentials 是否允许跨域 xhr.abort() 强制中断AJAX请求xhr.getAllResponseHeaders() 获取所有响应头信息xhr.getResponseHeader([key]) 获取Key对应的响应头信息xhr.open() 打开URL请求xhr.send() 发送请求xhr.setRequestHeader() 设置请求头, 不能是中文xhr.overrideMimeType() 重写MIME类型 123456789101112let xhr = new XMLHttpRequest();xhr.open('get', 'temp.xml');xhr.onreadystatechange=()=&gt;&#123; // 监听的是AJAX状态改变事件：设置监听之前有一个状态，当后续状态和设置之前的状态不相同的时候，才会触发这个状态 if (xhr.readyState == 2) &#123; console.log(1); &#125; if (xhr.readyState == 4) &#123; console.log(2); &#125;&#125;xhr.send(); // 发送请求，这个执行才证明AJAX任务开始console.log(3); 主线程任务执行完成，才会执行异步任务输出结果是 3,1,2 123456789101112let xhr = new XMLHttpRequest();xhr.open('get', 'temp.xml', false);xhr.onreadystatechange=()=&gt;&#123; if (xhr.readyState == 2) &#123; //当状态为2的时候，触发了事件，但是主任务AJAX正在执行，无法执行该任务 console.log(1); &#125; if (xhr.readyState == 4) &#123; // 状态为4的时候，主任务AJAX已经执行完成，执行此任务 console.log(2); &#125;&#125;xhr.send(); // 当AJAX开始，由于是同步编程，主任务队列在状态没有变成4（任务结束）之前一直被这件事占用着，其他事情都做不了（当服务器把响应头返回的时候，状态为2，触发了事件，但是由于主任务队列没有完成，被占着呢，绑定的方法也无法执行。。所以只有状态为4的时候执行这个方法）console.log(3); 2,3 12345678910111213let xhr = new XMLHttpRequest();xhr.open('get', 'temp.xml', false);xhr.send();xhr.onreadystatechange=()=&gt;&#123; //readystate一直是4 if (xhr.readyState == 2) &#123; console.log(1); &#125; if (xhr.readyState == 4) &#123; console.log(2); &#125;&#125; console.log(3); 3 基于服务器时间做倒计时从服务器端获取时间会存在一个问题：由于服务器端返回数据需要时间，所以客户端拿到返回的“服务器时间”的时候，已经过去一会了，导致获取的时间和真实时间是有一定误差的，这个误差越小越好，那么如何减少误差：1，在AJAX为2的时候就从响应头中获取信息，而不是等到更靠后的状态42，请求方式设置为head: 只获取响应头信息即可，响应主体内容不需要 创建一个全局变量，记录第一次从后台获取的服务器时间，每一秒刷新的时候都在第一次的基础上一直累加，而不是重新从服务器获取.如果每次都从服务器获取，那么服务器的可能会因负载过重而宕机。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div class=\"timebox\"&gt;倒计时： &lt;span&gt;-- : -- : --&lt;/span&gt;&lt;/div&gt;&lt;script&gt; let timebox = document.querySelector('.timebox'), timecout = timebox.querySelector('span'), autoTimer = null, _serverTime = null ; let queryServerTime = function queryServerTime() &#123; if (_serverTime) &#123; _serverTime = new Date(_serverTime.getTime() + 1000); return _serverTime; &#125; let promise = new Promise(resolve =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open('head', 'temp.xml'); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 2) &#123; _serverTime = new Date(xhr.getResponseHeader('date')); console.log(_serverTime); resolve(_serverTime); &#125; &#125;; xhr.send(null); &#125;); return promise; &#125; let fn = function fn(serverTime) &#123; let targetTime = new Date('2020-04-17 17:44:00'); let diffTime = targetTime - serverTime; if (diffTime &gt;= 0) &#123; let hours = Math.floor(diffTime / (1000 * 3600)); diffTime = diffTime - hours * 3600000; let minutes = Math.floor(diffTime / 60000); diffTime = diffTime - minutes * 60000; let seconds = Math.floor(diffTime / 1000); hours &lt; 10 ? hours = '0' + hours : null; minutes &lt; 10 ? minutes = '0' + minutes : null; seconds &lt; 10 ? seconds = '0' + seconds : null; timecout.innerHTML = `$&#123;hours&#125; : $&#123;minutes&#125; : $&#123;seconds&#125;`; return; &#125; timebox.innerHTML = '结束了'; clearInterval(autoTimer); &#125; let computedTime = function computedTime() &#123; promise = queryServerTime(); promise instanceof Promise ? promise.then(fn) : fn(promise); &#125; autoTimer = setInterval(computedTime, 1000);&lt;/script&gt; AJAX 封装JQ中的ajax$.ajax([url],[options]) 或者 $.ajax([options])$.get / $.post / $.getJSON / $.getScript 这些方法都是基于$.ajax构建出来的快捷方法，真实项目中最常用的还是$.ajax url:请求的API地址method: 请求的方式data: 传递给服务器的信息，可以放到data中 - 如果是get请求，是基于问号传参传递过去的 - 如果是post请求，是基于请求主题传递过去的 - data的值可以是对象也可以是字符串，一般常用对象，如果是对象类型，jq会把对象转化为xx=xxx&amp;xx=xxx的模式（x-www-form-urlencoded）,如果是字符串，我们写的是什么就是什么 dataType：预设置获取结果的数据格式 TEXT/JSON/JSONP/HTML/SCRIPT/XML…(服务器返回给客户端的响应主体中的内容一般都是字符串，json格式居多，而设置DATA-TYPE=‘JSON’，JQ会内部把获取的字符串转化为JSON格式的对象 =&gt; 它不会影响服务器返回的结果，只是把返回的结果进行了二次处理)async: 设置同步或者异步（TRUE是异步，FALSE是同步）cache: 设置get请求下是否建立缓存，TRUE是建立缓存，FALSE是不建立缓存，默认是TRUE，当我们设置FALSE，并且当前请求是GET请求，JQ会在请求的URL地址末尾追加当前时间戳SUCCESS: 当AJAX请求成功执行，JQ执行回调函数的时候会从响应主体中获取的结果（可能二次处理了）当作参数传递给回调函数error: 请求失败后执行1234567891011121314151617181920$.ajax(&#123; url:'', method:'get', data:null, dataType:'JSON', async:true, cache:true, success: (result)=&gt;&#123; //result 从服务器获取的结果 &#125;, error: ()=&gt;&#123; &#125;&#125;)$.ajax('temp.xml',&#123; success:result=&gt;&#123; &#125;&#125;); ajax简单封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105; (function anonymous() &#123; function AJAX(options) &#123; return new AJAX.prototype.init(options); &#125; AJAX.prototype = &#123; constructor: AJAX, init: function init(options) &#123; let &#123; url, method = 'GET', data = null, dataType = 'JSON', async = true, cache = true, success, error &#125; = options; //MOUNT 挂载，把这些配置项挂载在实例上 ['url', 'method', 'data', 'dataType', 'async', 'cache', 'success', 'error'].forEach(itme =&gt; &#123; this[item] = item; &#125;); this.sendAjax(); &#125;, sendAjax() &#123; this.handleCache(); let &#123; method, url, async, dataType &#125; = this; let xhr = new XMLHttpRequest(); xhr.open(method, url, async); xhr.onreadystatechange = () =&gt; &#123; if (!/^(2|3)\\d&#123;2&#125;$/.test(xhr.status)) &#123; error &amp;&amp; error(xhr.statusText, xhr); return; &#125; if (xhr.readyState === 4) &#123; //处理DATA-TYPE let result = this.handleDataType(xhr); success &amp;&amp; success(result, xhr); &#125; &#125; xhr.send(); &#125;, handleDataType(xhr) &#123; let &#123; dataType &#125; = this; dataType = dataType.toUpperCase(); let result = xhr.responseText; switch (dataType) &#123; case 'TEXT': break; case 'JSON': result = JSON.parse(result); break; case 'XML': result = xhr.responseXML; break; &#125; return result; &#125;, handleData() &#123; let &#123; data, method &#125; = this; if (!data) return; if (typeof data === 'object') &#123; //如果是个object对象，我们把它转化为x-www-form-urlencoded这种模式，方便后期传递给服务器 for (let key in data) &#123; if (data.hasOwnProperty(key)) &#123; let element = data[key]; str += `$&#123;key&#125;=$&#123;data[key]&#125;&amp;`; &#125; &#125; str.length &gt; 0 ? str = str.substring(0, str.length - 1) : null; data = str; &#125;; //根据请求方式不一样，传递给服务器的方式也不一样 if (/^(GET|DETELE|HEAD|TRACE|OPTIONS)$/i.test(method)) &#123; this.url += `$&#123;this.url.indexOf('?')&gt;-1?data:null&#125;`;//通过url传递 this.data=null; return; &#125; this.data = data; //post系列，通过请求主体传递 &#125;, handleCache() &#123; let &#123; url, method, cache &#125; = this; if (/^GET$/i.test(method) &amp;&amp; cache === false) &#123; if (url.indexOf(\"?\") &gt; -1) &#123; url += `&amp;_=$&#123;+new Date()&#125;`; return; &#125; url += `?_=$&#123;+new Date()&#125;`; //URL时间末尾追加时间戳 &#125; &#125;, //检测URL中是否有问号 //........... &#125; AJAX.prototype.init.prototype = AJAX.prototype; // window.ajax = AJAX;&#125;)(window);ajax();// 返回的是AJAX原型上init方法的实例，但是init.prototype = AJAX.prototype，所以上面的方法都可以使用 基于PROMISE解决回调地狱问题回调地狱：ajax循环嵌套Promise是ES6中新增加的内置类，目的是为了管理异步操作的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Promise是ES6中新增加的内置类，目的是为了管理异步操作的 * 1，new Promise(); 是创建类的实例，每一个实例都可以管理一个异步操作 * -&gt;必须要传递一个回调函数进去（回调函数中管理你的异步操作） * -&gt;回调函数中有两个参数： * resolve:异步操作成功做的事情(代指成功后的事件队列 -&gt; 成功后要做的所有的事情都存放在这个事件队列中) * reject: 异步操作失败做的事情（代指失败后的事件队列） * -&gt;new Promise的时候立即把回调函数执行了（Promise是同步的） * * 2, 基于Promise.prototype.then方法（还有catch / finally两个方法）向成功或失败队列中一次加入需要处理的事情 * * 3,如果是多个THEN调用，不是像我们想象的依次把增加的方法执行 * 异步操作成功或者失败，先把第一个THEN中的方法执行，每执行一个THEN，会返回一个新的PROMISE实例，这个实例管控的是上一个THEN中的方法执行的成功还是失败的结果 * */ let promise1 = new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: 'temp.xml', dataType: 'JSON', success(result) &#123; resolve(result); &#125;, error(msg) &#123; reject(msg); &#125; &#125;); &#125;); promise1.then( result =&gt; &#123; console.log(\"THEN1 OK\"); &#125;, msg =&gt; &#123; console.log(\"THEN1 NO\"); &#125;) .then( result =&gt; &#123; console.log(\"THEN2 OK\", result); &#125;, msg =&gt; &#123; console.log(\"THEN2 NO\", result); &#125;); // 建议不要使用THEN中的第二个参数（这样很乱），而是建议使用Promise.prototype.catch来管理失败的情况let promise2 = new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: 'temp.xml', dataType: 'JSON', success(result) &#123; resolve(result); &#125;, error(msg) &#123; reject(msg); &#125; &#125;);&#125;);promise1.then( result =&gt; &#123; console.log(\"THEN1 OK\"); &#125;).catch(msg =&gt; &#123; //第一个catch //1,异步请求失败会执行它 //2，第一个THEN方法执行失败也会执行它 console.log(msg); &#125;).then( result =&gt; &#123; console.log(\"THEN2 OK\"); &#125;).catch(msg =&gt; &#123; &#125;).finally(()=&gt;&#123; console.log('aa'); &#125;);// JS中的异常捕获(目的：把抛出的一场错误捕获到，不让其阻断浏览器的执行)try&#123; //正常执行的代码&#125;catch(e)&#123; //TRY中的代码报错了会执行&#125;finally&#123; //不管TRY中的代码执行成功还是失败都会执行&#125; 解决回调地狱的方法12345678910111213141516171819202122232425262728293031let queryA = new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: 'temp.xml', success(result) &#123; &#125; &#125;);&#125;);let queryB = new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: 'temp.xml', success(result) &#123; &#125; &#125;);&#125;)let queryC = new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: 'temp.xml', success(result) &#123; &#125; &#125;);&#125;);let promise1 = queryA();promise1.then(result =&gt; &#123; console.log('A OK'); return queryB();//上一个THEN中函数手动返回一个新的Promise实例（管控了一个异步操作），下一个THEN会等上一个THEN中的异步成功后再执行&#125;).then(result =&gt; &#123; console.log('B ok'); return queryC();&#125;).then(reuslt =&gt; &#123; console.log('c');&#125;); 如果方法中返回一个具体值，而且执行中没有错误异常，会立即执行下一个THEN中的方法（不写RETURN也是返回了具体值，undefined）,但是如果返回的是一个PROMISE实例（并且管控了一个异步操作），只能等PROMISE完成，把成功后的结果当作具体的值返回，才能进入下一个函数执行1234567891011121314151617181920let A = function A() &#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; console.log('1'); resolve(); &#125;,1000); &#125;); &#125; let B = function B() &#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; console.log('2'); resolve(); &#125;,1000); &#125;); &#125; let promise = A(); promise.then(()=&gt;&#123; return B(); &#125;) 补充 visibility:hidden; display:none同样是内容消失不见visibility:hidden，依然占据位置display:none 不会占据位置 new Date() 获取当前客户端的时间，是标准的时间格式数据=&gt;对象new Date(时间字符串) 把指定的时间字符串格式化为标准的当地时间（不再是字符串了）,时间字符串支持很多格式，例如“xxxx-xx-xx xx:xx:xx”原型上的方法只能通过实例调取使用，js禁止直接用 fn.prototype.fn1()来使用，在jquery源码中，选择设置了一个全局变量init=jQuery.prototype.init 来调取使用","categories":[],"tags":[]},{"title":"移动端开发","slug":"移动端开发","date":"2019-11-26T08:23:55.000Z","updated":"2020-06-05T09:17:29.476Z","comments":true,"path":"2019/11/26/移动端开发/","link":"","permalink":"https://abluecup.github.io/2019/11/26/移动端开发/","excerpt":"本篇主要是移动端的相关知识，包括h5标签，css3，响应式布局等","text":"本篇主要是移动端的相关知识，包括h5标签，css3，响应式布局等需要的基础知识： html51、新增加（修改/删除）的语义化标签headerfootermainsection 区域article 文章区域aside 与内容无关的部分（例如广告）nav 导航figure 配图 figcaption 配图说明mark 标记time 时间标记progress 进度条 2，关于表单元素的新改革 [传统表单元素]input:text/password/radio/checkbox/file/hidden/button/submit/reset…selecttextareabuttonformlabel [新增一些表单元素或者表单类型]input:search/email/tel/number/range/color/date/time/url… 表单元素中新增加的类型作用：1，功能强大了，很多东西不需要导入JS插件了，例如日历2，在移动端根据设置的类型不一样，用户输入过程中调取出来的虚拟键盘也不一样（例如number类型调用出来的是数字键盘）3, 新增加的类型提供了css/js验证，可以验证用户输入的内容是否符合格式（之前我们都是用正则自己解决，现在h5中的新类型自带验证机制） h5中给表单元素设置了一个新的属性：placeholder 用来做文本框的默认提示4,音视频标签 audio video =&gt; 让我们告别了flash 5, canvas 图形绘制 6， 提供了一些新的API， 有本地存储: localStorage/sessionStorage 获取地理位置： navigator.geolocation.getCurrentPosition 调取手机内部的GPS定位系统获取当前手机所在地的经纬度以及精确度等 还提供了一些API，让我们可以通过浏览器调取手机内部的软件或者硬件（但是性能都不咋高，而且兼容性也不很好） 7，websocket : socket.io 客户端和服务端新的传输方式（即时通讯IM系统基本上很多是基于它完成的） … 自己扩展：1）使用JS实现一套和placeholder一模一样的效果2）省市县三级联动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;!-- &lt;style&gt; *&#123; margin:0; border:0; padding:0; &#125; body&#123; padding:60px; &#125; #userEmail&#123; border:1px solid #ddd; outline: none;/*当文本框获取焦点后取出浏览器默认的边框选中颜色*/ &#125; #userEmail:valid&#123; /* 不输入或输入格式正确 */ border-color:green; &#125; #userEmail:invalid&#123; /*没通过验证*/ border-color:red; &#125; #userEmail:valid + span::after&#123; content: '邮箱格式正确'; &#125; #userEmail:invalid + span:after&#123; content:'邮箱不符合格式' &#125; &lt;/style&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"email\" id=\"userEmail\" placeholder=\"请输入邮箱\"&gt;&lt;span id=\"spanEmail\"&gt;&lt;/span&gt; &lt;script&gt; userEmail.onblur=function()&#123; // checkValidity:h5新提供的表单内容格式验证方法（新表单类型中有内置验证机制的，都可以基于这个方法验证） // if (this.checkValidity) &#123; // spanEmail.innerHTML='OK'; // &#125;else&#123; // spanEmail.innerHTML='NO'; // &#125; let val = this.value.trim(); if (val.length === 0) &#123; spanEmail.innerHTML = '必填'; return; &#125; let reg = /^\\w+((-\\w+)|(\\.\\w+))*@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/; if (!reg.test(val)) &#123; spanEmail.innerHTML= 'no'; return; &#125; spanEmail.innerHTML = 'ok'; &#125; &lt;/script&gt;&lt;/body&gt; css3学习一些样式属性和选择器就差不多了 常用的选择器#id.classtagselector1,selector2… 群组选择器a b 后代选择a&gt;b 子代a+b 下一个兄弟a~b 兄弟a.b 同级筛选， 标签a中class为b的a[name=’xx’] 属性选择器 name !=’’ name ^= ‘’ name $=’’ name *=’’(包含)a:hover,a:active, a:visited, a:after, a:before, a:nth-child, a:nth-of-type(), a:nth-last-of-type(),a:not,a:first-child, a:last-child 样式属性1,基本常用的border-radiusborder-shadowtext-shadow 2, 背景的background-color/image/position/repeat/attachment/ 新增的background-size: 100px 100px 宽高具体值 100% 100% 百分比，相对于所在的容器 cover 以合适的比例把图片进行缩放（图片不会变形），用来覆盖整个容器 contain 背景图包含在容器中，如果一边碰到容器边缘，另一边则不会覆盖 …background-clip:背景图片裁切 border-box padding-box content-box background-origin 设置背景图片的起始点 border-box padding-box content-box fiter 3 css3动画和变形（2D/3D）transform: 变形 （变形不是动画） translate(x|y|z) 偏移 scale 缩放 rotate 旋转 skew 倾斜 matrix 矩阵（按照自己设定的矩阵公式实现变形） transform-style:preserve-3d 实现3d变形 transform-origin 变形的起点 3.1 过渡动画transition: transition-proprty:all/width…哪些属性样式发生改变执行过渡动画效果，默认是all transition-duration: 过渡动画的时间 transition-timing-function 动画运动的方式 linear(默认) ease ease-in ease-out ease-in-out cubic-bezier(执行自己设定的贝塞尔曲线) transition-delay 设置延迟的时间，默认是03.2 帧动画animation: animation-name 运动轨迹的名称 animation-duration: 运动时长 animation-timing-function 运动方式，默认是ease animation-delay 延迟时间 animation-iteration-count 运动次数 infinite无限次运动 animation-fill-mode 运动完成后的状态（帧动画完成后，元素会默认回到起始位置，如果想让其停留在最后一帧的位置，设置为forwards, 还有其他值如backwards是当前动画如果有延迟时间，在等待时间内，元素处于帧动画的第一帧的位置；both是让帧动画同时具备forwards和backwards） @keyframes [轨迹名]{ 设置运动轨迹 from{ //开始的样式 } to{ //结束的样式 } 用百分比也行 } 4 css3中的新盒子模型 border-sizing:border-box|padding-box|content-box(default) 改变的就是css中设置的width和height到底代表的什么，一般都用border-box columns: 多列布局 flex 弹性盒子模型 5， 一些其他的css3属性perspective:视距，实现3d动画必用的属性@media 媒体查询 实现响应式布局的一种方案@font-face 导入字体图标 三、响应式布局开发在不同尺寸的设备上都能良好的展示 公司中的产品形态： PC端 PC+移动端 用同一套项目 简单的页面，例如产品介绍，公司展示类的官网等 移动端（移动端设备差异较大，需要做响应式布局） 公众号 小程序 嵌入到APP中的H5 微信中分享的H5 靠浏览器访问的H5 RN(React Native)/ionic/cordova… JS开发app的框架，使用JS代码开发APP，最后框架会把代码转化为安卓和IOS需要的代码 如何实现响应式开发 最常用的方案：REM等比例缩放响应式布局 做移动端H5开发，首先加meta标签 `&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;` rem和px一样，都是单位，px是固定单位，rem是相对单位（相对于当前页面的根元素html的字体设定的单位） html{ font-size:14px;/fontSize设置为多少，相当于一个rem相当于多少像素，所以做好设置为100px，之所以设置为100像素，就是为了方便计算rem和px的转换比例/ } 思路：我们开始给html的字体大小设置为100px,接下来我们写样式的时候，把所有的尺寸都用rem计算设定（测量出来的px值除以100就是应该设定的rem值），如果html的font-size不变，用rem和px一样，但是如果字体大小改变，也就是改变了rem和px之间的换算比例，那么之前所有用rem做单位的样式都会自动按照最新的比例进行缩放（实现了改动html的font-size,整个页面中的元素尺寸都跟着缩放了，牵一发而动全身） 真实项目中，设计师会给我们一套设计稿，（常用的尺寸： 640×1136，750*1334, 640*960...）,拿到设计稿后，我们严格按照设计稿中的尺寸去编写样式 html{ font-size:100px } 接下来写样式，把测量出来的px都除以100变为rem,所有的单位基于rem来搞 =&gt;假设设计稿是750的，也就相当于750的设备下，1rem=100px 我们的页面运行在320的设备上，我们需要修改html的字体大小，以实现页面跟着整体样式缩放：320/750 ×100 =&gt;当前设备上html字体的大小 123456789101112在Chrome中页面首次加载的时候有事会出现以上报错：Uncaught（in promise）DOMException：play（）处理方法Open chrome://flags/#autoplay-policySetting No user gesture is requiredRelaunch Chrome————————————————版权声明：本文为CSDN博主「super_XYQ」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/super_XYQ/article/details/83026792 关于audio常用属性duration 播放时间 单位scurrentTime 当前已经播放的时间 单位sended 是否已经播放完成controlsautoplay是否自动播放volume: 控制音量paused 当前是否为暂停状态 方法pause() 暂停play() 播放 事件canplay: 可以正常播放（播放过程中可能出现卡顿）canplaythrough: 资源加载完毕，可以顺畅的播放onended 已经播放完成onloadedmetadata: 资源的基本信息已经加载完成loadeddata 整个资源都已经加载完成onpause 触发了暂停onplay 触发了播放onplaying 正在播放中 移动端使用click会有三百毫秒的延迟 3.1 viewport 视口在PC端，我们开发的html页面运行在浏览器当中，浏览器有多宽（一般代表设备的宽度），html就有多宽，也就是在浏览器宽度的视口中渲染和呈现我们的页面。移动端和PC端是有区别的，不管移动端设备（代指打开的浏览器）的宽度是多少，html页面的宽度是980（或者1024）=》导致的问题：如果在设备窗口中想把整个页面完全呈现出来（小窗口展示大页面），我们只能把大页面进行缩放，HTML页面缩放了，那么页面中所有内容都缩放了【解决方案】 只要让H5页面和手机的设备的宽度保持一致即可，就不会出现手机首先渲染页面的时候把页面缩放的事情了举个例子，页面中有一个宽度为600px的div,如果我们不添加这段代码，div会进行缩放，让整个内容显示在手机中，添加代码后，将不再进行缩放，以此来保证页面的可读性（当内容的宽度 超过 html的宽度时，会出现滚动条）123456789&lt;meta name=\"viewport\" content=\"width=device-width initial-scale=1.0\"&gt;此meta标签就是在设置VP规则 width=device-width: 让html页面的宽度等于设备的宽度 initial-scale=1.0 初始缩放比例1：1（不让页面缩放） user-scaleable=no 禁止用户手动缩放 maximum-scale=1.0 最大缩放比例 minimum-scale=1.0 最小缩放比例 =&gt; 部分安卓机上只设置user-scaleable是不起作用的，需要同这两个一起使用 height 设置页面高度，一般不用 。。。 12345//JS中动态设置VIEW PORTlet metav = document.createElement('meta');metaV.name='viewport';metaV.content='width=device-width, initial-scale=1.0';document.head.appendChild(metaV); LayoutViewport: 布局视口，和开发css等相关visual viewport: 手机视口ideal viewport: 理想视口 HTML的宽度&gt;手机宽度: 页面整体缩放页面内容宽度&gt;html页面的宽度：出现滚动条 真实项目开发中，一般是不允许出现滚动条的，想让他不出现滚动条，就要保证内容的宽度不会超过html页面的宽度移动端开发手机设备宽度不一定，html页面的宽度不一定，所以内容的宽度一般也是不固定的（也就是百分比宽度），移动端开发：外层盒子的宽度一般都是百分比设定的，很少有些固定值的（里面具体的小元素宽度可以固定），这就是流式响应式布局方案 3.2 平时处理的移动端项目 1）PC端和移动端共用一套项目的（结构相对简单的：一般都是展示类的企业站） 设计师一般只会给一套设计稿 A: 先做PC端（设计师给的设计稿一般都是给PC端的） 一般宽度都不是写死的，都是自适应的(具体情况有所不同) B：切换到手机端，使用@media(媒体查询) 把不同设备上不合适的样式进行修改 1234567891011121314151617181920/** 我们可以把@media理解为JS中的条件判断，在不同条件中使用不同的css样式进行渲染 @media [媒体设备] and (媒体条件) and (媒体条件) ...&#123;&#125; all 所有设备 screen 所有屏幕设备 print 打印机设备 。。。 手机上常用的设备尺寸 苹果： 320、 375 、 414 安卓： 320、 360、 480、 540、 640、 （ 760 ...） pad: 768*1024 1024*1366*/ @media screen and (max-width:480px)&#123; //当前页面宽度小于等于480像素 ... &#125; @media screen and(orientation: portrait|landscape)&#123; //portrait 竖屏 //landscape 横屏 &#125; 2）PC端和移动端是分开的两套不同项目 PC端单独做（做它的时候不需要考虑响应式） =&gt;固定布局 移动端单独做（只需要考虑移动端的响应式适配即可） =&gt;响应式布局 a: 依然可以基于@media来做，就是麻烦一些 b: 固定布局(viewport width=320px):按照设计稿把320尺寸的写好即可（所有的尺寸都是固定的，而且都是设计稿的一般【因为设计稿是大一倍的】），在其他的设备上，让320的页面居中展示即可 c: scale等比缩放布局（严格按照设计稿的尺寸来写样式，没有自适应的宽度，都是固定写死的，在其他设备上，首先获取设备的宽度，让其除以设计稿的宽度，然后让原始写好的页面按照这个比例整体缩小即可） 设计师给的移动端设计稿一般都是： 640*1136(980或者不定高度)、750*1334... ？为啥我们的设计稿都比参照手机大一倍： 目的是保证我们切下来的素材资源图片是大图 ？为啥要保证是大图 因为很多手机都是二倍及三倍屏幕密度像素比（DPR）的 scale缩放会导致的问题：比如字体变得模糊 d: rem 等比缩放，它是参考scale，只是用的rem单位来实现的整体缩放（严格按照设计稿的尺寸编写，但是一般宽度都让它自适应，其余的值可以写成固定值 -&gt; 在编写css样式的时候，我们把所有的px单位都换算成rem单位 -&gt; 当加载页面的时候根据当前屏幕的设备的尺寸/设计稿，根据比例动态调整rem和px的换算比例） rem是相对单位，是相对于根元素（html元素）的字体大小设定的单位 12345html&#123; font-size:10px; /*1rem = 10px, 浏览器都有自己默认的最小字体，例如谷歌是12px，所以准确来说，此处这样写相当于1rem=12p*/ font-size:14px;/*换算比例过于麻烦*/ font-size:100px;/*方便换算1rem=100px*/&#125; 1234let HTML=document.getElement,winW = HTML.clientWidth;HTML.style.fontSize = `$&#123;winW/750 *100&#125;px`;//重新调整html字体大小（重新调整rem的转换比例，这样以前所有以rem为单位的样式值都会按照最新的比例重新布局） e: css3中提供了flex-box伸缩盒子模型，基于这个属性，可以让某些效果处理起来更加的方便 A &amp;&amp; D 是目前最常用的最长的响应式布局方案，以rem为主，以@media为辅，以flex为页面中某些部分的开发方式 设计师会给两套设计稿，PC端和移动端 布局宽度：我们在CSS中写的宽度&lt;=&gt;屏幕大小关联的（和屏幕分辨率没有必然关系） iphone4中布局宽度： 1px 1px (盒子大小=&gt;我们看见的大小)，手机渲染的时候是按照2px 2px的分辨率渲染的DPR:屏幕像素密度比2.0(2倍屏幕或者高清屏幕)如果11展示的是图片，手机是按照22大小的图片展示的（但是看到的大小还是11）,如果真实素材图片就是11的大小，图片在渲染的时候就会被拉伸，从而变得模糊，所以我们准备的图片都需要比实际看到的宽高大一倍（3倍屏幕需要大两倍）即使给的是二倍的设计稿，但是部分手机的设备尺寸要大于设计稿的一半，有的手机是三倍DPR，这样就导致一个问题，部分图片还是会变得模糊一些，此时我们找设计师，单独把一张模糊的图片要一张大图即可。 3d动画概念视距perspective 尽量大transform-style: perspective-3d;// 操作的元素设置3d属性围绕着X Y Z 轴顺时针旋转为正 四、微信二次开发（小程序） =&gt; Hybrid混合APP开发 五、移动端事件 六、移动端常用的插件、类库、框架 tips:1,background-size: contain/cover/值在设置背景的大小时，contain表示的意思是图片完全包含在元素内，如果图片的宽度或者高度超过了元素的宽度或者高度，则先超过的一方与元素的值相同，另一方自适应;cover的意思是图片要完全覆盖元素，图片的宽高按比例缩放，直到一方超出，另一方完全覆盖值，值为具体的值时，按具体值的大小计算图片的宽高，为百分比时，按照元素的宽高乘以百分比计算图片的宽高 手指事件对象12345678910111213141516171819202122232425262728293031/* box.ontouchstart = function (ev) &#123; //console.log(ev); //TouchEvent手指事件对象 // changedTouches //touches //手指操作集合，集合中记录了每一个操作的手指的相关信息（包含触发点的坐标位置） //touches记录的信息只有手指在屏幕上才有，也就是手指离开屏幕的时候，信息就消失了， //changedTouches本意上记录的是改变的值，即使手指离开，信息值也在 //按下的时候记录手指的起始位置 let point = ev.changedTouches[0]; this.strX = point.clientX; this.strY = point.clientY; this.isMove = false; &#125; box.ontouchmove = function (ev) &#123; let point = ev.changedTouches[0]; this.changeX = point.clientX - this.strX; this.changeY = point.clientY - this.strY; if (Math.abs(this.changeX) &gt; 10 || Math.abs(this.changeY) &gt; 10) &#123; this.isMove = true; &#125; &#125; box.ontouchend = function (ev) &#123; if (this.isMove) &#123; //滑动 return; &#125; //点击 console.log('我是点击操作'); &#125; */ swiper插件 Hybrid混合APP开发 1，前端做的都是H5页面 WebApp-&gt;运行在浏览器中-&gt;移动端不仅可以运行在浏览器中，还可以运行在AP中（例如：微信、自己公司的APP中） 【优点】及时更新（不需要用户选择，我们只需要把服务器上的源文件更新，用户访问的永远是最新的）跨平台【弊端】不是直接运行在操作系统中的，是运行在浏览器或者APP中的，所以不能直接操作手机上的软硬件运行模式 ：H5通知浏览器或者APP我们想做什么 -&gt; 浏览器调取手机的软硬件 -&gt; 浏览器把信息返回给H5性能没有APP高..2，APP不是H5，它是原生的应用 NativeAPP-&gt; IOS；object-c/swift-&gt; 安卓： java-native 【优势】 用户把安装包下载到手机上进行安装，后期程序是直接运行在手机操作系统当中的 A：性能高 B: 可以调取手机内置的软件或者硬件，例如调取摄像头、重力感应器、通讯录等【前提是需要用户同意】 【弊端】 不能跨平台，一款产品需要两个团队开发两套不同的安装包 A 成本大 B 版本不统一 不能及时更新 苹果商店上传一款APP需要七天审核周期 3，Hybrid混合开发模式把传统的IOS和安卓开发与H5开发结合在一起来做（微信公众号开发：把我们做的H5运行在微信APP中） NativeApp提供一个供H5运行的环境 ‘web view’ （webkit内核） H5和APP的通信 =&gt; jsBridge模式微信APP把所有H5可以调取的方法和功能都注入到WEB VIEW的全局对象中 webView有一个全局对象wx={}, h5运行在webview中，所以在js中可以使用wx.xx()完成方法的调用 4， ReactNative ionic 微信小程序 … 补充：1，SEO 网络运营推广（搜索引擎的优化推广） 目标：尽可能在搜索引擎中提升产品的权重（alex排名） 百度是一个搜索引擎，它养了个宠物“爬虫/蜘蛛”，他会让爬虫有规律得去你的网站进行内容的收录（收集到自己的词库中），当用户在引擎中输入关键词进行查询，引擎会到自己的词库中进行匹配，把匹配到的站点推荐展示 如果我们想做SEO优化，应该尽可能让引擎多收录一些关键词和内容-&gt; 给当前的页面设置meta标签/title123&lt;title&gt;news&lt;/title&gt; &lt;!-- 标题 --&gt; &lt;meta name=\"keywords\" content=\"news\"&gt; &lt;!-- 关键词 --&gt; &lt;meta name='description' content=\"news\"&gt; &lt;!-- 网页描述 --&gt; -&gt; 网页中H1-H6这些标签的权重较高，尤其是h1, 我们尽可能把重要的关键词放到h1中 （语义化标签合理使用） 12&lt;h1&gt;&lt;img src='' alt=''&gt;&lt;/h1&gt;h1中的文字不需要展示给用户，但是我们还会写一些文字，主要是给爬虫看的（样式中让font-size等于0即可） img是不被收录的，但是alt中编写的可以被收录，所以img的alt属性一定要加，最好写一些关键词…… -&gt; 前后端分离项目（数据有客户端JS获取和渲染）是不利于SEO优化的使用JS做数据绑定，页面的源代码中是没有动态绑定的数据的，（但是用户在页面中可以看见内容），而搜索引擎的爬虫就是从源代码中进行抓取收录的（VUE和REACT都是JS做数据绑定的）目前市场上大部分都是前后端分离的项目，也就是JS做数据绑定，由客户端渲染，但是还有一部分项目依然是传统的服务器端数据处理（非完全前后端分离项目） 2， SEM 百度竞价推广（千万不能信） fontCreate 9.1 阿里云字体图标库 3,audio 知识1234567891011121314151617181920212223242526272829&lt;!-- AUDIO:音频标签 1，h5中支持的音乐播放格式 MP3 ogg wav 有的项目中，以上三种都不支持，会继续使用FLASH完成音频的播放&lt;object&gt;&lt;/object&gt; m3u8 直播流 2, 常用属性 controls： 设置这个属性，使用浏览器默认的播放器播放 项目中一般都自己做播放器 autoplay: 自动播放 loop : 播放完成之后是否允许循环播放 preload: 资源预加载模式 none(开始之后什么都不加载，播放的时候才加载)[常用] metadata（加载一些基础信息） auto加载页面开始就加载资源 video里面有一个属性poster,用来设置视频的封面 --&gt;&lt;!-- &lt;audio&gt; &lt;source src=\"xxx.mp3\" type=\"audio/mpeg\"&gt; &lt;source src=\"xxx.ogg\" type=\"audio/mpeg\"&gt; &lt;source src=\"xxx.wav\" type=\"audio/mpeg\"&gt; 当前浏览器版本过低，不支持AUDIO播放&lt;/audio&gt; --&gt;&lt;audio src=\"img/myDream.m4a\" controls autoplay&gt;&lt;/audio&gt; 4，图片的模糊度1filter:blur(2px); 遇到的问题1，less文件引入代码正确，但是 doesn’t workReason: 浏览器使用时是用ajax来拉取less,因此直接在本机文件系统中（file://…开头）或者跨域的情况下会拉取不到less文件Resolve: 安装一个本地web服务器即可，选择有多种，比如appach服务器，nodejs web服务器, vscode本身有模块可以调用，安装打开即可，所以，我自己选择的这个：12345//在全局中安装 npm install -g live-server// 在工作的项目中启动live-server 也可以搜索vscode的扩展资源中搜索liveserver来安装使用，安装好后直接右键文件打开即可 2, 关于padding 和 position的关系盒子A和B，B是A的子元素，A的positiion:relative，B的position:absolute的时候，是相对于A的左上角定位，是盒子的左上角，而不是内容的左上角。比如: A { position:relative; padding:10px; width:40px; height:60px;}我们想让B在A的中间位置，定位就应该是B{ position:absolute; width:10px; height:12px; top:(60+102)/2-12/2=34px; left: (40+102)/2-10/2==25px;} 3, animation: name duration 参数duration必须要加单位s 4, darken(green， 20%) 深绿， lighten(green， 20%)浅绿基于这两个less函数，我们可以给按钮设置按下时的状态 5, 父级元素的高度不定义的时候，它呈现出来的高度是子集元素中relative的元素的高度的累加之和，而不包括他们相对定位的高度egA中有元素B、C、DB{ position:absolute; top:2px; left:3px; width:10px; height:20px;}C{ position:relative; top:3px; left:7px; width:10px; height:7px;}D{ position:relative; top:9px; left:7px; width:20px; height:17px;}A的高度是7+17=24px; 当有padding和margin值的时候，padding会被计算在内，margin值的最上和最下有一特殊情况，就是当A元素没有border，padding等值的时候，最上和最下的margin是不计算在内的。如果有border,padding,则计算在内。· 6, 情景再现：当页面改变尺寸的时候，小于640的时候能获取到html的fontSize,大于640的时候获取不到。 A: 我们在定义Html的fontSize的时候如果写在css文件里，而不是写在行内，则js通过style.fontSize的时候获取不到，只能通过其他方式获得。所以我们在写js计算屏幕宽度来定义根元素的fontSize时，一定要把所有的情况，都加上document.documentElement.style.fontSize=xxx,而不是直接return; 7,String.prototype.replace的运行机制String.prototype.replace(pattern, function(match, $1, …, $n, offset, string){});str1、str2是两个字符串，str1表示被替换的内容，str2表示替换的内容str1也可以使用正则表达式，并把匹配的内容作为参数传递给后面的函数，函数最终要返回一个字符串，当作替换内容，去替换str1 8, filter, find 在javascript和jQuery中的用途是不同的在javascript中， find是返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined filter是返回数组中所有满足条件的元素组成的新数组，否则返回空数组 123456789let arr = [1,2,3,4,5,6,7,8,9];let newArr = arr.filter(function(item,index)&#123; return item &gt; 6;&#125;);console.log(arr,newArr); // [7,8,9]let num = arr.find(item=&gt;&#123; return item &gt; 6;&#125;);console.log(num); //7 在jQuery中， find是找到所有后代中符合条件的DOM元素，返回jQuery对象 find(selector); filter是筛选所有jQ对象中，返回符合条件的jq对象 filter(selector); 9, _.intersection(arr1,arr2)返回一个新的数组，内容是arr1和arr2的交集","categories":[],"tags":[]},{"title":"发布订阅","slug":"发布订阅","date":"2019-11-19T07:23:43.000Z","updated":"2020-04-23T05:06:52.335Z","comments":true,"path":"2019/11/19/发布订阅/","link":"","permalink":"https://abluecup.github.io/2019/11/19/发布订阅/","excerpt":"本篇是对发布订阅设计模式JQ中发布订阅的介绍","text":"本篇是对发布订阅设计模式JQ中发布订阅的介绍 发布订阅设计模式（观察者模式）Publish and subscribe思想：准备一个容器，把到达指定时候要处理的事情事先一一增加到容器中当中（我们把这个叫做发布计划，并且向计划表总订阅方法），当到达指定时间点，通知容器中的方法依次执行即可 jQ中的发布订阅123456789101112let $plan = $.Callbacks();//=&gt;创建一个空的计划表：空容器 =&gt; $plansetTimeout(function()&#123; $plan.fire(10,20); // fire：通知容器中的方法按照顺序依次执行 // 10,20表示执行容器中的方法时，每一个方法都传递给两个参数10和20&#125;, 1000);$plan.add(()=&gt;&#123;//向容器中添加方法&#125;);$plan.remove( fn // 向容器中移除方法 ); 12345678910111213141516171819202122232425262728293031323334353637383940414243~function anonymous(window) &#123; class Subscribe &#123; constructor() &#123; //创建一个容器（每一个实例都有一个自己独有的容器，管理自己需要执行的方法即可） this.pond = [];//给实例挂载一个属性，里面盛放着需要执行的方法 &#125; // 向计划表中增加方法：去重 add(fn) &#123; //fn : 我们需要增加的方法 let pond = this.pond; let isExist = false; pond.forEach(item =&gt; &#123; item === fn ? isExist = true : null; &#125;); !isExist ? pond.push(fn) : null; &#125; remove(fn) &#123; //从计划表中移除方法 let pond = this.pond; pond.forEach((item, index) =&gt; &#123; if (item === fn) &#123; pond.splice(index, 1); &#125; &#125;); &#125; // 通知计划表中的方法依次执行 // 如果传递参数信息了，把这些参数一次赋值给执行的每一个方法 fire(...arg)&#123; let pond = this.pond; pond.forEach((item, index)=&gt;&#123; item(...arg); &#125;); &#125; &#125;; window.Subscribe = Subscribe;&#125;(window);let subscribe = new Subscribe();subscribe.add();subscribe.remove();subscribe.fire();","categories":[],"tags":[]},{"title":"拖拽","slug":"拖拽","date":"2019-10-30T06:04:32.000Z","updated":"2020-06-04T06:46:30.549Z","comments":true,"path":"2019/10/30/拖拽/","link":"","permalink":"https://abluecup.github.io/2019/10/30/拖拽/","excerpt":"本篇收录了拖拽的代码","text":"本篇收录了拖拽的代码12345&lt;section class=\"dragContainer\"&gt; &lt;div class=\"draging\" &gt;&lt;/div&gt; &lt;div class=\"draging\"&gt;&lt;/div&gt;&lt;/section&gt;&lt;script src=\"./js/index.js\"&gt;&lt;/script&gt; 123456789101112131415161718192021222324252627@import 'reset';.dragContainer&#123; position: relative; margin: 60px auto; width: 400px; height: 400px; border: 1px solid gray; .draging&#123; position: absolute; width: 100px; height: 100px; cursor: move; background: orangered; &#125; .draging:nth-of-type(1)&#123; top: 0; left: 0; &#125; .draging:nth-of-type(2)&#123; top:0; right: 0; background-color: orange; z-index: 9; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061let dragRender = (function () &#123; let dragContainer = document.querySelector('.dragContainer'), draging = dragContainer.getElementsByClassName('draging')[0] ; //公共变量 let c = &#123;&#125;; c.left = dragContainer.offsetLeft; c.top = dragContainer.offsetTop; let target = null, p = null, e = null, d = null; //鼠标按下 let readyMove = function startMove(ev) &#123; target = ev.target || ev.srcElement, currentState = target.getAttribute('data-move'); if (!currentState) &#123; return; &#125; //指针的位置 pointer, 相对于容器 p = &#123;&#125;; p.left = ev.pageX - c.left; p.top = ev.pageY - c.top; //元素当前位置 ele 相对于容器 e = &#123;&#125;; e.left = target.offsetLeft; e.top = target.offsetTop; //差值 difference d = &#123;&#125;; d.left = p.left - e.left; d.top = p.top - e.top; // 最大值，最小值 e.maxLeft = dragContainer.clientWidth - target.offsetWidth; e.maxTop = dragContainer.clientHeight - target.offsetHeight; target.setAttribute('data-isReady', true); &#125; // 鼠标移动 let isMoving = function isMoving(ev) &#123; if (!target) &#123; return; &#125; if (target.getAttribute('data-isReady') === 'true') &#123; p.left = ev.pageX - c.left; p.top = ev.pageY - c.top; e.left = p.left - d.left; e.top = p.top - d.top; e.left = e.left &lt; 0 ? 0 : (e.left &gt; e.maxLeft ? e.maxLeft : e.left); e.top = e.top &lt; 0 ? 0 : (e.top &gt; e.maxTop ? e.maxTop : e.top); target.style.top = e.top + 'px'; target.style.left = e.left + 'px'; &#125; &#125; // 鼠标抬起，移动结束， 回归原始状态 let endMove = function endMove() &#123; target.setAttribute('data-isReady', false); target = p = d = e = null; &#125; return &#123; init: function init() &#123; draging.onmouseenter = function () &#123; this.setAttribute('data-move', true); &#125; draging.onmouseleave = function () &#123; this.setAttribute('data-move', false); this.setAttribute('data-isReady', false); &#125; draging.onmousedown = readyMove.bind(draging); draging.onmousemove = isMoving.bind(draging); draging.onmouseup = endMove.bind(draging); &#125; &#125;&#125;)();dragRender.init();","categories":[],"tags":[]},{"title":"事件委托","slug":"事件委托","date":"2019-09-29T06:14:30.000Z","updated":"2020-04-23T05:05:45.336Z","comments":true,"path":"2019/09/29/事件委托/","link":"","permalink":"https://abluecup.github.io/2019/09/29/事件委托/","excerpt":"本篇介绍了事件委托机制，并收录了无限菜单代码。","text":"本篇介绍了事件委托机制，并收录了无限菜单代码。 事件委托也叫事件代理：利用事件的冒泡传播机制，如果一个容器的后代元素当中，很多元素的点击或其他行为都要做一些处理,此时我们不需要一个个获取绑定了，我们只需要给容器的click绑定方法，这样不管点击的是哪一个后代元素，都会把容器的click行为触发，并把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而做不同的事情。 一个个获取元素，然后绑定事件的方式，不仅麻烦，而且性能消耗比较大。当我们给容器绑定事件的时候，不管点击的是后代中的水，绑定的方法都会执行，而且ev事件对象中记录了事件源let target = ev.target || ev.srcElement事件委托这种处理方式，比一个个的事件绑定，性能上提高50%左右，而且需要操作的元素越多，性能提高越大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Event Delegate Navigation&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./css/reset.min.css\"&gt; &lt;style&gt; html body&#123; width: 100%; height: 100%; background:lightseagreen; &#125; .menuBox &#123; margin: 20px auto; width: 700px; height: 500px; border: 1px solid #ddd; &#125; .menuBox .navBox &#123; float: left; width: 200px; &#125; .menuBox .navBox ul li &#123; height: 50px; line-height: 50px; &#125; .menuBox .navBox ul li a &#123; padding: 0 10px; display: block; font-size: 16px; text-decoration: none; background: lightgray; &#125; /* .menuBox .navBox ul li a:hover &#123; background: burlywood; &#125; */ .detailsBox &#123; float: left; background: rgb(218, 242, 243); width: 500px; height: 500px; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"menuBox\"&gt; &lt;nav class=\"navBox\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航6&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航7&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航8&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航9&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;导航10&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=\"detailsBox\"&gt;内容&lt;/div&gt; &lt;/section&gt; &lt;script src=\"../jq/node_modules/jquery/dist/jquery.js\"&gt;&lt;/script&gt; &lt;script&gt; //基于事件委托给最外层盒子的mouseover方法，这样不管操作后代元素中的谁，方法都会执行 let $detailsBox = $('.detailsBox'); $('body').on('mouseover', function (ev) &#123; let target = ev.target, tag = target.tagName, $target = $(target), $pars = $target.parents(); // 如果事件源是navBox下的a或者li,让detailsBox显示 // $target.css('background','orange'); let flag = $pars.filter('.navBox').length &gt; 0 ? true : false; if ((tag==='A' || tag ==='LI') &amp;&amp; flag) &#123; let val = $target.text().match(/\\d+/); $target.css('background','orange'); $detailsBox.show().html(`导航$&#123;val&#125;对应的内容`); return; &#125; //如果事件源是detailsBox或者使它的后代元素，不做处理 // if ($target.hasClass('detailsBox') || $pars.filter('detailsBox').length &gt; 0) &#123; // return; // &#125; $detailsBox.hide(); // $target.css('background','orange'); &#125;); $detailsBox.on('mouseover', function(ev)&#123; ev.stopPropagation(); &#125;); $(\".navBox li a\").on('mouseout', function()&#123; $(this).css('background','lightgray'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 处理情况一个容器中，很多后代元素的点击行为都要处理一些事情，之前的思路是把需要操作的元素一一获取，然后再一一做事件绑定，在不同的方法中完成不同的需求：现在不用了，基于事件的冒泡传播，我们可以只给容器的CLICK事件绑定一个方法，这样不管以后点击的是容器中的哪一个后代元素，都会通过事件的冒泡传播机制，把容器的click行为触发，把绑定的方法执行，我们在方法执行的时候，根据时间对应项中的事件源（ev.target）来做不同的业务处理即可，这种机制即是事件委托机制。 1， 容器中很多后代元素的某个行为要进行操作，委托给容器处理是不错的选择2， 元素是动态绑定的3， 需求是除了某某某，剩下的操作都是做同样的事情（此时把点击行为的操作委托给body,事件源是某某某做什么，不是统一做什么） 无限层级菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"./css/style.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"menuBox\"&gt; &lt;ul class=\"level1\"&gt; &lt;li&gt; &lt;!-- plus: +, minus:- --&gt; &lt;em class=\"plus\"&gt;&lt;/em&gt;&lt;span&gt;产品技术部&lt;/span&gt; &lt;ul class=\"level2\"&gt; &lt;li&gt; &lt;span&gt;产品小组&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;em class=\"plus\"&gt;&lt;/em&gt;&lt;span&gt;UI小组&lt;/span&gt; &lt;ul class=\"level3\"&gt; &lt;li&gt;&lt;span&gt;UI设计师&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;UE体验师&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;em class=\"plus\"&gt;&lt;/em&gt;&lt;span&gt;开发小组&lt;/span&gt; &lt;ul class=\"level3\"&gt; &lt;li&gt;&lt;em class=\"plus\"&gt;&lt;/em&gt;&lt;span&gt;前端开发&lt;/span&gt; &lt;ul class=\"level4\"&gt; &lt;li&gt;&lt;span&gt;PC设备开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;移动设备开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;VR/AI设备开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;native-app开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;node开发&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;后台开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;服务器开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;公共技术研发团队&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;测试小组&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;运维小组&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"level1\"&gt; &lt;li&gt; &lt;!-- plus: +, minus:- --&gt; &lt;em class=\"plus\"&gt;&lt;/em&gt;&lt;span&gt;运维技术部&lt;/span&gt; &lt;ul class=\"level2\"&gt; &lt;li&gt; &lt;span&gt;产品小组&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;em class=\"plus\"&gt;&lt;/em&gt;&lt;span&gt;UI小组&lt;/span&gt; &lt;ul class=\"level3\"&gt; &lt;li&gt;&lt;span&gt;UI设计师&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;UE体验师&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;em class=\"plus\"&gt;&lt;/em&gt;&lt;span&gt;开发小组&lt;/span&gt; &lt;ul class=\"level3\"&gt; &lt;li&gt;&lt;em class=\"plus\"&gt;&lt;/em&gt;&lt;span&gt;前端开发&lt;/span&gt; &lt;ul class=\"level4\"&gt; &lt;li&gt;&lt;span&gt;PC设备开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;移动设备开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;VR/AI设备开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;native-app开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;node开发&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;后台开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;服务器开发&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;公共技术研发团队&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;测试小组&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;运维小组&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;script src=\"../jq/node_modules/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/tabox.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647html,body &#123; height : 100%; padding : 0; margin : 0; border : 0; overflow: hidden;&#125;.menuBox &#123; width : 300px; height : 100%; overflow : auto; background: linear-gradient(to bottom right, lightblue, lightgray)&#125;.menuBox li &#123; position : relative; list-style: none;&#125;.menuBox li span &#123; margin-left: 20px; line-height: 30px; font-size : 14px;&#125;.menuBox li em &#123; position : absolute; left : 0; top : 7px; width : 16px; height : 16px; background: url(../img/icon.png) no-repeat;&#125;.menuBox li em.plus &#123; background-position: -59px -28px;&#125;.menuBox li em.minus &#123; background-position: -42px -29px;&#125;.menuBox ul:not(.level1) &#123; display: none;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940(function($)&#123; let $meunBox = $('.menuBox'); $meunBox.on('click', function(ev)&#123; let target = ev.target, $target = $(target), tarTag = target.tagName; // 合并事件源：点击的是EM，我们让TARGET也等于它的弟弟SPAN，此时TARGET只有SPAN我们才处理，统一基于SPAN位置参照即可 if (tarTag === 'EM') &#123; $target = $target.next(); target = $target[0]; tarTag = target.tagName; &#125; // 只有tarTag是span，我们才会处理 if (tarTag === 'SPAN') &#123; let $ul = $target.next('ul'), $em = $target.prev('em'); //基于jQ获取的结果一般都是jq对象，即使没有获取到元素也是一个length为零的空对象， //而不是null，所以 if($ul)&#123;&#125;,这样算存在不行 if($ul.length === 0) return; // 没有下一级结构什么都不做，有下一级结构控制显示和隐藏 let promise = new Promise(resolve =&gt;&#123; $ul.stop().slideToggle(300, function()&#123; resolve(); &#125;); &#125;); // EM的样式类名如果是plus,说明当前是折叠的，我们应当让其展开，反之，让其折叠起来 if($em.hasClass('plus'))&#123; $em.addClass('minus').removeClass('plus'); &#125;else&#123; $em.addClass('plus').removeClass('minus'); // 外层收起里面的小层级也都收起 promise.then(()=&gt;&#123; $ul.find('ul').css('display','none'); $ul.find('em').removeClass('minus').addClass('plus'); &#125;); &#125; &#125; &#125;);&#125;)(jQuery)","categories":[],"tags":[]},{"title":"图片跟随","slug":"图片跟随","date":"2019-09-29T05:26:45.000Z","updated":"2019-09-29T06:57:30.974Z","comments":true,"path":"2019/09/29/图片跟随/","link":"","permalink":"https://abluecup.github.io/2019/09/29/图片跟随/","excerpt":"本片收录了图片跟随的代码","text":"本片收录了图片跟随的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./css/reset.min.css\"&gt; &lt;link rel=\"stylesheet\" href=\"./css/magnifier.css\"&gt; .container&#123; position: relative; margin:20px auto; width: 462px;&#125;.container .imgBox li&#123; float: left; width: 100px; height: 75px; border:1px solid #eee; margin-right: 18px; cursor: move;&#125;.container .imgBox li:nth-last-child(1)&#123; margin-right: 0;&#125;.container .mark&#123; position: absolute; top: 0; left: 0;&#125;.container .mark img&#123; display:block; width: 300px; height: auto;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt; &lt;!-- 方案一： 每一个li中都有一个大盒子，大盒子中存放的是大图，开始是隐藏的， 鼠标进入到li中，让其显示，并且让他的位置跟随鼠标的位置改变即可 ，鼠标离开Li，让自己的大盒子小时即可（类似于放大镜中small-box中出现mark） 方案二： 只有一个大盒子（可以在JS中动态创建，也可以事先写好，控制显示隐藏），鼠标进入任意一个li, 都让大盒子出来并且大盒子中存放的图片根据当前进入的Li动态改变， 同样实现鼠标移动，大盒子也跟着移动 --&gt; &lt;section class=\"container\"&gt; &lt;ul class=\"imgBox clearfix\"&gt; &lt;li&gt;&lt;img src=\"img/apple_1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/apple_2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/apple_3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/apple_4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 在Js中根据需求动态创建 &lt;div class=\"mark\"&gt;&lt;img src=\"img/apple_1_bigger.jpg\" alt=\"\"&gt;&lt;/div&gt; 如果小图和大图在名字上没有固定的规则，我们把大图地址都已自定义属性的方法存储起来 ，后期需要展示大图的时候，从自定义属性获取即可 有固定的规则，我们完全可以不采用自定义属性的方式，而是基于规则自己处理和匹配即可 &lt;li&gt;&lt;img src=\"img/apple_1.jpg\" data-big=\"img/apple_1_bigger.jpg\" alt=\"\"&gt;&lt;/li&gt; --&gt; &lt;/section&gt; &lt;script src=\"./js/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; (function($)&#123; let $container = $('.container'), $imgList = $(\".container&gt;.imgBox&gt;li\"), $mark = null; $imgList.on('mouseenter', function(ev)&#123; //创建mark，根据经过的Li中的小图片，动态管控mark中的大图片 let $src = $(this).children('img').attr('src'); $src = $src.replace(/_(\\d+)/g,'_$1_bigger'); if (!$mark) &#123; $mark = $(` &lt;div class=\"mark\"&gt;&lt;img src=\"$&#123;$src&#125;\" alt=\"\"&gt;&lt;/div&gt;`); $container.append($mark); &#125; &#125;).on('mouseleave',function(ev)&#123; if ($mark) &#123; $mark.remove(); $mark = null; &#125; &#125;).on('mousemove', function(ev)&#123; // 根据鼠标的位置计算出mark的位置 let &#123;top:conTop, left:conLeft&#125;=$container.offset(), curL = ev.pageX - conLeft + 20, curT = ev.pageY - conTop + 20; $mark.css(&#123; top:curT, left:curL &#125;); &#125;); &#125;)(jQuery); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"放大镜效果","slug":"放大镜效果","date":"2019-09-26T02:26:32.000Z","updated":"2019-09-30T07:15:58.502Z","comments":true,"path":"2019/09/26/放大镜效果/","link":"","permalink":"https://abluecup.github.io/2019/09/26/放大镜效果/","excerpt":"本篇收录了放大镜功能的原理和代码","text":"本篇收录了放大镜功能的原理和代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./css/reset.min.css\"&gt; &lt;link rel=\"stylesheet\" href=\"./css/magnifier.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"magnifierBox\"&gt; &lt;div class=\"smallBox\"&gt; &lt;img src=\"./img/1.jpg\" alt=\"\"&gt; &lt;div class=\"mark\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"bigBox\"&gt;&lt;img src=\"./img/2.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;/section&gt; &lt;section class=\"magnifier-Box\"&gt; &lt;div class=\"smallBox\"&gt; &lt;img src=\"./img/1.jpg\" alt=\"\"&gt; &lt;div class=\"mark\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"bigBox\"&gt;&lt;img src=\"./img/2.jpg\" alt=\"\"&gt;&lt;/div&gt; &lt;/section&gt; &lt;script src=\"./js/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/magnifier.js\"&gt;&lt;/script&gt; &lt;script&gt; var $magniferBox = $('.magnifierBox'), $smallBox = $magniferBox.find('.smallBox'), $mark = $smallBox.find('.mark'), $bigBox = $magniferBox.find('.bigBox'), $bigImg = $bigBox.find('img'); Magnifier($smallBox, $mark, $bigBox, $bigImg, 3); // Magnifier(smallBox, mark, bigBox, bigImg, proportion) var $magniferBox1 = $('.magnifier-Box'), $smallBox1 = $magniferBox1.find('.smallBox'), $mark1 = $smallBox1.find('.mark'), $bigBox1 = $magniferBox1.find('.bigBox'), $bigImg1 = $bigBox1.find('img'); Magnifier($smallBox1, $mark1, $bigBox1, $bigImg1, 3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940.magnifierBox,.magnifier-Box&#123; width: 600px; height: 300px; overflow: hidden; margin:20px auto;&#125;.magnifierBox .smallBox, .magnifierBox .bigBox,.magnifier-Box .smallBox, .magnifier-Box .bigBox&#123; position: relative; float: left; width: 300px; height: 100%; overflow: hidden;&#125;.magnifierBox .smallBox img,.magnifier-Box .smallBox img&#123; display:block; width: 100%; height: 100%;&#125;.magnifierBox .smallBox .mark,.magnifier-Box .smallBox .mark&#123; position: absolute; top: 0px; left: 0px; width: 100px; height: 100px; z-index:10; background-color: #e01d20; opacity: .3; filter: alpha(opacity=30); cursor: move; display: none;&#125;.magnifierBox .bigBox img,.magnifier-Box .bigBox img&#123; display:block; position: absolute; width: 900px; height: 900px; top: 0px; left: 0px; display: none;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 1 鼠标进入和离开 small-box, 控制mark以及bigbox的显示和隐藏 * 2 控制mark在small box中的移动，但是不能超过边界； * 3 当Mark在smallbox中移动的时候，根据MARK移动的距离，计算出BIG-IMG在BIGBOX中移动的距离（反向三倍，x/y轴都是三倍整体9倍） *//* $(function () &#123; var $magniferBox = $('.magnifierBox'), $smallBox = $magniferBox.find('.smallBox'), $mark = $smallBox.find('.mark'), $bigBox = $magniferBox.find('.bigBox'), $bigImg = $bigBox.find('img'); // 鼠标进入和离开 small-box, 控制mark以及bigbox的显示和隐藏 $smallBox.on('mouseenter', function (ev) &#123; $mark.add($bigImg).show(); computedMark(ev);// 刚进入的时候计算mark的位置 &#125;) .on('mouseleave', function () &#123; $mark.add($bigImg).hide(); &#125;) .on('mousemove', function (ev) &#123; //jquery中的EV已经是兼容所有浏览器了（JQ内部处理了），我们只需要按照标准浏览器的属性使用即可 computedMark(ev);// 鼠标在盒子中，随时计算mark的位置 &#125;); console.log($mark); // 鼠标在SMALL-BOX function computedMark(ev) &#123; var offsetObj = $smallBox.offset(), curL = ev.pageX - offsetObj.left - $mark.outerWidth() / 2, curT = ev.pageY - offsetObj.top - $mark.outerHeight() / 2; var minL = 0, minT = 0, maxL = $smallBox.outerWidth() - $mark.outerWidth(), maxT = $smallBox.outerHeight() - $mark.outerHeight(); curL = curL &lt; minL ? minL : (curL &gt; maxL ? maxL : curL); curT = curT &lt; minT ? minT : (curT &gt; maxT ? maxT : curT); $mark.css(&#123; top: curT, left: curL &#125;); $bigImg.css(&#123; top: -3 * curT, left: -3 * curL &#125;); &#125;;&#125;); */~function anonymous() &#123; let utils = (function () &#123; function computedMark(smallBox, mark, bigBox, bigImg, proX,proY,ev) &#123; var offsetObj = smallBox.offset(), curL = ev.pageX - offsetObj.left - mark.outerWidth() / 2, curT = ev.pageY - offsetObj.top - mark.outerHeight() / 2; var minL = 0, minT = 0, maxL = smallBox.outerWidth() - mark.outerWidth(), maxT = smallBox.outerHeight() - mark.outerHeight(); curL = curL &lt; minL ? minL : (curL &gt; maxL ? maxL : curL); curT = curT &lt; minT ? minT : (curT &gt; maxT ? maxT : curT); mark.css(&#123; top: curT, left: curL &#125;); bigImg.css(&#123; top: -proX * curT, left: -proY * curL &#125;); &#125;; return &#123;computedMark:computedMark&#125;; &#125;)(); function Magnifier(smallBox, mark, bigBox, bigImg, proX, proY)&#123; smallBox.on('mouseenter', function(ev)&#123; mark.add(bigImg).show(); utils.computedMark(smallBox, mark, bigBox, bigImg, proX, proY, ev); &#125;).on('mouseleave', function()&#123; mark.add(bigImg).hide(); &#125;).on('mousemove', function(ev)&#123; utils.computedMark(smallBox, mark, bigBox, bigImg, proX, proY, ev); &#125;); &#125; window.Magnifier = Magnifier;&#125;(); 在大盒子嵌套小盒子的操作中，我们不建议使用mouseover的，因为一方面存在冒泡传播机制，另一方面，从大盒子进入到小盒子，它是按照离开大盒子算的","categories":[],"tags":[]},{"title":"事件","slug":"事件","date":"2019-09-20T09:29:58.000Z","updated":"2020-06-02T09:06:45.677Z","comments":true,"path":"2019/09/20/事件/","link":"","permalink":"https://abluecup.github.io/2019/09/20/事件/","excerpt":"事件是一件事情或者一个行为（对于元素来说，它的很多事件都是天生自带的），只要我们去操作这个元素，就会触发这些行为“事件是天生自带的行为，我们操作元素，就会触发相关行为”","text":"事件是一件事情或者一个行为（对于元素来说，它的很多事件都是天生自带的），只要我们去操作这个元素，就会触发这些行为“事件是天生自带的行为，我们操作元素，就会触发相关行为” 什么是事件？事件就是一件事情或者一个行为（对于元素来说，它的很多事件都是天生自带的），只要我们去操作这个元素，就会触发这些行为“事件是天生自带的行为，我们操作元素，就会触发相关行为” 事件绑定给元素天生自带的事件行为绑定方法，当事件触发，会把相应的行为执行。 1, DOM 0级事件绑定： [element].onxxx=function(){}; 2, DOM 2级事件绑定： [element].addEventListener(‘xxx’, function(){}); [element].attachEvent(‘onxxx’,function(){}); [IE6-8] attachEvent只能存在于IE5-10中， addEventListener存在于IE9及以上 目的：给当前元素的某个事件绑定方法（不管是基于DOM0还是DOM2）,都是为了触发元素的相关行为的时候，能做点事情（也就是把绑定的方法执行），不仅把方法执行了，而且浏览器还给方法穿了一个实参信息===&gt; 这个值就是事件对象 元素天生自带的事件常用的元素天生自带的事件【鼠标事件】 click : 点击（PC端是点击，移动端代表单击[移动端使用click会有300毫秒延迟]） dblclick: 双击 mouseover: 鼠标经过 mouseout: 鼠标移出 mouseenter: 鼠标进入 mouseleave: 鼠标离开 mousemove: 鼠标移动 mousedown: 鼠标按下（左右键都起作用，它是按下即触发， click是按下抬起才触发，先触发down和up,然后才触发click） mouseup: 鼠标抬起 mousewheel:鼠标滚轮滚动 【键盘事件】 keydown 键盘按下 keyup 键盘抬起 keypress 和keydown类似，keydown返回的是键盘码，keypress返回的是ASCII码值，一般不用 input:由于PC端有物理键盘，可以监听到键盘的按下和抬起，但是移动端是虚拟的键盘，所以Keydown和keyup在大部分手机上都没有，我们使用input事件统一代替他们 【表单元素事件】 focus:获取焦点 blur: 失去焦点 change: 内容改变 【其他常用事件】 load:加载完成 unload: 页面关闭 beforeunload: 关闭之前 scroll:滚动条滚动事件 resize:大小改变事件 window.onresize=function(){};浏览器窗口大小改变，会触发这个事件 【移动端手指事件】 touchstart: 手指按下 touchmove: 手指移动 touchend: 手指移开 touchcancel: 因为意外事故导致手指操作失误 [gesture] 指的是多手指操作 gesturestart: 多手指按下 gesturechange: 手指改变 gestureend:手指离开 [H5中的audio/video音视频事件] canplay:可以播放（播放过程中可能出现由于资源没有加载完成，导致的卡顿） canplaythrough: 资源加载完成，可以正常无障碍播放 … 事件对象给当前元素的某个事件绑定方法（不管是基于DOM0还是DOM2）,都是为了触发元素的相关行为的时候，能做点事情（也就是把绑定的方法执行），不仅把方法执行了，而且浏览器还给方法穿了一个实参信息===&gt; 这个值就是事件对象；根据操作的不同，事件对象又分为： MouseEvent KeyBoardEvent touchEvent 普通event对象 事件对象中记录了很多属性名和属性值，这些信息中包含了当前操作的基础信息，例如：鼠标点击位置的X/Y坐标，鼠标点击的是谁（事件源）等信息 1 鼠标事件对象的信息 ev.target =&gt; 事件源（操作的是哪个元素） ev.clientX/ ev.clientY =&gt; 当前鼠标触发点距离当前窗口左上角（不是当前元素左上角）的横纵坐标值 ev.pageX/ev.pageY =&gt; 当前鼠标触发点距离body左上角的横纵坐标值 ev.preventDefault(): 阻止默认行为 ev.stopPropagation(): 阻止事件的冒泡传播 ev.type: 当前事件的类型 ‘click’ 2 键盘对象keyBoardEvent ev.code: 当前按键’KeyE’ ev.key: 当前按键 ‘e’ ev.which/ev.keyCode: 当前按键的键盘码 69 兼容问题 1let code = ev.which || ev.keyCode; 2.1 常用键盘码 左-上-右-下： 37-38-39-40 Backspace:8 Enter:13 Space: 32 Delete: 46 Shift: 16 Alt: 18 Ctrl: 17 ESC:27 Tab:9 a-z: 65-90 A-Z: :;;;;;;;;;;;;;;;; F1~F12: 112~123 0-9: 48-57 在IE低版本浏览器中，浏览器执行绑定的方法，并没有把事件对象传递进来，此时ev===undefined,需要基于window.event来获取，由于是全局属性，鼠标每次操作，都会把上一次操作的值替换掉123456789101112131415161718192021if(!ev)&#123; //低版本中没有的属性，我们手动设置一下，按照自己有的先获取到值 //然后赋值给标准对应的新属性（经过判断处理后，低版本中也有TARGET/PAGE-X/PAGE-Y这些属性了） //直接按照高版本的规则来使用即可 ev=window.event; //ev.srcElement; // 获取事件源，标准中使用的是ev.target ev.target = ev.srcElement; //低版本浏览器中的事件对象当中不存在pageX和pageY ev.pageX=event.clientX+(document.documentElement.scrollLeft||document.body.scrollLeft); ev.pageY=ev.clientY+(document.documentElement.scrollTop||document.body.scrollTop); ev.which=ev.keyCode; // preventDefault &amp; stopPropagation 在低版本下也没有 ev.preventDefault = function()&#123; ev.returnValue=false; // 低版本阻止默认行为 &#125; ev.stopPropagation = function()&#123; ev.cancelBubble = true; // 低版本阻止冒泡传播 &#125; &#125; 第二种兼容方法123456box.onclick = function(ev)&#123; ev = ev || window.event; var target = ev.target || ev.srcElement; // ... 用到谁就写谁 ev.preventDefault ? ev.preventDefault():ev.returnValue=false;&#125; 事件的默认行为事件本身就是天生的，某些事件触发，即使你没有绑定方法，也会存在一些效果，这些默认的效果就是事件的默认行为。 1，a标签的点击操作就存在默认行为 1.1 页面跳转 1.2 锚点定位（HASH定位）哈希定位 基于HASH值，我们可以实现SPA单页面应用 2， INPUT标签的默认行为 2.1 输入内容可以呈现到文本当中； 2.2 输入内容的时候会把之前输入的一些信息呈现出来（并不是所有浏览器和所有情况下都有） 3， SUBMIT按钮也存在默认行为 3.1 点击按钮页面会刷新 （在FORM中设置ACTION,点击SUBMIT,会默认按照ACTION指定的地址进行页面面跳转，并把表单中的信息传递过去【非前后端分离项目中，由服务器进行页面渲染，由其他语言实现数据交互，一般都是这么处理】） 。。。 如何阻止默认行为 阻止A标签的默认行为：很多时候我们使用A标签仅仅是想当作一个普通按钮，不想跳转，也不想锚点定位 在结构中阻止1.1 href=&quot;javascript:;&quot; 1.2 href=&quot;javascript:false/void 0/null/undefined..;&quot; 在JS中阻止:给click绑定方法，当我们点击a标签的时候，先触发click事件，其次才会执行自己的默认行为link.onclick=function(ev){ ev = ev || window.ev; return false; // 或者 ev.preventDefault?ev.preventDefault():ev.returnValue = false; } 1234567891011tempInp.onkeydown =function()&#123; let val = this.value.trim(),//trim不兼容 this.value.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/,'') len = val.length; if (len&gt;6) &#123; this.value = val.substr(0,6); &#125;; let code = ev.which || ev.keyCode; if(!/(37|8)/.test(code))&#123; ev.preventDefault? ev.preventDefault():ev.returnValue=false; &#125;&#125; 事件的传播机制冒泡传播： 触发当前元素的某一个事件行为，不仅当前元素行为触发，而且其祖先元素的相关事件行为也会依次被触发，这种机制就是“事件的冒泡传播机制”) 12345document.onclick=function()&#123;&#125;document.documentElement.onclick=function()&#123;&#125;document.body.onclick=function()&#123;&#125;document.outer.onclick=function()&#123;&#125;document.inner.onclick=function()&#123;&#125; xxx.onclick=function(){} DOM0级事件绑定，给元素的事件行为绑定方法，这些方法都是在当前元素的冒泡传播阶段（或者目标阶段）执行的 xxx.addEventListener(‘xxx’,function(){},false) 第三个参数也是控制绑定的方法在事件传播的冒泡阶段（或者目标阶段）执行，只有第三个参数为true才代表让当前方法在事件的传播阶段触发执行（这种捕获阶段执行没啥意义，项目中不用） 不同浏览器对于最外层祖先元素的定义是不一样的谷歌： window-&gt;document-&gt;html-&gt;body..IE高： window-&gt;html-&gt;body…IE低： html-&gt;body.. 关于事件对象的一些理解 事件对象是用来存储当前本次操作的相关信息，和操作有关，和元素无必然关系；2，当我们基于鼠标或者键盘灯操作的时候，浏览器会把本次操作的信息存储起来（标准浏览器存储到默认的内存中【自己找不到】，IE低版本存储到window.event中了），存储的值是一个对象（堆内存），操作肯定会触发元素的某个行为，也就会把绑定的方法执行，此时标准浏览器会把之前存储的对象（准确来说堆内存地址）当作一个实参传递给每一个执行的方法，所以操作一次，即使再多方法中都有EV,但是存储的值都是一个（本次操作信息的对象而已） mouseover mouseout mouseenter mouseleaveenter 和leave 会阻止冒泡传播1，over 属于经过、滑过，覆盖xx,从父元素进入子元素，属于离开了父元素，会触发父元素的out,触发子元素的over enter属于进入，从父元素进入子元素，并不离开父元素，会触发父元素的leave,触发子元素的enter2, enter和leave组织了事件的冒泡传播，而over和out还存在冒泡传播所以对于父元素嵌套子元素这种情况，使用OVER会发生很多不愿意操作的事情，此时我们使用ENTER会更加简单，操作方便，所以真是项目中ENTER的使用比over多 事件池机制事件绑定123456789101112DOM0 box.onclick=function()&#123;&#125; //每一个元素对象都是对应类的实例，浏览器天生为其设置了很多私有属性和公有属性方法，而onclick就是其中的一个私有属性（事件类私有属性，还有很多其他的私有属性，默认值是Null） // dom0事件绑定的原理就是给每一个事件的私有属性赋值（浏览器会建立监听机制，当我们触发元素的某个行为，浏览器会自己把属性中的赋值去执行） //dom0事件绑定只允许给某个时间行为绑定一个方法，多次绑定，后面绑定的内容会替换前面绑定的，一最后一次绑定的方法为主DOM2 box.addEventListener('click', function()&#123;&#125;,false); removeEventListener //使用的方法都是EventTarget.prototype上定义的 //在IE低版本浏览器中使用的是attachEvent来处理：box.attachEvent('onclick', function()&#123;&#125;);移除使用的是dettachEvent //dom2事件绑定可以给当前元素的某一个事件绑定多个不同的方法，//DOM1并没有对事件绑定做升级改版 事件池 DOM2事件绑定的兼容性问题[谷歌 vs IE高版本]在移除事件绑定的时候，如果移除操作发生在正要执行的方法之前（例如：点击的时候，正要执行FN8,但是在执行FN4的时候，我们把FN8从事件池中移除了），谷歌下是立即生效，第一次也不再执行FN8了，而IE是当前本次不生效，下一次点击才生效，第一次点击还是要执行FN8 [谷歌 vs IE低版本] 标准： addEventListener(‘click’,fn) / removeEventListener IE: attachEvent(‘onclick’, fn) / detachEvent 1，this问题 标准下，方法执行，方法中的this是当前元素本身，Ie低版本中this指向了window2, 重复问题 标准浏览器中的事件池是默认去重的，同一个元素的同一个事件行为不能出现相同的绑定方法，但是IE低版本的事件池机制没有这么完善，不能默认去重，也就是可以给同个元素的同个事件绑定相同的方法3，顺序问题 标准浏览器是按照向事件池中存放的顺序依次执行的，而IE低版本是乱序执行的，没有规律 IE低版本浏览器出现的所有问题都是由于本身自带的事件池机制不完整导致的 IE低版本浏览器跟标准浏览器的区别：事件对象DOM2事件绑定事件传播的路径不一样 DOM0和DOM2事件绑定的区别1）机制不一样DOM0是给事件的私有属性赋值，所以只能绑定一个方法；DOM2采用的是事件池机制，所以可以绑定多个不同的方法2）移除的操作box.onclick = null;重新赋值即可移除绑定方法DOM2移除的时候，必须清楚要移除哪一个方法，才能呢个在事件池当中移除掉。所以基于DOM2做事件绑定，我们要有瞻前顾后的思路，也就是绑定的时候考虑如何移除（技巧：不要绑定匿名函数，都绑定实名函数）3）DOM2事件绑定增加了一些DOM0无法操作的事件行为，例如：DOMContentLoaded事件（当页面中的HTML结构加载完成就会触发执行）1234567891011121314let fn=function()&#123; //...&#125;box.addEventListener('DOMContentLoaded',fn);window.onload = function()&#123;&#125;;//当页面中的资源都加载完成（包含HTML结构加载完，CSS和JS等资源加载完成等），才会触发window.addEventListener('load', function()&#123;&#125;);// 这样也可以执行多次$(function()&#123;//当页面中的HTML结构加载完成就会执行&#125;); // 就是 $(document).ready(function()&#123;&#125;);的简写 原理基于DOMContentLoaded完成的// 在document.readyState === 'complete'时候执行函数//基于DOM2事件绑定的，所以在同一个页面总可以执行多次（绑定多个不同的方法），当结构加载完成，会依次执行方法 DOM0和DOM2两套机制可以共存，执行顺序和编写顺序有关 JQ中的事件绑定方法JQ中的事件绑定方法有很多，最常用的是on / off 添加 / 移除one : 只绑定一次，第一次执行完成后，就移除掉该方法click / mouseover / mouseout / …这些方法最后都是基于 on / off 完成的，one也是基于 on / off 完成的delegate: 事件委托方法，在1.7版本以前用的是live方法基于DOM2事件绑定实现事件的绑定和移除（兼容了所有的浏览器）1234$('#box').on();$(document).delegate('#box','click',fn);// 在document上绑定fn点击行为，并把它委托给#box,通常#box是一个未来元素","categories":[],"tags":[]},{"title":"选项卡封装","slug":"常用代码段","date":"2019-09-06T06:10:06.000Z","updated":"2020-04-28T05:33:37.895Z","comments":true,"path":"2019/09/06/常用代码段/","link":"","permalink":"https://abluecup.github.io/2019/09/06/常用代码段/","excerpt":"本篇收录了一些练习题：","text":"本篇收录了一些练习题： ## 选项卡封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//=&gt; 参数初始化（初始化配置项），设置参数的默认值// 挂载：把每一项当作实例的私有属性设置一下即可，我们通常说是把属性挂载到实例上//获取需要挂载的元素，把获取的元素也挂载到实例上// this.container = container;~function anonymous() &#123; let hasClass = (ele, str) =&gt; ele.className.trim().split(/ +/).indexOf(str) &gt;= 0; let addClass = (ele, str) =&gt; &#123; !hasClass(ele, str) &amp;&amp; (ele.className += ` $&#123;str&#125;`); &#125;; let removeClass = (ele, str) =&gt; &#123; hasClass(ele, str) &amp;&amp; (ele.className = ele.className.trim().split(/ +/).filter(item =&gt; item !== str).join(' ')); &#125; class Tabox &#123; constructor(container, options) &#123; let _default = &#123; lastIndex: 0, eventType: 'mouseover', customPageClass: 'options', customContentClass: 'con', changeEnd: null &#125;; // 把参数挂载到实例上 for (let attr in options) &#123; if (options.hasOwnProperty(attr)) &#123; _default[attr] = options[attr]; &#125;; &#125;; for (let attr in _default) &#123; if (_default.hasOwnProperty(attr)) &#123; this[attr] = _default[attr]; &#125; &#125;; //获取操作元素，把需要操作的元素也挂载在实例上 this.container = document.getElementById(container); console.log(this.container.children); this._childNodes = [].slice.call(this.container.children); this.option =this. _childNodes.find(item =&gt; hasClass(item, this.customPageClass)); this.tabList = [].slice.call(this.option.children); this.conList = this._childNodes.filter(item =&gt; hasClass(item, this.customContentClass)); // 执行方法 this.changeTab(); &#125;; // 写在class里面的都是实例上的方法 changeTab() &#123; let _this = this; this.tabList.forEach((item, index) =&gt; &#123; item[`on$&#123;this.eventType&#125;`] = function () &#123; if (index === _this.lastIndex) &#123; return; &#125;; addClass(this, 'active'); removeClass(_this.tabList[_this.lastIndex], 'active'); addClass(_this.conList[index], 'active'); removeClass(_this.conList[_this.lastIndex], 'active'); _this.lastIndex = index; &#125; &#125;); &#125; &#125;; window.Tabox = Tabox;&#125;(); rest运算符题目来自freecodecamp1.使用解构赋值以及rest操作符来进行一个Array.prototype.slice相同的操作。使得arr是原数组source除开前两个元素的子数组。12345678910111213const source = [1,2,3,4,5,6,7,8,9,10];function removeFirstTwo(list) &#123; \"use strict\"; // 在这行以下修改代码 const [,,...arr]=list; // change this // 在这行以上修改代码 return arr;&#125;const arr = removeFirstTwo(source);console.log(arr); // 应该为 [3,4,5,6,7,8,9,10]console.log(source); // 应该为 [1,2,3,4,5,6,7,8,9,10]; 2.对half的参数进行解构赋值，使得仅仅将max与min的值传进函数。123456789101112131415161718192021const stats = &#123; max: 56.78, standard_deviation: 4.34, median: 34.54, mode: 23.87, min: -0.75, average: 35.85&#125;;const half = (function() &#123; \"use strict\"; // 不要改变这行 // 在这行以下修改代码 return function half(&#123;max,min&#125;) &#123; // 请在函数参数中使用解构赋值 return (max + min) / 2.0; &#125;; // 在这行以上修改代码&#125;)();console.log(stats); // 应该为 objectconsole.log(half(stats)); // 应该为 28.015 css3属性box-shadow: 1.写一个一圈都是阴影的box-shadow: 0 0 0 4px gray;2.画个月亮12345678div&#123; position: relative; width: 100px; height: 100px; background:transparent; border-radius: 50%; box-shadow: 20px 10px 0 0 yellow; &#125; background: linear-gradient(gradient_direction, 颜色 1, 颜色 2, 颜色 3, …); 3.background-size，linear-gradient配合写出条形滚动条纹1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;style&gt; #progress &#123; position: relative; width: 400px; height: 40px; border: 1px solid gray; &#125; #cur &#123; box-sizing: border-box; position: absolute; top: 0; left: 0; width: 0; height: 100%; background: linear-gradient(to top right, #FF007D 0, #FF007D 25%, #00FFD7 25%, #00FFD7 50%,#FF007D 50%, #FF007D 75%,#00FFD7 75%, #00FFD7 100%) ;/*这种分法让背景图重复的时候看起来是连贯的，有助于图片动画时的连续性*/ transition: all 1s linear; background-size: 40px 40px; /*背景图的大小是一个正方形*/ /* background-repeat: no-repeat; 默认值是repeat,所以当上一个背景图上移的时候，下面的背景就会上来，以覆盖全部的元素大小，同理，当长度变长的时候，也会出现新的重复的背景图*/ animation: loadingMove 2s linear 0s infinite both ; &#125; @keyframes loadingMove &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: 0 -40px;/*移动一个完整的图片距离*/ &#125; &#125; &lt;/style&gt;&lt;div id=&quot;progress&quot;&gt; &lt;div id=&quot;cur&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;let autoTimer = setInterval(function () &#123; let curW = cur.offsetWidth; curW += 80; if (curW &gt; 400) &#123; clearInterval(autoTimer); curW = 400; &#125; cur.style.width = curW + &apos;px&apos;; &#125;, 1000); &lt;/script&gt; background-clip 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。border-box|padding-box|content-box|text 4.画个心1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;.heart &#123; position: absolute; margin: auto; top: 0; right: 0; bottom: 0; left: 0; background-color: pink; height: 50px; width: 50px; transform: rotate(-45deg);&#125;.heart:after &#123; background-color: pink; content: &quot;&quot;; border-radius: 50%; position: absolute; width: 50px; height: 50px; top: 0px; left: 25px;&#125;.heart:before &#123; content: &apos;&apos;; background-color: pink; border-radius: 50%; position: absolute; width: 50px; height: 50px; top: -25px; left: 0px;&#125;&lt;/style&gt;&lt;div class = &quot;heart&quot;&gt;&lt;/div&gt;","categories":[],"tags":[]},{"title":"同步、异步编程","slug":"同步、异步编程","date":"2019-07-26T06:29:02.000Z","updated":"2020-05-28T05:04:48.070Z","comments":true,"path":"2019/07/26/同步、异步编程/","link":"","permalink":"https://abluecup.github.io/2019/07/26/同步、异步编程/","excerpt":"本篇是对JS同步、异步编程的介绍，以及定时器原理的解析：","text":"本篇是对JS同步、异步编程的介绍，以及定时器原理的解析： 定时器定时器；设定一个定时器，并且设定了等待的时间，当到达设定的时间时，浏览器会执行对应的方法 【常用的定时器】setTimeout([function],[interval])setInterval([function],[interval])[function],到达时间后执行的方法（设定时方法没有执行，到时间浏览器会帮我们执行）[interval],时间因子（需要等待的时间），单位：毫秒 setTimeout是执行一次定时器，setInterval是可以多次执行的(轮循定时器) 清除定时器：clearTimeout([序号]) / clearInterval([序号]) 这两种方法中的任何一个都可以清除用任何方法创建的定时器 设置定时器会有一个返回值，这个值是一个数字，属于定时器的编号，代表当前是第几个定时器（不管是基于setTimeout还是setInterval创建定时器，这个编号会累加） Js中的同步编程和异步编程1，同步编程：任务是按照顺序依次处理，当前这件事没有彻底做完，下一件事是执行不了的；2，异步编程：当前这件事没有彻底做完，需要等待一段时间才能继续处理，此时我们不等，继续执行下面的任务，当下面的任务完成后，再去把没有彻底完成的事彻底完成 JS中的异步编程：1，所有的事件绑定都是异步编程； 2，所有的定时器都是异步编程； 3，ajax中一般都使用异步编程处理； 4，回调函数也算是异步编程 123456789let n=0;setTimeout(()=&gt;&#123; console.log(++n);&#125;)console.log(n);while(true)&#123;&#125;//定时器设定一个时间，到时间后也不一定执行，如果当前还有其他的同步任务正在处理，那么到时间了也等着； 浏览器是如何规划同步异步机制的1，浏览器是多进程的，JS是单线程的（浏览器只给JS执行分配一个线程）每一个应用程序都可以理解为一个进程，浏览器打开一个页面，就相当于开辟一个进程，在一个程序中（进程中），我们经常会同时做很多事情，此时我们可以分配多个线程去同时完成多项任务2, js在单线程当中实现异步的机制，主要依赖于浏览器的任务队列完成的，浏览器中有两个任务队列，（主任务队列和等待任务队列） 2.1 在主任务队列自上而下执行的时候，如果遇到一个异步操作任务，没有立即执行，而是把它放到等待任务队列中排队 2.2 当主无人队列完成后才会到等待任务队列中进行查找（主任务队列完不成，不管等待任务队列中是否有到达时间的，都不处理，继续等待主任务队列完成，因为js是单线程的，一次只能处理一件事情）3， 等待任务队列当中，谁达到条件了（如果有很多都达到条件了，谁先达到的，就先处理谁），就把这个任务重新放到主任务队列当中去执行，把这个任务执行完，再去等待队列中找……123456789101112131415setTimeout(()=&gt;&#123; console.log(1);&#125;,20)console.log(2);setTimeout(()=&gt;&#123; console.log(3);&#125;,10); setTimeout(()=&gt;&#123; console.log(4);&#125;,100);console.time('aa');for (let i = 0; i &lt; 90000000; i++) &#123; &#125;console.timeEnd('aa'); 初始PromisePromise：它是ES6中新增加的类 （new Promise）,目的是为了管理JS中的异步编程的，所以我们也把它称为Promise设计模式1234567891011121314151617// 三个状态：pending(准备状态：（初始化成功）开始执行异步任务)/fulfilled(成功)/rejected(失败)new Promise((resolve, rejected)=&gt;&#123; //resolve, 当异步操作执行成功，我们执行resolve方法 //rejected, 当异步操作执行失败，执行rejected方法 //执行一个异步的任务, new Promise的时候，创建Promise的一个实例，立即会把当前函数体中的异步操作执行 //Promise本身是同步编程，它可以管理异步操作 setTimeout(()=&gt;&#123; resolve(100); &#125;,1000);&#125;).then( // 第一个传进来的函数是resolve,第二个是rejected (res)=&gt;&#123; console.log(\"ok\",res);&#125;,()=&gt;&#123; console.log(\"no\");&#125;); 123456789101112131415161718192021222324let pro = new Promise((resolve, rejected) =&gt; &#123; let xhr = new XMLHttpRequest(); xhr.open('get', 'js/1.js', false); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; val = xhr.responseText; resolve(val); &#125;; if(xhr.readyState !== 200)&#123; rejected(val); &#125; &#125; xhr.send(null); &#125;); pro.then((res)=&gt;&#123; // 数据绑定…… &#125;,(res)=&gt;&#123; console.log(\"no\"); &#125;).then(()=&gt;&#123; // 当一个then中的函数执行完成，会执行第二个，依次类推 &#125;).then(()=&gt;&#123; // 第二个执行完成，就会执行第三个 &#125;); //所有的设计模式都是一种编程思想，便于管理代码，管理业务逻辑 动画实现方式： 1. css3动画 (transition（过度动画）/animation（真动画） transform是变形，不是动画) 经常依托某一种动画让元素在一定时间内实现变形效果 （能用css3解决的，不用js，因为css3的动画性能高） 2. js动画 定时器 requestAnimationFrame(js中的帧动画) canvas动画就是js基于定时器完成的（canvas是一个html标签，可以理解为是一个画布，我们可以基于JS在画布上绘制图像和效果） 3.flash动画 简单动画回调函数把一个函数A当作实参传递给另外一个函数B，在B方法中执行的时候，把A执行了，我们把这种机制叫做“回调函数机制” 1, 根据需求回调函数可以被执行N多次； 2，不仅可以把回调函数执行，还可以给传递的回调函数传递实参，这样在回调函数中设置形参（或者arg）接收即可； 3，还可以改变回调函数中的this指向 4, 可以在宿主函数（它在哪执行的，它的宿主函数就是谁）中接收回掉函数执行的返回结果123456let fn=(callback)=&gt;&#123; callback &amp;&amp; cackback();&#125;;fn(()=&gt;&#123; this:window 回调函数中一般this都是window,除非宿主函数执行回调函数的时候把this特殊指向了（箭头函数除外，箭头函数中的this是它上下文的）&#125;); jquery中的动画和动画库123456789101112131415161718192021222324/* let $box=$(\"#box\");console.log($box);// stop()结束正在运行的动画，继续执行下一个新的动画，在哪停的就从哪开始// finish()同stop一样，也是结束正在执行的动画(结束动画后，让元素立即运动到目标位置，从上一个动画的目标位置作为下一个动画的起始位置)$box.stop().animate(&#123; top:300, left:500&#125;,2000,'linear',()=&gt;&#123; $box.css(&#123; 'border-radius':'50%', 'background-color':'red' &#125;);&#125;); */// 快捷动画//1，show,hide,toggle//2,fadeIn|fadeOut|fadeToggle//3, slideDown|slideUp|slideToggle//可以制定具体的运动时间，也可以指定'slow','fast'$('#box').slideUp('slow'); 轮播图1，container是轮播图容器，溢出的内容需要隐藏2，wrapper存放所有图片（所有图片同行排列），wrapper相对于container定位，后期让来轮播图切换其实就是改变wrapper的left值","categories":[],"tags":[]},{"title":"快捷键","slug":"快捷键","date":"2019-06-13T01:55:51.000Z","updated":"2019-07-04T09:28:38.699Z","comments":true,"path":"2019/06/13/快捷键/","link":"","permalink":"https://abluecup.github.io/2019/06/13/快捷键/","excerpt":"文件主要记录了常用的快捷键","text":"文件主要记录了常用的快捷键 vscode 中的快捷键 插入注释ctrl + alt + i 在文件头部添加注释ctrl + alt + t 在光标处添加注释 打开控制台ctrl + ` JS多行注释alt + shift + A 代码格式化alt + shift + F","categories":[],"tags":[]},{"title":"面试题","slug":"面试题","date":"2019-06-12T07:54:28.000Z","updated":"2019-07-15T01:00:02.343Z","comments":true,"path":"2019/06/12/面试题/","link":"","permalink":"https://abluecup.github.io/2019/06/12/面试题/","excerpt":"本篇是对前面课程的总结归纳","text":"本篇是对前面课程的总结归纳 1. ES6相比ES5有哪些新语法 let/const 和ES5有哪些区别1) let不存在变量提升机制（变量不允许在声明之前使用）2) 不允许重复声明3) 在全局作用域中声明的变量不是window的一个属性，和他没有关系4) typeof 未被声明的变量 =&gt;不是undefined而是报错（暂时性死区）5) let会形成私有作用域（类似于私有作用域，大部分大括号都会形成块级作用域） 解构赋值 “…” 拓展、剩余、展开运算符 箭头函数 和普通函数的区别1) 没有arguments,但是可以基于…arg获取实参集合（结果是一个数组）2) 没有自己的this,箭头函数中的this是上下文中的this 模板字符串 Promise(async/await) Class(ES6中创建类的) interator(for of 循环) Map / set … 2.请说出你对“重排（回流）、 重绘、 读写分离”的理解 思路： 1.首先说出什么是重排和重绘2.突出他们耗性能3.突出自己写项目的时候重点注意了这些事情，以及自己的解决方案（说一下解决原理） 浏览器渲染一个页面的时候是按照“先创建DOM树，再加载CSS，生成渲染树RENDER TREE, 把渲染树交给浏览器（GPU）进行绘制”，如果后期我们修改了元素的样式（但是没有改变大小和位置），浏览器会把当前元素重新生成渲染树，然后重新渲染，这个机制是重绘，但是一旦元素的大小或者位置发生改变，浏览器就要从DOM树重新计算渲染，这个机制是重排（回流）。无论是重排还是重绘都非常的消耗性能。在我以前的项目中，我特意的重视了这个问题，尽量减少DOM操作引发的回流和重绘问题，常用的解决方案：1，需要动态向页面追加元素的时候，基于文档碎片或者先把需要增加的所有元素拼接成字符串，最后统一进行增加2，读写分离： 把统一修改样式都放到一起执行，新版浏览器都有一个自己检测的机制，如果发现下面紧挨着的操作也是修改元素的样式，会把所有修改的事先存起来，知道遇到非修改样式的操作，会把之前存储的统一执行，引发一次回流和重绘 当让还有一些其他的办法，这些是最常注意的，我认为减少DOM回流重绘是非常重要的性能优化手段之一 3.js中的this总结this : 当前方法的执行主体（谁执行的方法，this就是谁，this和当前方法在哪创建的或者在哪执行的都没有必然关系）1.给当前元素的某个元素绑定事件，方法中的this都是当前操作的元素本身；2.函数执行，看函数前面是否有点，有的话，点前面是谁，this就是谁，没有点，this是window(严格模式下，没有点this是undefined)3.构造函数执行，方法中的this一般都是当前类的实例4.箭头函数中没有自己的this,this是上下文中的this12345678let obj=&#123; fn:function()&#123; //this: obj setTimeout(()=&gt;&#123; //this:obj &#125;,1000); &#125; &#125; 5.在小括号表达式当中，会影响this的指向1234567var obj=&#123; fn:function()&#123; console.log(this); &#125;&#125;obj.fn(); // obj(12, obj.fn)(); // window 以最后一项为主，但是函数指向window 6.使用call/apply/bind可以改变this的指向fn.call(obj); 第一个参数不写或者写none,undefined,this指向window;严格模式下，指向undefined 谈一下你对作用域链和原型链的理解1.作用域链：函数执行会形成一个私有的作用域，形参和在当前私有作用域中声明的变量都是私有变量，当前的私有作用域有自我保护机制，私有变量和外界是没有关系的，但是如果私有作用域中遇到一个非私有变量，则向它的上级作用域查找，如果上级作用域还没有，则继续查找，一直找到window为止，这种变量一层层向上查找的机制就是“作用域链机制“2.原型链：也是一种查找机制，实例首先在自己的私有属性中进行查找，如果不是私有属性，基于proto向所属类的原型上查找，如果再找不到，则继续基于proto向上查找，一直找到Object.prototype为止obj.hasOwnProperty(),这里调取的hasOwnProperty这个属性就是找到Object.prototype上才找到 数组去重12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//数组去重不改变原有数组let ary = [1, 2, 3, 2, 3, 4, 5];Array.prototype.myUniqueAry = function () &#123; // this:我们需要操作的数组，如果不想改变原有的数组，我们需要把要操作的数组克隆一份出来，处理的都是克隆的数组； let _this = [...this], obj = &#123;&#125;; for (let i = 0; i &lt; _this.length; i++) &#123; let item = _this[i]; if (typeof obj[item] !== 'undefined') &#123; // 当前对象在数组中已经存在，需要删除 _this[i] = _this[_this.length - 1]; _this.length--; i--; &#125; else &#123; obj[item] = item; &#125; &#125; obj=null; return _this;&#125; let uniqueAry = ary.myUniqueAry();console.log(uniqueAry);Array.prototype.myDelete=function()&#123; // 这种情况只能用于不改变原有数组，如果需要改变原有数组的话， let _this=[]; for (let i = 0; i &lt; this.length; i++) &#123; if (_this.indexOf(this[i])===-1) &#123; _this[_this.length]=this[i]; &#125; &#125; return _this; &#125;let aa = ary.myDelete();console.log(aa,ary); Array.prototype.myDelete=function()&#123; let _this=[]; for (let i = 0; i &lt; this.length; i++) &#123; if (_this.indexOf(this[i])===-1) &#123; _this[_this.length]=this[i]; &#125; &#125; // 修改原有数组 this.length=0; for (let i = 0; i &lt; _this.length; i++) &#123; this[this.length]=_this[i]; &#125; return this; &#125; 说出你所掌握的算法1.递归算法12345678910111213141516171819202122232425262728293031/** * 常用算法 * 递归 * 去重 * 冒泡排序 * 插入排序 * 快速排序 * 时间复杂度 * 空间复杂度 * KMP * ... */// 递归：函数自己调用自己执行就是递归// (递归是基于条件判断的，因为我们不能形成死递归，在某个条件下，我们需要结束递归操作)// 数组扁平化 let ary = [1, [2, [3, [4, 5]]], 6]; let result = [], fn = function (ary) &#123; for (let i = 0; i &lt; ary.length; i++) &#123; let item = ary[i]; if (Object.prototype.toString.call(item) === &apos;[object Array]&apos;) &#123; fn(item); &#125; else &#123; result.push(item); &#125; &#125; &#125; fn(ary); console.log(result); 写出你掌握的JS继承方式，项目中什么时候你用到了继承面向对象：类的继承、封装、多态 封装：把实现一个功能JS代码进行封装，主要目的：“低耦合、高内聚”； 多态 2.1 重载：方法名相同，参数的个数或者类型不同，此时名字相同的方法叫做方法的重载（后台语言中的重载），JS中不存在重载的 （后面的方法会把前面的方法覆盖掉，不管传递多少实参，传递的都是后面的方法） （有人说JS中的重载是指，同一个方法根据传参的不一样，实现不同的功能，但是有点扯）服务器端的重载是为了减轻服务器端的压力，客户端不需要抗压 2.2 重写：子类重写父类 继承 子类继承父类的属性和方法 3.1 原型继承 3.2 call继承 3.3 寄生组合寄生 3.4 ES6中class类实现继承 。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function A()&#123; this.x=100;&#125;;A.prototype=&#123; constructor:A, getX:function()&#123; console.log(this.x); &#125;&#125;;function B()&#123; this.y=200;&#125;;let f=new B();// 原型继承: 让子类的原型指向父类的一个实例B.prototype=new A();/** * 1, b.prototype = new A(); A的实例本身具备父类A的私有属性和公有方法，子类B的原型指向它，那么子类B的实例就可以找到这些属性和方法了 * 2, 和传统后台语言的继承不一样，子类继承父类，并不是把父类复制一份副本给子类（这样处理，子类和父类就没有直接关系了），JS中的原型继承是让子类和父类建立原型链的机制，子类的实例调取父类的属性和方法都是基于原型链来完成的。 * 存在的问题：子类可以重写父类原型上的方法（重写），子类和父类还有关系的。 * 父类实例私有的属性和公有属性都变为子类实例的公有属性 * 如果子类B的原型上之前有属性方法，重新执行A的实例后，之前的方法都没用了 */ // call继承：把父类A作为普通函数执行，让A中的this变为B的实例，相当于给B的实例增加了一些属性和方法 function B()&#123; A.call(this); this.y=200; &#125; //弊端：把父类A当作普通函数执行，和原型没有关系了，仅仅是把A中的私有属性变为子类B实例的私有属性，A原型上的公有属性和方法跟B没有关系 //寄生组合式继承 A的私有变为B的私有，A的公有变为B的公有 function A()&#123; this.x=100;&#125;;A.prototype=&#123; constructor:A, getX:function()&#123; console.log(this.x); &#125;&#125;;function B()&#123; A.call(this); // 基于call继承把A的私有变为B的私有 this.y=200;&#125;;// B.prototype=A.prototype 一般不这么处理，会让修改父类A原型上的东西更方便，这样会导致A的其他实例也受到影响B.prototype=Object.create(A.prototype); // B.prototype = &#123;&#125; (obj._proto_ = A.prototype)let f=new B();// Object.create(); 内置Object类天生自带的方法// 1.创建一个空对象// 2.让新创建的空对象的_proto_指向第一个传递进来的对象（把obj作为新创建空对象的原型）let obj=&#123; name:'haha'&#125;Object.create(obj);// 这种方式和原型继承的区别： B.prototype = new A() 创建A的实例指向A的原型，但是实例中不是空的，存放了A的私有属性，这些属性变为B的公有属性// B.prototype=Object.create(A.prototype)的好处是创建了一个没有任何私有属性的空对象，指向A的原型，这样B的公有中就不会存在A的私有属性了。 12345678910111213141516171819202122232425262728293031323334353637383940414243//ES6中的类和继承/** * ES6中创建类是有自己标准语法的 * 这种语法创建出来的类只能new执行，不能当作普通函数执行 */class Fn &#123; //Fn是类名，没有小括号 constructor(n, m) &#123; //等价于传统ES5类的构造体 this.x = n; this.y = m; &#125; getX()&#123; // 相当于给Fn的原型上设置方法 Fn.prototype.getX=function()&#123;&#125; &#125; //给Fn的原型上设置方法（只能设置方法，不能设置属性），可以写外边 // static AA()&#123; //把Fn当作一个普通对象，设置私有的方法，同样也只能设置方法，不能设置属性，只能在外边设置 &#125;&#125;Fn.prototype.BB=100;let f = new Fn(20, 10);//继承class A&#123; constructor()&#123; this.x=100; &#125; getX()&#123; console.log(this.x); &#125;&#125;class B extends A&#123;//extends类似于形成了原型继承 constructor()&#123; super(); //类似于call继承，相当于把A的constructor给执行了，并且让方法中的this是B的实例，super中传递的参数都是给A的constructor传递的 this.y=100; &#125; getY()&#123; console.log(this.y); &#125;&#125; 英文字母汉字组成的字符串，用正则给英文单词前后加空格12345678910// 把一个英文段落中的每一个的单词首字母大写let str=\"he is a good man-boy!\"//let reg = /\\b([a-zA-Z]+)\\b/g;// \\b会把-左右两边算作边界，the-man会被当作两个单词let reg=/(^| )([^\\s]+)( |$)/g;str = str.replace(/ /g, ' ').replace(reg, (...arg) =&gt; &#123; let val=arg[0]; return val.substr(0,1).toUpperCase()+val.substr(1);&#125;);console.log(str);","categories":[],"tags":[]},{"title":"瀑布流","slug":"瀑布流","date":"2019-06-11T07:18:49.000Z","updated":"2020-05-27T06:49:44.493Z","comments":true,"path":"2019/06/11/瀑布流/","link":"","permalink":"https://abluecup.github.io/2019/06/11/瀑布流/","excerpt":"瀑布流是当前流行的一种图片排列方式，本篇做了一些基本的介绍；","text":"瀑布流是当前流行的一种图片排列方式，本篇做了一些基本的介绍； 瀑布流专题瀑布流： 效果：多列的不规则排列，每一列中有很多内容，每一项内容的高度不定，最后我们按照规则排列，散列之间不能相差太多高度 实现：首先获取需要展示的数据（假设有50条，共3列），把50条数据中的前三条依次插入到三列中（目前有的列高，有的列低），接下来，再拿三条数据，但是本次插入不是依次插入，而是需要先把当前三列按照高矮进行排序，哪个最矮，就先给哪个插入内容，然后依次类推，把50条数据都插入即可。 tips:123456使用 Windows 快捷方式。Windows 右击 Chrome 的快捷方式 属性 - 快捷方式 - 目标。将目标内容后添加--allow-file-access-from-files。注意添加的内容和原有内容要用空格分割。例如：\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\" --allow-file-access-from-files。点击确定后，关闭所有 Chrome 窗口，使用快捷方式打开的 Chrome 窗口进行访问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * * */class WaterFall &#123; constructor(wrapper, pictures) &#123; this.wrapper = wrapper; this.pictures = pictures; this.container = this.wrapper.getElementsByClassName('grid-item'); this.imagesHeightAry = []; this.baseAry = []; this.flag = true; this.init(this.pictures, this.wrapper, this.imagesHeightAry, this.baseAry, this.container, this.flag); &#125; //给计算高度数组添加默认值:因为每列的宽度是一定的，所以自适应的情况下，宽高比是一定的，这样我们可以设置宽度为100，计算高度，通过此高度来比较哪一列最低，虽然数值不准确，但是各列的比值是一定的，效果也一样。 setAryDefaultValue(ary1, len) &#123; for (let i = 0; i &lt; len; i++) &#123; ary1[i] = 0; &#125; &#125; //插入一张图片 insertOneImg(imgSrc, ary, container, ary2, index) &#123; let _min = Math.min(...ary), _minIndex = ary.indexOf(_min); container[_minIndex].innerHTML += `&lt;img src = ./img/$&#123;imgSrc&#125;&gt;`; ary[_minIndex] += ary2[index]; &#125; // 初始化 placeAllImages(images, imagesHeightAry, baseAry, container) &#123; let _that = this; // 后面会使用实例，但是this会改变指向，所以定义_that = this, 方面后续使用 let count = 0; imagesHeightAry = []; images.forEach((item, index) =&gt; &#123; let tempImg = new Image(); tempImg.src = `./img/$&#123;item&#125;`; tempImg.onload = function () &#123; let _w = this.width, _h = this.height; _h = (100 / _w) * _h; imagesHeightAry[index] = _h; count++; if (count === images.length) &#123; // 依次插入所有的图片 insert all the images in the order. images.forEach((item, index) =&gt; &#123; _that.insertOneImg(item, baseAry, container, imagesHeightAry, index); &#125;); _that.flag = true; &#125; &#125; &#125;); &#125; //滚动加载 scrollLoad(images) &#123; let _wh = this.wrapper.offsetHeight, _cH = document.documentElement.clientHeight, _scrollH = document.documentElement.scrollTop; if (_scrollH + _cH + 10 &gt; _wh &amp;&amp; this.flag) &#123; this.flag = false; this.placeAllImages(images, this.imagesHeightAry, this.baseAry, this.container); &#125; &#125; init(images, wrapper, imagesHeightAry, baseAry, container) &#123; this.setAryDefaultValue(baseAry, container.length); this.placeAllImages(images, imagesHeightAry, baseAry, container); window.onscroll = () =&gt; &#123; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"英语学习","slug":"英语学习","date":"2019-05-16T11:58:04.000Z","updated":"2020-05-17T07:00:48.924Z","comments":true,"path":"2019/05/16/英语学习/","link":"","permalink":"https://abluecup.github.io/2019/05/16/英语学习/","excerpt":"英语学习笔记","text":"英语学习笔记 Day1Last year, I bought a watch. 英文： 状1 主 定1 谓 状2 宾 （定2| 状1） 中文： 状1 定1 主 状2 谓 定2| 宾 状1 R1 定语的倒序新近公布的统计数字表明，中国的公共图书馆数量在逐年增长Number pulished newly says, the number of public library in china are increaing year by year 她把手伸到书包里掏钢笔She gets the pen from bag by hands.","categories":[],"tags":[{"name":"英语","slug":"英语","permalink":"https://abluecup.github.io/tags/英语/"}]},{"title":"盒子模型","slug":"盒子模型","date":"2019-05-15T08:43:09.000Z","updated":"2019-09-18T08:48:03.964Z","comments":true,"path":"2019/05/15/盒子模型/","link":"","permalink":"https://abluecup.github.io/2019/05/15/盒子模型/","excerpt":"本篇的主要内容是盒子模型和jQuery的介绍","text":"本篇的主要内容是盒子模型和jQuery的介绍 JS中的盒子模型属性在JS中通过相关的属性可以获取（设置—）元素的样式信息，这些属性就是盒子模型属性（基本上都是有关于样式的），共有13个属性，client/offset/scroll[Top/Left/Width/Height], offsetparent. clientWidth &amp; clientHeight获取当前元素可视区域的宽高：内容的宽高+padding;和内容是否有溢出无关（和设置了overflow:hidden也无关）,就是我们自己设定的内容的宽高+padding123// 获取当前页面一屏幕（可视区域）的宽高document.documentElement.clientWidth || document.body.clientWidth;document.documentElement.clientHeight || document.body.clientHeight; clientTop &amp; clientLeft内容的左上角相对于盒子的左上角的偏移距离 offsetWidth &amp; offsetHeight在client的基础上加上border(和内容是否溢出也没有关系) offsetLeft &amp; offsetTop元素距离其父级元素左边和上边的偏移距离 scrollWidth &amp; scrollHeight真实内容的宽高（，不一定是自己设置的值，因为可能会存在内容溢出，有内容溢出的情况下，需要把溢出的内容也算上）+ 左/上padding,而且是一个约等于值（在不同浏览器下，或者是否设置了Overflow:hidder都会对最后的结果产生影响，所以这个值仅仅做参考，属于约等于的值）没有内容溢出的情况下和client值相同123// 当前页面内容的真实宽高document.documentElement.scrolltWidth || document.body.scrollWidth;document.documentElement.scrollHeight || document.body.scrollHeight; 通过JS盒子模型属性获取值的特点1 获取的都是数字，不带单位2 获取的都是整数，不会出现小数(一般都会四舍五入，尤其是获取的偏移量)3 获取的结果都是一个复合样式值（好几个元素样式组合在一起的值），如果只想获取单一样式值（这个不能说明没有用，真实项目中，有时候我们就是需要获取组合的值来完成一些操作） 获取元素的具体的某个样式值 [元素].style.xxx 操作只能获取所有卸载元素行内上的样式（不写在行内上，不管你写没写都获取不到，真实项目中，我们很少会把样式卸载行内上） window.getComputedStyle获取当前元素所有经过浏览器计算的样式（只要当前元素可以在页面中呈现或者说浏览器渲染它了），那么它的样式都是被计算过的,不管当前样式写在哪，不管你是否写了（浏览器给元素设置了一些默认样式）语法：12window.getComputedStyle([元素]，[伪类，一般都写null]) // 获取到当前元素的所有样式//IE6-8中用[元素].currentStyle getCSS1234567891011121314151617181920/*** * getCSS: 获取当前元素的某一个元素属性值 * @param * curEle[object]: 当前要操作的元素 * attr[string]: 当前要获取的样式属性名 * @return * 获取的样式属性值 */ let getCss=function getCss(curEle,attr)&#123; if ('getComputedStyle' in window) &#123; let val=window.getComputedStyle(curEle,null)[attr]; //把获取的结果去除单位，不是所有的值都能去单位的。例如display，还有一些复合值，比如border:1px solid gray; // 只有符合数字+单位这种模式的结果才能去除 let reg=/^-?\\d+(\\.\\d+)?(px|em|rem|pt)?$/i; reg.test(val)?val=parseFloat(val):null; return val; &#125; throw new SyntaxError('您的浏览器版本过低，请升级到最新版本，谢谢配合！'); // 抛出一个错误（语法错误），让浏览器崩溃，不再继续执行JS &#125;; console.log(getCss(outer,'border')); jQuery(JQ) JQ是一个非常优秀的JS类库。 123456789101112131415 /** * 类库、插件、UI组件、框架 * 1，类库：JQ/ZEPTO... 提供一些真实项目中常用的方法，任何项目都可以把类库导入进来，调取里面的方法实现自己需要的业务逻辑； * 2，插件：具备一定的业务功能，例如，我们可以封装轮播图插件、选项卡插件、模态狂插件等（规定了当前这个功能的样式结构，把实现功能的JS进行封装，以后想实现这个功能，直接导入插件即可）swiper\\iscroll\\jquery-dialog\\jquery-drag\\jquery-datepicker\\ECharts； * 3，UI组件：把结构、css、js全部都封装好了，我们想实现一个功能，直接导入进来即可（可能会偶尔需要我们修改下，但是改动不多）bootstrap... * 4, 框架：具备一定的编程思想，要求我们按照他们的框架思想开发，一般框架中提供了常用的类库方法，强大的功能插件，有的也提供了强大的UI组件 React \\ Vue \\ Angular \\ Backbone \\ Sea.js \\ Require.js... *//** * jQuery非常优秀的JS“类库” * -&gt; 基于原生JS封装的一个类库，提供了很多的方法，而且这些方法是兼容所有浏览器的； * -&gt; JQ版本 * v1 (常用) 1.8.7 1.9.3 1.11.3 * v2 * v3// */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849(function()&#123; var version = \"1.11.3\", jQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery.fn.init( selector, context ); //创建了init这个类的实例，相当于也创建了JQ这个类的实例，因为在后面的时候，让init.prototype=jQuery.prototype &#125;; //JQ是一个类，在它的原型上提供了很多属性和方法，供JQ的实例调取使用 jQuery.fn = jQuery.prototype = &#123; // The current version of jQuery being used jquery: version, constructor: jQuery, // 原型重定向之后，自己开辟的堆内存中是没有constructor,需要手动增加，保证它的完整性。 // Start with an empty selector selector: \"\" //... &#125;; //给JQ原型上增加extend方法，同时把JQ当作一个普通对象，给这个对象设置了一个私有的方法 /** * JQ是一个类，也是一个普通对象，这是函数的两种角色；JQ是一个类库，提供了很多方法，其中这些方法有两部分 * 1，放到JQ原型上的，这里面的方法是供JQ的实例调取使用的 * 2，把JQ当作一个普通的对象，在对象上设置一些私有的属性和方法，这类方法以后用的时候直接jQuery.xxx()执行即可 */ jQuery.extend = jQuery.fn.extend = function() &#123; //把一个对象中的属性和方法扩展到指定的对象上 &#125;; jQuery.extend(&#123; isFunction:function()&#123;&#125;, isArrary:function()&#123;&#125; //... &#125;); //JQ上多了方法isFunction, isArray... jQuery.fn.extend(&#123; find:function()&#123;&#125; //... // 往JQ的原型上添加新的方法find &#125;); //... // 把init当作一个类，但是让这个类的原型指向了JQ的原型（init的实例最后找到的是JQ这个类的原型上的方法，init的实例也可以理解为JQ的实例） var init = jQuery.fn.init = function( selector, context ) &#123;&#125;; init.prototype=jQuery.fn; window.jQuery = window.$ = jQuery; return jQuery;&#125;)();$()//创建了一个jQuery的实例，可以调取jQuery.fn上的方法$.isFunction();// 把jQuery当作一个普通对象，直接使用对象上的方法，这些方法和实例没有关系 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//=&gt; JQ选择器:基于各种选择器创建一个JQ实例（JQ对象）//1. selector 选择器的类型（一般都是字符串，但是支持函数或者元素对象）//2. context 基于选择器获取元素的时候指定的上下文（默认document）//JQ对象：一个类数组结构（JQ实例），这个类数组集合中包含了获取到的元素// console.log($('.tabBox'));/** * JQ对象（类数组）=&gt;JQ实例 * 0:div.tabBox 获取到的元素 * length:1 * context:document * selector: '.tabBox' * _proto_:jQuery.prototype * add: * ... * _proto_: Object.prototype * hasOwnProperty: * ... */ /** * 获取页面中的元素对象 * 1.基于原生JS提供的属性和方法获取=&gt;\"原生JS对象\" * 可以调取使用内置的JS属性和方法 className,onclick,... * 2.基于JQ选择器获取=&gt;JQ对象 * 可以调取JQ原型上提供的方法 * add * find * ... *///$('.tabBox').className += 'clearfix'; // 没法使用，$原型上没有这些方法// 把JQ对象和原生JS对象之间相互转化/** * 1 JQ对象 -&gt; 原生JS对象 * JQ对象是一个类数组结合，集合中每一个索引对象的都是原生JS对象，我们基于索引获取即可 * let $tabBox=$(\".tabBox\"); 变量名前面是以$开头的，一般代表基于JQ选择器获取的结果 * let tabBox=$tabBox[0]; * 获取$tabBox.get(0);get是JQ原型提供的方法，供JQ实例基于索引获取到指定的JS对象 * $tabBox.eq(0); 它也是基于索引获取集合中的某一项，只不过get获取到的是JS对象，EQ会把获取到的结果包裹成一个新的JQ对象 * * 2 原生JS对象 -&gt; JQ对象 * let tabBox=document.querySelector('.tabBox'); * $(tabBox); 直接使用$把原生JS对象包裹起来，就可以把JS对象转化为JQ对象（因为$()执行就是创建JQ的一个实例） */ /** * 看选择器源码，我们发现selector传递的值支持三种类型 * 1 STRING * 2 元素对象 selector.nodeType 把JS对象转化为JQ对象 * 3 函数 把传递的函数执行，并且把jQuery当作实参传给函数 selector(jQuery); *//* $(function($)&#123; //=&gt;$: 传递进来的jQuery // console.log($); &#125;); */ $='呱呱呱'; jQuery(function($)&#123; //$:是私有变量，而且特定就是JQ $(); &#125;); jQuery(()=&gt;&#123; //函数肯定会执行，但是会在当前页面中的HTML结构都加载完成后再执行 //函数执行会形成一个闭包 &#125;); $(function()&#123; // 写自己的代码 &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 //JQ中常用的方法/* $(document).ready(function()&#123; $('&lt;a href=\"https://www.baidu.com\"&gt;&lt;/a&gt;')[0].click();&#125;); *//** * JQ选择器的selector可以是字符串，字符串这种格式也有两种 * 1 选择器 * 2 html字符串拼接的结构：把拼接好的html字符串转换为JQ对象，然后基于append-to方法追加到页面当中 */$('&lt;div id=\"AA\"&gt;&lt;/div&gt;').appendTo(document.body);/** * JQ中的each方法是用来进行遍历（类似数组中的FOR-EACH * 【可遍历对象】 * 1.数组 * 2 对象 * 3 类数组（JQ对象） * 。。。 * 【三种EACH】 * 1 给JQUERY设置的私有属性 $.each(); * 2 给实例设置的公有属性 $([SELECTOR]).each(); * 3 内置的EACH */$.each([12,23,34],(index,item)=&gt;&#123; //=&gt; 参数的顺序和内置的FOR-EACH相反 console.log(index,item);&#125;);$.each(&#123;name:'xxx',age:25,0:100&#125;,(key,value)=&gt;&#123; //原理就是FOR-IN循环 console.log(key,value);&#125;);/* $('.tabBox li').each(function(index,item)&#123; //非箭头函数：this===item,当前遍历的项（原生JS对象） //$(this),把原生JS对象转化为JQ对象 $(this).on('click',function()&#123; //this &#125;); $(this).click(function()&#123; //this: 原生JS对象 $(this).css(&#123; color:'red' &#125;); &#125;);&#125;); */$('.tabBox li').click(function()&#123; //集合中有三个，我们此处相当于给三个Li都绑定了点击事件，JQ在调取click的时候，首先会默认的把集合进行each遍历，然后把每一项都绑定点击事件 $(this).css(&#123; color:'red' &#125;);&#125;);$('.tabBox li').css(&#123;color:'green'&#125;);//JQ中的大部分方法都会对对象进行each/** * addClass *//** * */jQuery.noConflict();//转让JQ使用$的权利console.log($); // undefinedlet zzz=jQuery.noConflict(true);// 深度转让/* */console.log(jQuery); //undefinedconsole.log(zzz); // jQuery// $.ajax(&#123;url:'',method:get,async:false，success:function()&#123;&#125;&#125;); 直接得到的就是JSON格式的数据//属性//toggle切换//jQ里面常用的筛选方法有三个：//filter:同级筛选//children:子集筛选//find:后代筛选 12345678910111213141516171819202122232425//=&gt;当html结构都加载完成执行函数/* jQuery(function ($) &#123; let $tabBox = $('.tabBox'), $tabList = $tabBox.find('.header&gt;li'), $divList = $tabBox.children('div'); //基于JQ内置的each机制，给每一个li都绑定了点击事件 $tabList.on('click', function () &#123; let index = $(this).index(); $(this).addClass('active') .siblings().removeClass('active') .parent().nextAll('div').eq(index).addClass('active') .siblings('div').removeClass('active'); &#125;);&#125;); */jQuery(function ($) &#123; $(\".tabBox&gt;.header&gt;li\").on('click', function () &#123; let index = $(this).index(); $(this).addClass('active') .siblings().removeClass('active') .parent().nextAll('div').eq(index).addClass('active') .siblings('div').removeClass('active'); &#125;);&#125;); 补充：&lt;!– 块级元素，默认宽度为父级元素的100%； 如果块级元素的子元素全部都是position:absolute的话，宽度为100%，高度为0 position:relative是相对于自己的定位；position:absolute是相对于父级元素的的定位； float, absolute都会让元素脱离文档流， clear：left|right|both|none;表示清除元素左|右|两边|none的浮动元素（float属性不为none的元素，float属性值为none的元素不受影响） p span a i strong b img td等都是行内元素 div header table tr section ul li等都是块级元素 inline-block行内块：位置在行内，但是拥有宽度、高度等块级元素的属性 –&gt;","categories":[],"tags":[]},{"title":"正则","slug":"正则","date":"2019-04-29T08:24:35.000Z","updated":"2020-05-25T06:37:53.590Z","comments":true,"path":"2019/04/29/正则/","link":"","permalink":"https://abluecup.github.io/2019/04/29/正则/","excerpt":"恰如其分得使用正则，能够减少代码的冗余量；","text":"恰如其分得使用正则，能够减少代码的冗余量； 正则是一个用来处理字符串的规则 正则只能用来处理字符串 1:验证当前字符串是否符合某个规则（正则匹配） 2：把一个字符串中符合规则的字符获取到（正则捕获）学习正则其实是学习如何编写规则，每一个正则都是由“元字符”、“修饰符”两部分组成 创建正则的两种方式1.字面量方式let reg = /^\\d+$/g; 2.构造函数方式let reg =new RegExp(&#39;^\\\\d+$&#39;,&#39;g&#39;) 元字符和修饰符两个//之间的都是元字符，/后面出现的都是修饰符^ caret 常用的修饰符i,m,g i: ignoreCase 忽略大小写m: multiline 多行匹配g: global 全局匹配 常用的元字符『特殊元字符』我们简单介绍常用的16个元字符： \\d 0-9之间的数字 \\D 非0-9之间的任意字符 \\w 数字、字母、下划线中的任意一个 =&gt; /[0-9a-zA-Z_]/ \\W 数字、字母、下划线外的任意一个 \\s 匹配任意一个空白字符（包括\\t制表符） \\b 匹配边界符 ‘zhu’ z左边和u右边就是边界 ‘zhu-feng’ z左边、u右边、f左边、g右边都是边界 \\n 匹配一个换行符 \\ 转义字符：把一个普通字符转义为特殊的字符，例如\\d; 把有特殊含义的转化为普通意思,例如. 表示一个小数点 (. 不仅仅是小数点，代表除了\\n以外的任意字符) ^ 以某个元字符开头 发音：[‘kærət] $ 以某个元字符结尾 | x|y 表示x或者y中的任意一个 [] [xyz] 表示x,y,z中的任意一个 [^xyz] 除了x,y,z之外的任意一个字符 [a-z]获取a-z中的任意一个字符 [0-9] == \\d [^0-9] == \\D () 正则分组 (?:) 当前分组只匹配，不捕获 (?=) 正向预查 (?!) 负向预查 … 『量词元字符』：让其左边的元字符出现多少次 * 出现0到多次 ? 出现零到一次 + 出现一到多次 {n} 出现n次 {n,} 出现n到多次 {n,m} 出现n到m次 『普通元字符』 只要在正则中出现的元字符（在基于字面方式创建），除了特殊和有量词意义的以外，都是普通元字符。 []的一些细节[xyz][^xyz][a-z][^a-z]1.在[]中出现的元字符一般都是代表本身含义的12345let reg = /^.$/; 里面是任意字符//一个正则设置了^$,那么代表的含义其实就是只能是xxxlet reg1=/^[.]+$/ [.]只能是 . let reg2=/^[\\d]$/; \\d依然代表的是0-9中的任意数字 2.[]中出现的两位数，不是两位数，而是两个数字中的任意一个12345678910111213let reg=/\\d+/;// 不加^$,代表字符串中只要包含xx即可let reg=/\\d+/;console.log(reg.test(8)); //trueconsole.log(reg.test(18)); //truelet reg1=/^[18]$/; // 18中的一个console.log(reg1.test(8)); //trueconsole.log(reg1.test(18)); // falselet reg3=/^[12-65]$/;//表示1或者2-6或者5 console.log(reg3.test(13)); // falseconsole.log(reg3.test(5)); //true 思考题：年龄在18-65之间123456/** * 18,19 1[89] * 20-59 [2-5][0-9] * 60-65 6[0-5] */let reg=/^(([2-5][0-9])|(1[89])|(6[0-5]))$/; 思考题：编写一个规则，匹配”[object AAA]”1let reg=/^\\[object .+\\]$/ () 分组的作用 a 改变默认的优先级 12345let reg=/^(18|19)$/;/** * /^18|19$/表示的是1开头，9结尾，中间夹一个8或者1 * /^(18|19)$/表示的是18或者19中的一个*/ b 分组捕获 c 分组引用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** 正则捕获：把一个字符串中和正则匹配到的部分获取到* 【正则】* exec [ɪg'zek; eg-]* test* * 【字符串】* replace* match* split*//*** 基于exec可以实现正则捕获，* 1. 如果当前字符和正则不匹配，捕获到的结果是null;* 2. 如果匹配，获取到的是一个数组* 0：大正则捕获的内容* index ： 正则捕获的起始索引* input: 源字符串* 3. 执行一次exec只能捕获到第一个和正则匹配的内容，其余匹配的内容还没有捕获到，而且执行多次，也无法获取到之后匹配的内容=&gt;正则的捕获有懒惰行：只能匹配到第一个匹配的内容，剩下的匹配不到*/let str = 'zhufeng2018peixun2019yangfan2020qihang2021';let reg1 = /\\d+/;/* console.log(reg1.test(str)) true;console.log(reg1.exec(str)); [ '2018', index: 7, input: 'zhufeng2018peixun2019yangfan2020qihang2021' ]*/console.log(reg1.lastIndex); // 0 正则捕获的时候，下一次在字符串中开始查找的索引//lastIndex不变导致了懒惰性//即使我们手动修改了lastIndex的值，也没什么用//解决懒惰性问题: 加全局修饰符g; 如果不加g，不管用什么方法，都无法把全部匹配的捕获到let reg2 = /\\d+/g;/* console.log(reg2.lastIndex);console.log(reg2.exec(str));console.log(reg2.lastIndex);//console.log(reg2.exec(str)); */RegExp.prototype.myExecAll = function (str) &#123;//this:reg当前操作的正则//str: 我们要捕获的字符串//具体捕获多少次不定，直到捕获到null为止，期间把捕获到的内容存储到数组中即可// 为了防止死循环，我们需要对正则进行检验if (!this.global) &#123;return this.exec(str);&#125;let result = [],valAry = this.exec(str);while (valAry) &#123;result.push(valAry[0]); // 把每一次正则捕获到的内容存储到容器当中，最后把result返回valAry = this.exec(str);&#125;;return result;&#125;;//console.log(reg2.myExecAll(str));console.log(str.match(reg1));console.log(str.match(reg2)); //[ '2018', '2019', '2020', '2021' ] match 实现了我们自己编写的execAll处理的事情，正则不加g，返回第一个即可，加g，把所有匹配的内容都捕获到，最后存储到一个数组中返回let str1 = 'zhufeng&#123;2018&#125;peixun&#123;2019&#125;yangfan&#123;2020&#125;qihang&#123;2021&#125;';let reg4=/\\&#123;(\\d+)\\&#125;/g;console.log(reg4.exec(str1)); // 在正则捕获的时候，如果正则中存在分组，捕获的时候不仅仅把大正则匹配到的字符捕获到（数组的第一项），而且把小分组匹配的内容也单独抽取出来（数组中第二项console.log(str1.match(reg4)); //match 有局限性，在正则设置g的情况下，基于match捕获的内容只有大正则匹配的内容，小分组的内容没有单独抽取出来；不设置g的情况下和执行exec一样。 1234567891011121314151617/*** 正则捕获的贪婪性* 每一次匹配捕获的时候，总是匹配到和正则匹配中最长的内容：我们捕获到的不是2，而是2018*/console.log(reg1.exec(str));//解决方案：在量词后面加个?let reg5=/\\d+?/; //此时?不是出现0-1次，而是取消捕获的贪婪性/*** ?在正则中的作用* 1. 量词元字符：出现0-1次* 2. 取消贪婪性 /\\d+?/ 只捕获最短匹配的内容* 3. ?: 只匹配不捕获* 4. ?= 正向预查* 5. ?! 负向预查*/ 更多的捕获方式123456let str=\"zhufeng2018peixun2019\";let reg=/\\d+/g;console.log(reg.test(str));console.log(reg.lastIndex); // 11//基于test进行捕获的时候，如果设置了g，test匹配也相当于捕获，修改了last-index的值console.log(reg.exec(str)); 12345let str='zhufeng2018';let reg=/\\d+/g;if(reg.test(str))&#123; console.log(reg.exec(str)); // null&#125; 12345let str='zhufeng2018';let reg=/\\d+/g;console.log(reg.exec(str)); // 2018console.log(reg.exec('zhufeng2018peixun2019')); // 2019//虽然捕获的不是同一个字符串，但是同一个正则，上一次正则处理的时候修改了它的last-index,也会对下一次匹配的字符串产生影响 123456789101112let str='zhufeng2018peixun2019';let reg=/(\\d+)/g;console.log(reg.test(str));console.log(RegExp.$1); // 2018/** * 把上一次匹配到的结果获取到，获取的是第一个小分组匹配的内容，大正则匹配的内容无法获取到 * 它是一个全局的值，浏览器中$1只有一个，其他的正则操作也会覆盖这个值，所以没有什么用处 * */console.log(reg.test(str));console.log(RegExp.$1); //2019console.log(reg.test(str));console.log(RegExp.$1); //2019 replace123456789101112131415161718/** * * replace:实现正则捕获（本身是字符串替换） * 原理：每一次正则匹配的结果都把函数执行，然后基于EXEC把本次匹配的信息捕获到，然后把捕获的信息传递给这个函数 */let str='zhufeng2018zhufeng2019';//zhufeng =&gt; zhufengpeixun//真实项目中，很多需求不基于正则是无法实现替换的str=str.replace(/zhufeng/g,'zhufengpeixun');let reg = /zhufeng/g;console.log(str);let str1='zhufeng&#123;val:2018&#125;zhufeng&#123;val:2019&#125;';let reg1=/\\&#123;val:(\\d+)\\&#125;/g;//str1=str1.replace(reg1,'@'); str1=str1.replace(reg1,'$1');//此处的$1代表第一个分组匹配的内容，等价于RegExp.$1 zhufeng2018zhufeng2019console.log(str1); //zhufeng@zhufeng@ /*用reg正则和str字符串进行匹配，匹配几次就替换几次，每一次都是把当前“大正则”匹配的结果用第二个传递的字符串替换掉了*/ 12345678910111213141516171819202122232425/** * * replace:实现正则捕获（本身是字符串替换） * 原理：每一次正则匹配的结果都把函数执行，然后基于EXEC把本次匹配的信息捕获到，然后把捕获的信息传递给这个函数 */let str='zhufeng2018zhufeng2019';//zhufeng =&gt; zhufengpeixun//真实项目中，很多需求不基于正则是无法实现替换的str=str.replace(/zhufeng/g,'zhufengpeixun');let reg = /zhufeng/g;console.log(str);let str1='zhufeng&#123;val:2018&#125;zhufeng&#123;val:2019&#125;';let reg1=/\\&#123;val:(\\d+)\\&#125;/g;/** * 1 reg 和 str 匹配多少次，函数就被处罚执行多少次，而且传递了一些参数信息值； * 2 每一次arg中国存储的信息，和执行exec捕获到的信息相似 * 3 每一次函数中返回的是啥，就把当前大正则匹配的内容替换成啥 */str = str1.replace(reg1, (...arg)=&gt;&#123; console.log(arg); return 'AA';&#125;);console.log(str); 时间字符串格式化12345678// 时间字符串格式化String.prototype.myFormatTime = function (template = '&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒') &#123; //this:str let ary = this.match(/\\d+/g).map(item =&gt; item &lt; 10 ? '0' + item : item); return template.replace(/\\&#123;(\\d)\\&#125;/g, (...[, index]) =&gt; ary[index] || '00');&#125;;let str = '2018/4/30';console.log(str.myFormatTime('&#123;0&#125;:&#123;1&#125;:&#123;2&#125; &#123;3&#125;:&#123;4&#125;:&#123;5&#125;')); 正则闯关游戏:https://alf.nu/RegexGolf ([a-z]{3}).*\\1\\1表示重复前面的括号内的规则([a-z]{3}) ^(?!.([a-z])([a-z])\\2\\1);不包含baidu开头 /^.(?!baidu).*$/","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"https://abluecup.github.io/tags/正则/"}]},{"title":"less","slug":"less","date":"2019-04-29T07:18:27.000Z","updated":"2020-05-25T06:37:11.051Z","comments":true,"path":"2019/04/29/less/","link":"","permalink":"https://abluecup.github.io/2019/04/29/less/","excerpt":"less是css预编译语言，能够提高css的书写，本片是对less的基本介绍","text":"less是css预编译语言，能够提高css的书写，本片是对less的基本介绍 less 它是css预编译语言，和它类似的还有sass/stylus…css是标记语言，不是编程语言，没有类、实例、函数、变量等东西。而less等预编译语言就是让css具备面向对象编程的思想，但是浏览器不能直接识别和渲染less代码，需要我们把less代码预先编译为正常的css后，再交给浏览器渲染解析 less的编译 在开发环境下编译（产品还没有开发完，正在开发中，这个是开发环境） 导入less.js即可 1234// rel=\"stylesheet/less\" &lt;link rel=\"stylesheet/less\" href=\"css/index.less\"/&gt;// 导入js文件 &lt;script src=\"js/less-2.5.3.min.js\"&gt;&lt;/script&gt; 在生产环境下（产品开发完需要部署到服务器上） 项目上线，不能把less部署上线，这样用户每一次打开页面都需要重新编译，非常好性能，我们不到服务器上的都是编译后的css 1234561. 在当前电脑的全局环境下安装less模块 $ npm install less -g 验证是否安装成功2. 基于命令把less编译成css $ lessc a.less b.min.css -x -x 是压缩 编译完成后，部署到生产环境中的是编译后的b.min.css 目前基于webpack和框架实现工程化开发的时候，我们都是在webpack配置文件中，配置出less的编译（需要安装less/less-loader等模块），这样不管是开发环境下的预览，还是部署到生产环境下，都是基于webpack中的Less模块编译的 less的基础语法less中的变量 用一个变量存储一个公共值，后期需要使用这个值，直接调取这个变量即可，以后如果值需要修改iazhixuyao更改变量的值，那么所有用到这个变量的地方都跟着修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152.centerPos(@w: 100, @h: 100) &#123; position : absolute; top : 50%; left : 50%; margin-top : unit(-(@w/2), px); margin-left: unit(-(@h/2), px);&#125;/* 变量 */@link-color: #555;@bg-src : '../img'; .box &#123; width : 400px; height: 400px; .centerPos(400, 400); background: lightblue; background:url(\"@&#123;bg-src&#125;/1.jpg\") no-repeat; a &#123; color: @link-color; &#125;&#125;/* 函数 */.transition(@property:all,@duration:.5s,@timing-function:linear,@delay:0)&#123; -webkit-transition: @arguments; -moz-transition: @arguments; -ms-transition:@arguments; -o-transition: @arguments; transition: @arguments;&#125;/* 嵌套 */@H:200;.pub&#123; @H:100; .bg&#123; /* .pub .bg */ a&#123; color:red; width:unit(@H,px); /* @H是300，按照嵌套层，逐层往外查询 */ &#125; @H:300; &#125; &amp; &gt; .bg&#123; /* .pub &gt; .bg */ color: #000; &#125; &amp;.bg&#123; /* .pub .bg */ color: #000; &#125;&#125; 一般我们会把函数和变量存放到一个单独的less文件中，然后在文件中导入，使用 @import (reference) &#39;common&#39;; reference是指不会编译common中的内容 商城排序中的lesshtml:12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;商城排序&lt;/title&gt; &lt;!-- &lt;link rel=\"stylesheet/less\" href=\"css/index.less\"&gt; &lt;script src=\"js/less-2.5.3.min.js\"&gt;&lt;/script&gt; --&gt; &lt;link rel=\"stylesheet\" href=\"css/index.min.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;header class=\"headerBox\" id=\"headerBox\"&gt; &lt;span&gt;排序&lt;/span&gt; &lt;a href=\"javascript:;\"&gt;上架时间&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;价格&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;热度&lt;/a&gt; &lt;/header&gt; &lt;ul class=\"productBox clearfix\" id=\"productBox\"&gt; &lt;li&gt; &lt;a href=\"javascript:;\"&gt; &lt;img src=\"../SHOP/img/1.jpg\" alt=\"\"&gt; &lt;p title=\"来的感觉的管理法规和；国家宏观\"&gt;来的感觉的管理法规和；国家宏观&lt;/p&gt; &lt;span&gt;￥4888&lt;/span&gt; &lt;span&gt;时间：2014-01-01&lt;/span&gt; &lt;span&gt;热度：999&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 真实项目中，我们经常使用a标签做一些点击的按钮 1.因为a标签的:hover伪类兼容所有浏览器 a标签的href属性存储的是点击需要跳转的页面，或者是#xxx,这个是hash定位，如果指向让其作为一个普通的按钮，我们需要组织a变迁的默认跳转行为 &lt;a href=\"javascript:;\"&gt;排序&lt;/a&gt; --&gt; &lt;script src=\"js/index.js\"&gt;&lt;/script&gt; &lt;script src=\"../SHOP/json/product.json\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; common.less123456789101112@con-bg: #fff;@text-black : #555;@text-gray : #999;@text-active: #e01d20;.transition(@property: all, @duration: 1s, @timing-function: linear, @delay: 0s) &#123; -webkit-transition: @arguments; -moz-transition : @arguments; -ms-transition : @arguments; -o-transition : @arguments; transition : @arguments;&#125; index.less123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/**reset是清空默认样式，不仅需要导入进来使用，最后需要和我们写的css一起编译，放到浏览器中渲染解析才可以common中存放的一般都是公用的变量或者方法，只需要调取使用即可，编译的时候不需要编译这些内容，所以用reference修饰一下导入的其他文件最好都是less文件，这样在编译的时候，把所有的less编译到一个文件中，实现css的合并和压缩*/@import 'reset';@import (reference) \"common\";html body &#123; background: #f4f4f4; overflow-x: hidden;&#125;.container &#123; width : 1200px; margin: 20px auto;&#125;.headerBox &#123; @H : 60px; height : @H; line-height: 50px; background : @con-bg; font-size : 0; span &#123; display : inline-block; // 使用inline-block会把标签之间的空格和换行当作元素占位，导致元素之间有间隙。解决：让父元素的font-size:0; width : 90px; text-align : center; height : @H; line-height: @H; font-size : 14px; color : @text-black; &#125; a &#123; display : inline-block; padding : 0 15px; height : @H; line-height: @H; font-size : 14px; color : @text-gray; &amp;:hover &#123; color: @text-active; &#125; &#125;&#125;.productBox &#123; margin : 20px 0 0 0; overflow: hidden; li &#123; float : left; // 子元素浮动，子元素的高度不能撑开父元素（脱离文档流）。解决：清除子元素浮动对父元素的影响 =》 clear:both; 在父元素上添加 margin-right: 10px; margin-bottom: 10px; background:@con-bg; &amp;:nth-child(5n+5) &#123;//五个为一组，一组中的第五个 margin-right: 0; &#125; a&#123; display:block; box-sizing: border-box; //css3新合资模型：我们设置的width是盒子最后的宽度，包括边框、padding、内容宽度 padding:0 16px; width: 232px; border:3px solid transparent; img&#123; display:block; width:100%; height: 194px; &#125; p&#123; color:@text-gray; font-size:14px; line-height: 20px; height: 40px; overflow: hidden; &#125; span&#123; display: block; line-height: 20px; font-size:12px; color:@text-black; &amp;:nth-child(1)&#123; /*不是所有span中的第一个，是a子元素中的第一个，并且是span标签*/ color:@text-active; &#125; &amp;:nth-of-type(1)&#123; color: @text-active; font-weight: bold; &#125; &#125; .transition(@duration: 0.5s;); &amp;:hover&#123; border-color:@text-active; box-shadow:3px 3px 10px pink; border-radius: 5px; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://abluecup.github.io/tags/css/"}]},{"title":"商城排序","slug":"商城排序","date":"2019-04-28T02:36:44.000Z","updated":"2020-05-21T06:10:32.618Z","comments":true,"path":"2019/04/28/商城排序/","link":"","permalink":"https://abluecup.github.io/2019/04/28/商城排序/","excerpt":"商城排序是项目中常见的问题，我们在本篇中使用原生JS实现此功能","text":"商城排序是项目中常见的问题，我们在本篇中使用原生JS实现此功能 知识预备JSON数据格式 释义：JSON格式：JSON不是一种数据类型，而是一种数据格式，只要把对象的属性用双引号括起来，此时的对象就不再称之为普通对象，而是叫做JSON格式对象12let obj=&#123;\"name\":\"xxx\"&#125;; //obj是json格式对象（操作起来和普通对象没有太大区别）let str='&#123;\"name\":\"xxx\"&#125;';//str是JSON格式字符串 JSON数据和对象之间的转换1234// 1.parse 把JSON格式的字符串转换为对象 JSON.parse('&#123;\"name\":\"xxx\"&#125;') // &#123;name:\"xxx\"&#125;// 2.stringify 把对象转换为JSON格式的字符串 JSON.stringify(&#123;name:\"xxx\"&#125;); //'&#123;\"name\":\"xxx\"&#125;' sort原理12345678910ary.sort((a,b)=&gt;&#123; // a是当前项， b是下一项 return Number(); //返回Number类型值，大于0调整a,b顺序，小于0不调整； &#125;);//打乱数组ary.sort((a,b)=&gt;&#123; return (Math.random() * 2 - 1);&#125;); AJAX123456789101112131415/** * 1. 创建一个AJAX实例 * 2. 打开一个请求地址 * 3. 监听 * 4. send(null)*/let xhr = new XMLHttpRequest; //=&gt;创建一个AJAX实例xhr.open('get', 'json/product.json', false);//=&gt; 打开一个请求的地址，一般这个地址都是服务器端提供的，最后一个参数是设置同步还是异步，true是异步，false是同步// 真实项目中往往是异步，我们为了简单使用同步xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; &#125;;&#125;;xhr.send(null); 数据绑定12345678910111213141516171819202122// 数据绑定：依托获取的数据，把页面中需要展示的数据和结构都搞出来，然后把创建好的数据和结构放到页面指定容器中/** * 1 字符串拼接： * -&gt; 传统字符串拼接 * -&gt; ES6模板字符串拼接 * -&gt; 模板引擎：原理也是字符串拼接 * 2 动态创建DOM * -&gt; createElement * -&gt; appendChild * 弊端：操作起来太麻烦，而且性能消耗更大（DOM回流） */let list = document.getElementById(\"list\");let str = ``;//这是两个撇（TAB上边按键），ES6模板字符串for (let i = 0; i &lt; productData.length; i++) &#123; let &#123; title, img='img/1.jpg', price &#125; = productData[i]; str += `&lt;li&gt;&lt;a href=\"javascript:;\"&gt; &lt;img src=\"$&#123;img&#125;\" alt=\"\"&gt; &lt;p&gt;$&#123;title&#125;&lt;/p&gt; &lt;span&gt;$&#123;price&#125;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;`;&#125;;list.innerHTML=str; 自定义属性编程思想 自定义属性编程思想： 凡是在后面的操作当中需要用到一些值，我们需要将属性定义到当前元素的属性上data-,后期需要用到这个值的时候，我们基于自定义属性获取到即可,后期我们获取这个值的时候，只能基于get attribut这种模式获取; 凡是在后面的某项操作当中，我们需要用到当前元素的某个值，但是这个值我们可以在前面的某个元素中得到，这时我们就想办法在前面的元素中设置自定义属性，存储这些值12 DOM映射机制页面中的HTML元素，和JS中通过相关方法获取到的元素集合或者元素对象存在映射关系（一个改变，另一个也改变） xxx.style.color=&apos;red&apos;: 把xxx元素对象对应堆内存中的style属性下的color属性值修改为red(本质操作的是JS堆内存) 但是由于DOM映射关系，页面中的标签和xxx元素对象是绑在一起的，我们修改元素对象空间中的值，页面中的元素会按照最新的值渲染。 在元素绑定前，我们获取容器中的元素，得到一个空的元素集合，元素数据绑定后，我们不需要重新获取，DOM的映射机制 会帮我们把新增加的元素映射到之前获取到的元素集合中，让其变为有元素的集合； querySelectALL获取的集合是静态集合，不存在上述所谓的映射机制，基于这种办法，数据绑定完成后需要重新获取一次才可以 箭头函数虽然很强大，但是不能乱用，尤其是在需要改变函数中this的情况下，箭头函数中的this不受我们管控，都是默认继承上下文中的，使用call也没有用拿出一张白纸，写思路，再按照思路写代码 完整的商城排序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let linkBox = document.getElementById('list'), headerBox = document.getElementById('header'), linkList = headerBox.getElementsByTagName('a'), productList = linkBox.getElementsByTagName('li');~function () &#123; let productData = null; let xhr = new XMLHttpRequest; xhr.open('get', 'json/product.json', false); xhr.onreadystatechange = function () &#123; xhr.readyState === 4 &amp;&amp; xhr.status === 0 ? productData = xhr.responseText : null; productData ? productData = JSON.parse(productData) : null; &#125; xhr.send(null); let str = ''; for (let i = 0; i &lt; productData.length; i++) &#123; let &#123; time, price, hot, img, title &#125; = productData[i]; str += `&lt;li data-time='$&#123;time&#125;' data-price='$&#123;price&#125;' data-hot='$&#123;hot&#125;'&gt; &lt;a href=\"javascript:;\"&gt; &lt;img src=\"$&#123;img&#125;\" alt=\"\"&gt; &lt;p title=\"$&#123;title&#125;\"&gt;$&#123;title&#125;&lt;/p&gt; &lt;span&gt;￥$&#123;price&#125;&lt;/span&gt; &lt;span&gt;时间：$&#123;time&#125;&lt;/span&gt; &lt;span&gt;热度：$&#123;hot&#125;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;` &#125; linkBox.innerHTML = str; for (let i = 0; i &lt; linkList.length; i++) &#123; let item = linkList[i]; item.index=i; item.flag=-1; item.onclick=function()&#123; for (let j = 0; j &lt; linkList.length; j++) &#123; if(this !== linkList[j])&#123; linkList[j].flag=-1; &#125;; &#125;; this.flag *=-1; sortList.call(this); &#125; &#125; let sortList=function()&#123; let productAry=[].slice.call(productList,0); let ary=['data-time','data-price','data-hot']; let &#123;index:_index,flag:_flag&#125;=this; productAry.sort((a,b)=&gt;&#123; let aInn=a.getAttribute(ary[_index]), bInn=b.getAttribute(ary[_index]); _index===0?(aInn=aInn.replace(/-/g,''),bInn=bInn.replace(/-/g,'')):null; return (aInn-bInn)*_flag; &#125;); for (let i = 0; i &lt; productAry.length; i++) &#123; linkBox.appendChild(productAry[i]); &#125; &#125;&#125;(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 //基于高级单例模式完成业务逻辑开发let productRender = (function () &#123; //=》自执行函数形成的私有作用域不销毁（闭包） //里面的方法和变量和外界不冲突，里面创建的值不销毁 //基于ajax获取数据 let productData = null; // 如果一个变量在多个方法里都要用到，我们需要定义一个公共变量 let productBox = document.getElementById('productBox'); let headerBox = document.getElementById('headerBox'); let linkList = headerBox.getElementsByTagName('a'); let productList = null; let getData = function () &#123; let xhr = new XMLHttpRequest; xhr.open('get', '../SHOP/json/product.json', false); xhr.onreadystatechange = function () &#123; xhr.readyState === 4 &amp;&amp; xhr.status === 0 ? (productData = xhr.responseText) : null; productData ? productData = JSON.parse(productData) : null; &#125; xhr.send(null); &#125;; //数据绑定:基于ES6模板字符串 let bindHTML = function () &#123; let str = ``; productData.forEach((&#123; time, price, hot, title, img &#125;, index) =&gt; &#123; //$&#123;&#125;里面放的是JS代码，包含需要动态绑定的数据的JS变量的值 str += `&lt;li data-time='$&#123;time&#125;' data-price='$&#123;price&#125;' data-hot='$&#123;hot&#125;'&gt; &lt;a href=\"javascript:;\"&gt; &lt;img src=\"../SHOP/$&#123;img&#125;\" alt=\"\"&gt; &lt;p title=\"$&#123;title&#125;\"&gt;$&#123;title&#125;&lt;/p&gt; &lt;span&gt;￥$&#123;price&#125;&lt;/span&gt; &lt;span&gt;时间：$&#123;time&#125;&lt;/span&gt; &lt;span&gt;热度：$&#123;hot&#125;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;`; &#125;); productBox.innerHTML = str; productList=productBox.querySelectorAll('li'); &#125;; // 绑定点击事件 let bindClick=function()&#123; //给三个排序标签绑定点击事件 [].forEach.call(linkList,(curLink,index)=&gt;&#123; //循环三次，执行三次click方法，每次执行都会形成一个闭包，每一个闭包中都保存了当前这个A对应的索引index curLink.flag=-1; curLink.onclick=function()&#123; this.flag *= -1; // 给product-List进行排序（依据点击列的不同） // 点击的时候需要获取每一个li的时间/价格/热度，此时我们可以在绑定的时候，把这些信息存储到自定义属性上，点击的时候根据自定义属性排序 let ary=['data-time','data-price','data-hot']; // 根据点击的li的索引获取按照谁来排序 productAry=[].slice.call(productList); productAry.sort((a,b)=&gt;&#123; let aInn=a.getAttribute(ary[index]), bInn=b.getAttribute(ary[index]); index===0?(aInn=aInn.replace(/-/g,''),bInn=bInn.replace(/-/g,'')):null; return (aInn-bInn) *this.flag ; &#125;); //按照最新顺序依次添加到容器当中 productAry.forEach(curLi=&gt;&#123; productBox.appendChild(curLi); &#125;) &#125; &#125;); &#125; // return &#123; init: function () &#123; //当前模块的入口，想要实现完整的业务逻辑，我们执行init即可， //在Init中，我们根据具体的业务需求，规划哪些方法先执行，哪些方法后执行， //init相当于当前模块的指挥官 getData(); bindHTML(); bindClick(); &#125; &#125;&#125;)();productRender.init();/* forEach:数组中的方法，用来遍历数组中的每一项内容 */let ary = [12, 23, 34];ary.forEach((item, index) =&gt; &#123; //item：当前遍历的值； index:当前遍历的索引 //数组中有多少项，我们这个函数就被执行多少次，保证数组中的每一项都可以得到遍历 console.log(item, index);&#125;) 性能优化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /** * 1 字符串拼接 * -&gt;普通字符串拼接 * -&gt;ES6模板字符串 * -&gt;模板引擎 * 2 DOM操作 */let data = [ &#123; \"id\": 1, \"title\": \"HUAWEI Mate 10 4GB+64GB 全网通版（亮黑色）\", \"price\": 3899, \"time\": \"2017-03-15\", \"hot\": 198, \"img\": \"img/1.jpg\" &#125;];/* data.forEach((item,index) =&gt;&#123; //动态创建DOM（外层容器基于create-element完成，容器中的具体内容可以基于创建DOM完成，也可以基于字符串拼接完成） let curLi=document.createElement('li'); curLi.innerHTML=`&lt;li&gt; &lt;a href=\"javascript:;\"&gt; &lt;img src=\"../SHOP/img/1.jpg\" alt=\"\"&gt; &lt;p title=\"来的感觉的管理法规和；国家宏观\"&gt;来的感觉的管理法规和；国家宏观&lt;/p&gt; &lt;span&gt;￥4888&lt;/span&gt; &lt;span&gt;时间：2014-01-01&lt;/span&gt; &lt;span&gt;热度：999&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;`; document.querySelector('.productBox').appendChild(curLi); // 之所以不建议使用这种方式，因为循环十次，每一次都改变了DOM结构，引发浏览器的十次回流 避免循环创建DOM &#125;); *///基于文档碎片（虚拟内存中开辟的一个容器）可以解决这个问题：每创建一个li，我们首先把它存放到文档碎片中（千万不要放到页面中，// 避免回流），当我们把需要的元素都创建完成，并且都添加到文档碎片中，在统一把文档随便存放到页面中（只引发一次回流操作）let frg=document.createDocumentFragment();//创建文档碎片容器data.forEach((item, index) =&gt; &#123; let curLi = document.createElement('li'); curLi.innerHTML = `&lt;li&gt; &lt;a href=\"javascript:;\"&gt; &lt;img src=\"../SHOP/img/1.jpg\" alt=\"\"&gt; &lt;p title=\"来的感觉的管理法规和；国家宏观\"&gt;来的感觉的管理法规和；国家宏观&lt;/p&gt; &lt;span&gt;￥4888&lt;/span&gt; &lt;span&gt;时间：2014-01-01&lt;/span&gt; &lt;span&gt;热度：999&lt;/span&gt; &lt;/a&gt;&lt;/li&gt;`; frg.appendChild(curLi);// 每一次把创建的li存放到文档碎片中 &#125;);document.querySelector('.productBox').appendChild(frg);frg=null; 1234567let frg=document.createDocumentFragment(); productAry.forEach(curLi=&gt;&#123; frg.appendChild(curLi); &#125;) productBox.appendChild(frg); frg=null; 123456789101112131415161718192021222324252627282930313233343536373839 /** * DOM的回流(reflow)和重绘(repaint) * * 1. 计算DOM结构（DOM树）； * 2. 加载CSS * 3. 生成渲染树(RENDER TREE):渲染树是和样式相关的 * 4. 浏览器基于GPU开始按照RENDER TREE画页面 * * 重绘：当某一个DOM元素样式更改(位置没变，只是样式更改，例如：颜色变为红色……)浏览器会重新渲染这个元素 * box.style.color='red'; * box.style.fontSize='16px' * 上面的操作触发了两次重绘，性能上有所消耗，真实项目中为了优化这个性能，我们最好一次性把需要的样式搞定，例如 * .xxx&#123; * color:'red'; * font-size:16px; * &#125; * box.className='xxx'; * * 回流：当DOM元素的结构或者位置发生改变（删除或增加元素，改变位置，改变大小……）都会引发回流 * 所谓回流，就是浏览器抛弃原有计算的结构和样式，重新计算DOM TREE和RENDER TREE，非常非常。。。消耗性能 *//** * * 字符串拼接只引发一次回流， +str 把原有容器中的结构都已字符串的方式获取到，然后和新的str字符串拼接，最后统一再插入到原有的 * 容器中 =str用新的字符串替换原有的结构 * 这种方式并不如文档碎片，因为浏览器需要把字符串再转化成文档结构，但是因为字符串拼接简单，在实际项目中常用 *//** * 分离读写 ： 把所有读的操作放在一起，把所有写的操作放在一起 */box.style.top='100px'; //引发回流console.log(box.style.top); //100pxbox.style.left='100px'; // 再次引发回流//总共引发两次回流box.style.top='100px';box.style.left='100px'; // console.log(box.style.top); //100px//只引发一次回流，浏览器会把任务放在待办任务中，继续往下看，遇到写的操作时重绘","categories":[],"tags":[]},{"title":"Javascript基础知识之数组和字符串原型上的方法","slug":"数组方法","date":"2019-04-24T09:28:06.000Z","updated":"2020-05-21T09:29:34.628Z","comments":true,"path":"2019/04/24/数组方法/","link":"","permalink":"https://abluecup.github.io/2019/04/24/数组方法/","excerpt":"本篇补充了一些数组和字符串方法的介绍","text":"本篇补充了一些数组和字符串方法的介绍 数组方法map作用：生成一个新的数组参数：currentValue[,index[,array]]返回值：新的数组原有数组不改变1234567var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array &#125;[, thisArg])let _arr = arr.map(function(x,y,z)&#123; return x = x * 2;&#125;); filter作用：遍历数组，当数组中的当前值满足筛选条件的时候，返回给新数组参数：element[,index[,array]]返回值：新的数组原有数组不改变1234var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])let _arr = arr.filter((ele, index, array) =&gt; &#123; return ele &gt; 2 //返回的必须是布尔值，true时，当前值返回给新数组 &#125;); find作用：遍历数组，当数组中的当前值满足筛选条件的时候，返回当前值参数：element[,index[,array]]返回值：满足条件的项原有数组不改变1234const array1 = [5, 12, 8, 130, 44];const found = array1.find(element =&gt; element &gt; 10);console.log(found);// expected output: 12 every作用：测试一个数组内的所有元素是否都能通过某个指定函数的测试。参数：element[,index[,array]]返回值：布尔值原有数组不改变123456arr.every(callback[, thisArg])const isBelowThreshold = (currentValue) =&gt; currentValue &lt; 40;const array1 = [1, 30, 39, 29, 10, 41];console.log(array1.every(isBelowThreshold));// expected output: false some作用：测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。。参数：element[,index[,array]]返回值：Boolean类型的值原有数组不改变123456arr.some(callback(element[, index[, array]])[, thisArg])let arr = [1, 2, 3, 4]; let _b = arr.some((ele,index,arr)=&gt;&#123; return ele &gt; 3; &#125;); console.log(_b); //true reduce作用：对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。参数：element[,index[,array]]返回值：单个返回值原有数组不改变1234567891011arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])// accumulator 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue// currentValue 数组中正在处理的元素。// initialValue 设置累积值的初始值let arr = [1, 2, 3, 4]; let total = arr.reduce((result, curval)=&gt;&#123; result += curval; return result; &#125;,10);console.log(total); //20 fill作用：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。参数：element[,index[,array]]返回值：新数组原有数组改变12345arr.fill(value[, start[, end]])let arr = [1, 2, 3, 4]; arr.fill('值',2,3); console.log(arr); // [1, 2, \"值\", 4] includes作用：数组是否包含某个值参数：特定值返回值：布尔值原有数组不改变 isArray作用：是否是数组参数：某个值返回值：布尔值原有数组不改变 Array.of();作用：方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。参数：某个或者某些值返回值：新数组12345Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7) //// [ , , , , , , ] 创建长度为7的数组，元素为空，而不是undefinedArray(1, 2, 3); // [1, 2, 3] flatIE不支持作用：会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。参数：某个值返回值：新的数组原有数组不改变123456789101112131415161718192021222324var newArray = arr.flat([depth])var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4]var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]]var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6]//使用 Infinity，可展开任意深度的嵌套数组var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];arr4.flat(Infinity);// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]flat会移除空元素var arr4 = [1, 2, , 4, 5];arr4.flat();// [1, 2, 4, 5][].contact(1,2) // [1,2], 字符串方法concat 语法str.concat(string2, string3[, …, stringN])，拼接成新的字符串startWidth 以xx为开头， true| falseendsWith 以xx为结尾，返回true | false includes includes() 方法用于判断一个字符串是否包含另一个字符串，根据情况返回 true 或 false。 str.includes(searchString[, position])1234567let str = 'hello';str.includes('hello, world'); // falsestr.includes('hell'); // truestr.includes('Hell'); // false 严格区分大小写 match 返回一个字符串匹配正则表达式的的结果 str.match(regexp) matchAll 返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器12345678910let regexp = /t(e)(st(\\d?))/g;let str = 'test1test2';let array = [...str.matchAll(regexp)];console.log(array[0]);// expected output: Array [\"test1\", \"e\", \"st1\", \"1\"]console.log(array[1]);// expected output: Array [\"test2\", \"e\", \"st2\", \"2\"] trim 删除两边的空格trimLeft, trimRight 删除左边的，右边的空格","categories":[],"tags":[]},{"title":"Javascript基础知识三","slug":"Javascript基础知识三","date":"2019-04-18T08:15:30.000Z","updated":"2019-06-27T09:36:58.665Z","comments":true,"path":"2019/04/18/Javascript基础知识三/","link":"","permalink":"https://abluecup.github.io/2019/04/18/Javascript基础知识三/","excerpt":"本篇介绍了js底层机制和一些经典的面试题","text":"本篇介绍了js底层机制和一些经典的面试题 js底层机制经典面试题1234567891011121314151617181920212223242526272829303132333435/* * 函数有三种角色： * 1 普通函数 堆栈内存释放 作用域链 * 2 类 prototype ： 原型 _proto_ : 原型链 实例 * 3 普通对象 和普通的obj没啥区别，就是对键值对的增删改查 * 三种角色之前没有必然的关系 */function Fn() &#123; var n = 10; this.m = 100;&#125;Fn.prototype.aa = function () &#123; console.log('aa');&#125;Fn.bb = function () &#123; console.log('bb');&#125;// 普通函数执行Fn(); // this:window,有一个私有变量n,和原型以及属性bb没有关系// 构造函数执行var f = new Fn();console.log(f.n); // undefined;console.log(f.m); // 100f.aa(); // 'aa' 实例通过_proto_找到Fn.prototype上的方法aaconsole.log(f.bb); // undefined, bb是把Fn当作一个普通对象设置的属性，和实例没有关系// Fn作为一个对象，只跟bb有关系 12345678910111213// JQ这个类库提供了很多的方法，其中有一部分是卸载原型上的，有一部分是把它当作普通对象处理的~ function () &#123; function jQuery() &#123; // return [JQ实例] &#125; jQuery.prototype.animate = function () &#123;&#125;； jQuery.ajax = function () &#123;&#125;; window..jQuery = window.$ = jQuery;&#125;()$().ajax(); // 无法调取，ajax是jq的私有属性 $.ajax(); 直接的对象键值对操作$().animate(); // 可以调取，原型上的方法 $.animate():无法执行，对象上没有animate这个属性 123456789101112131415161718192021222324252627282930function Foo() &#123; getName = function () &#123; console.log(1); &#125; return this;&#125;;Foo.getName = function () &#123; console.log(2);&#125;Foo.prototype.getName = function () &#123; console.log(3);&#125;;var getName = function () &#123; console.log(4);&#125;;function getName() &#123; console.log(5);&#125;Foo.getName(); // 2 把Foo当作一个对象，找Foo对象下的getName属性getName(); // 4 全局下的getName函数Foo().getName(); // 1 //window.getName(); 先把Foo当作普通函数执行，把执行返回的结果再调取getName方法getName(); // 1new Foo.getName(); // 2 A: Foo.getName , new Anew Foo().getName(); // 3 B: new Foo(), B.getName();new new Foo().getName(); // 3 C: new Foo(), D:C.getName(), new D// 优先级 . = new Fn() &gt; new Fn; 同级别从左到右// Foo -&gt; aaff00 函数代码, getName = aaff11 （4） 只要是函数，不管是啥类，永远都是内置类Function的实例函数的proto 指向 Function.prototype Object.proto 指向 Function.prototypeFunction.prototype.proto 指向 Object.prototype Function.prototype === Function.proto // true Function也是函数，它的proto指向所属类Function的原型Function.prototypeObject.prototype.hasOwnProperty == Object.proto.proto.hasOwnProperty call, apply, bind用来改变某一个函数中this关键字指向 call12345678910111213141516171819202122232425262728293031323334353637383940window.name = \"kyle\";let fn = function () &#123; console.log(this.name);&#125;;let obj = &#123; name: 'OBJ', fn: fn&#125;;let oo = &#123; name: 'oo'&#125;;/* * 1. [fn].call([this],[param]...) * fn.call:当前实例fn通过原型链的查找机制找到Function.prototype上的call方法 =&gt; function call()&#123;[native code]&#125; * fn.call()把找到的call方法执行 * 当call方法执行的时候，内部处理了一些事情 * =&gt; 首先把要操作的函数中的this关键字变为call方法传递的第一个实参值 * =&gt; 把call方法第二个及以后的实参获取到 * =&gt; 把第二个以后传递进来的实参传给操作的函数,把要操作的函数执行 */// call 中的this指向的是函数，this执行即函数执行，如果没有传参，call中的this就是指向fn,直接执行fn即可，如果传参，就要// 调用call执行的是call中的this,fn.call(oo); // this -&gt; oofn.call(obj); // this -&gt; OBJFunction.prototype.mycall = function () &#123; let param1 = arguments[0], paramOther = []; // 把arg中除了第一个以外的方法获取到 // this:fn 当前要操作的函数(函数类的一个实例) // 把fn中的this关键字修改为param1 =&gt; 把this(call中)中的this关键字修改为param1 // 把fn执行，把paramOther分别传递给fn =&gt; this(paramOther) this(paramOther) &#125;fn.mycall();sum.call.call(opt);// 1 sum.call 找到Function.prototype上的call方法（也是一个函数，是函数类的实例，可以继续调用call/apply等方法）sum.call = A// 2 A.call(opt), 继续找原型上的call方法，把call方法执行，把A中的this关键字修改为opt,把A执行// 3 1234567891011121314151617181920212223242526272829function fn1()&#123;console.log(1)&#125;;function fn2()&#123;console.log(2)&#125;;fn1.call(fn2); // call中的this是fn1, fn1中没有this关键字，不做修改，然后执行this(fn1), 输出1fn1.call.call(fn2) // fn1.call.call中的this是fn1.call,第一个参数是fn2, fn1.call中的this修改为fn2,执行this(fn1.call)// call中的this,在上一步操作中已经被修改为fn2, fn2中没有this关键字，不做修改，直接执行this(fn2),输出 2Function.prototype.call(fn1);//// call方法执行， this 是 Function.prototype, 这是个匿名函数，匿名函数中的 this 被修改为 fn1, 执行匿名函数Function.prototype, 没有任何输出Function.prototype.call.call(fn1);// call 方法执行， this 是 Function.prototype.call函数，第一个参数fn1, 将Function.prototype.call函数中的this修改成fn1, 后面没有参数，执行Function.prototype.call()函数，这个函数中的this已经被修改为fn1, 而不是Function.prototype,执行this就是执行fn1,输出1Function.prototype.call.call.call.call.call(fn2);// call方法第一次执行，前面的call函数中的this被修改为fn2,执行前面的call函数，没有参数，就没有this的修改，直接执行fn2,输出2；执行前面的call函数，没有参数，this是前面的..call,没有任何输出，直到执行匿名函数Function.prototype为止，都没有任何输出fn1.call.call.call.call.call(fn2);// 结果也是只输出fn2fn.call(10,20); // this:Number&#123;10&#125;, a:20, b:undefined;fn.call();// this:window;fn.call(null);// this:window;fn.call(undefined);// this:window;/** call中的细节* 1,非严格模式下，如果参数不传，或者第一个传递的是null / undefined,this都指向window;* 2,在严格模式下，第一个参数是谁，this就指向谁(包括null和undefined),不传，this是undefined;*/ apply12345/** 和call基本上一样，唯一区别在于传参方式* fn.call(obj,10,20);* fn.apply(obj,[10,20]); apply把需要传递给fn的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给fn一个个传递*/ bind1234567891011121314151617/* * bind:语法和call一模一样，唯一的区别在于立即执行还是等待执行 * fn.call(obj,10,20) 改变fn中的this，并且把fn立即执行 * fn.bind(obj,10,20) 改变fn中的this,此时fn并没有执行，不兼容IE6-8 */'use strict';let fn = function (a, b) &#123; console.log(this, a, b);&#125;let obj = &#123; name: 'OBJ'&#125;;//document.onclick = fn; //把fn绑定给点击事件，点击的时候执行fn;//document.onclick=fn();// 绑定的时候，先执行fn,把执行的返回值返回给点击事件，当点击的时候执行的是undefined// document.onclick = fn.call(obj); 虽然把this修改为obj了，但是绑定的时候就把fn执行了(call是立即执行函数)，点击的时候执行的是fn的返回值document.onclick = fn.bind(obj, 10, 20); // bind属于把fn中的this预处理为obj,当点击的时候才会执行fn 应用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 需求一：获取数组中的最大值（最小值） */let ary = [12, 23, 14, 23, 24, 13, 15, 12];/*1,给数组由大到小排序**//*let max = ary.sort(function (a, b) &#123; return b - a;&#125;)[0];let min = ary[ary.length - 1];console.log(max, min);*//*2,假设法：假设第一个值是最大值，依次遍历数组中后面的每一项，和假设的值进行比较，如果比假设的值大，把当前项赋值给max**//*let max = ary[0];let min = ary[0];for (let i = 1; i &lt; ary.length; i++) &#123; max - ary[i] &lt; 0 ? (max = ary[i]) : null; min - ary[i] &gt; 0 ? (min = ary[i]) : null;&#125;console.log(max, min);*//*3,基于Math.max,apply**/// 利用了apply的一个特征，虽然方的是一个数组，但是执行方法的时候，也是把数组中的每一项一个个的传递给函数let max = Math.max.apply(null, ary);console.log(max);let min = Math.min.apply(null, ary);console.log(min);/* 基于Math.max, eval * 4, eval: 不能使用Math.max(eval(ary.toString()));因为括号表达式自身的执行机制，原因如下 [12,23,34].toString() * 2,括号表达式：用小括号包起来，里面有很多项，每一项用逗号分隔，最后值获取最后一项的内容，但是会把其他的项也过一遍 * (function () &#123; * console.log(1) * &#125;, function () &#123; * console.log(2) * &#125;)(); * 不建议过多使用括号表达式，因为会改变this *//*let fn = function () &#123; console.log(this);&#125;;let obj = &#123; fn: fn&#125;;(fn, obj.fn)(); // 执行的是obj.fn，当时方法中的this是window而不是obj(obj.fn)(); // this是obj*//*let max = eval(\"Math.max(\" + ary.toString() + \")\");let min = eval(\"Math.min(\" + ary.toString() + \")\");console.log(max, min);*/ 1234//上述需求一的最优解，...是ES6中的let max = Math.max(...ary), min = Math.min(...ary);console.log(max, min); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* * 解构赋值：按照一个数据值的结构，快速解析获取到其中的内容 * 1. 真实项目中一般都是针对于数组或者对象进行解构赋值； *///===========数组解构赋值let ary = [12, 23, 34];/*let [a, b, c] = ary; // 让等号左边出现和右边相同的数据结构，左边可以创建一些变量快速获取到右侧对应位置的值（解构赋值）；console.log(a, b, c);let [d] = ary;console.log(d); //12let [, , e] = ary;console.log(e); //34let [f, , g] = ary;console.log(f, g);*//*//获取第一项，把剩下的项作为数组返回let [a, ...b] = ary; // ...在此处称之为剩余运算符：除了前面以外的项都放在一个数组当中console.log(a, b);let [a, ...b,c] = ary; //这样会报错，因为剩余运算符必须放在解构位置中的最后*/let ary2 = [12];let [a, b = 0] = ary2; //结构的时候可以给变量设置默认值：如果当前变量对应结构中的这一项没有值，变量使用默认值console.log(a, b);// 交换值let a = 12, b = 13;//=&gt;a,b交换值[a, b] = [b, a];console.log(a, b);//============对象解构赋值let obj = &#123; name: 'xxx', age: 25, sex: 0&#125;;/*let &#123; name, age&#125; = obj; //对象结构赋值默认情况下要求：左侧变量名和对象中的属性名一致才可以console.log(name, age);let &#123; sex&#125; = obj;console.log(sex);*/// let &#123; name: nameAA // 给解构的属性名起别名作为我们使用的变量&#125; = obj;console.log(nameAA);let &#123; friend: friendAA = 0 // 给不存在的值设置默认值&#125; = obj;console.log(friendAA);console.log(friend); // 报错：obj中没有这个属性名//常用赋值方法let fn = function (&#123; name = 'kyle', age = 0&#125; = &#123;&#125;) &#123; // 把传递的对象解构了,设置默认值是&#123;&#125;:现在传递对象或者不传递，形参接收到的都是对象 //结构的时候可以把传递进来的对象中，如果某个属性不存在，我们赋值默认值 console.log(name, age);&#125;;fn(); //kyle 0fn(&#123; name: 'picapoon', age: 28&#125;); // picapoon 28// 应用：let value = &#123; name: 'xxx', age: 25, score: [12, 23, 34, 45]&#125;;// a=xxx,b=12,c=[23,34,45]let &#123; name: a, score: [b, ...c]&#125; = value;console.log(a, b, c); 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * \"...\"在ES6中有三种含义 * 1. 剩余运算符 * 2. 拓展运算符 * 3. 展开运算符 : 把数组（或者对象，类数组）中的每一项展开 *//*let ary = [12, 23, 34];let [...arg] = ary; // ary.slice(0);function fn(context, ...arg) &#123; //获取传递值中的第一个和剩下的 console.log(context, arg); //arg是一个数组格式的，aruments是一个类数组&#125;let obj = &#123; name: 'xxx'&#125;;fn(obj, 10, 20, 30, 40);*/function sum(...arg) &#123; //传递几个实参，arg中就存储多少个，此时arg和arguments是一样的，区别是arg是一个数组，arguments是一个类数组 return arg.join('+');&#125;;//console.log(sum([1, 2, 3, 4, 5]));//展开运算符let ary = [12, 23, 34];Math.max(...ary); // Math.max(12,23,34);let fn = function (a, b, c) &#123; console.log(a, b, c);&#125;fn(ary); // [12,23,34],undefined,undefinedfn(...ary); //12,23,34 把数组中的每一项分别传递给一个函数，此时我们使用展开运算符即可；let obj = &#123; name: 'xxx', age: 20&#125;;let newObj = &#123; //对象的克隆， ...obj, //原有对象展开，即克隆到新的对象上 sex: 0&#125;;//数组的展开let ary0 = [12, 23];let newAry = [...ary0, 100]; //[12,23,100] 类数组转化为数组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 编写一个方法fn，实现任意数求平均值（去除数字中最大值和最小值，然后再算平均值，保留小数点后两位） */let fn = function () &#123; // arguments是类数组，不能执行数组原型上的方法 //1.先给arguments排序（不能直接使用sort方法），把排序后的值去掉首尾， //2.把剩下的值求和除以总长度 //类数组转化为数组 (把类数组克隆一份一模一样 的，最后存储到数组中)，数组的slice可以实现克隆 /* let ary=[]; for (let i = 0; i &lt; arguments.length; i++) &#123; ary.push(arguments[i]); &#125;; */ // 如果我们把内置的slice执行，并且让方法中的this指向arguments,就相当于把arg转换为数组 // Array.prototype.slice()或者[].slice() //类数组借用数组原型上的方法执行实现相关的操作：先找到数组原型上的slice方法，调用call方法，修改this为argumens, 类数组和数组类似，都有length和索引 let ary=[].slice.call(arguments); ary.sort(function (a, b) &#123; return a - b; &#125;); ary.pop(); ary.shift(); /* let total=0; for (let i = 0; i &lt; ary.length; i++) &#123; total = total+ ary[i]; &#125; */ let total = eval(ary.join(\"+\")); return (total / ary.length).toFixed(2);&#125;;console.log(fn(10, 9.8, 9.5, 8.7, 8.8, 8, 9.2,8.9));// 重写slice方法，实现： ary.slice(0),相当于把ary克隆一份新数据let ary = [12, 23, 34];Array.prototype.myslice = function () &#123; let ary = []; for (let i = 0; i &lt; this.length; i++) &#123; ary[i] = this[i]; &#125; return ary;&#125;console.log(ary.myslice());// 字符串转化为数组的方法有两种，一是split,一是[].slice.callconsole.log(\"yuihdgrg\".split(''));console.log([].slice.call('yuijok')); 箭头函数12345678910111213141516171819202122232425262728293031323334353637let fn=(x,y)=&gt;&#123;&#125;let fn=x=&gt;&#123;//只有一个参数，可以省略小括号&#125;function fn(x,y)&#123; return x+y;&#125;let fn=(x=0,y=0)=&gt;x+y // 如果当前函数体中只有一句操作，并且是RETURN的，可以省略大括号（可以给形参设置默认值）let fn=x=&gt;y=&gt;x+yfunctiion fn(x)&#123; return function(y)&#123; return x+y; &#125;&#125;// 箭头函数中没有arguments，但是可以使用剩余运算符代替，而且arg是数组，更便于使用let fn=(..arg)=&gt;&#123;&#125;// 箭头函数中没有自己的执行主体this,它的this都是继承上下文中的thislet obj=&#123; fn:(function()&#123; // this -&gt; window let _this =this, _this只是一个 return function()&#123; console.log(this); // console.log(_this) _this不是执行主体，而是一个变量，不是私有的，需要向上级作用域查找 &#125; &#125;)()&#125;let obj=&#123; fn:(function()&#123; return ()=&gt;&#123; console.log(this); // 箭头函数执行和是否有点，点前面是谁没有关系，因为它没有自己的执行主体，在箭头函数中使用到的this都是直接找上下文中的this来使用 &#125; &#125;)();&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://abluecup.github.io/tags/javascript/"}]},{"title":"Javascript基础知识二","slug":"Javascript基础知识二","date":"2019-04-02T03:24:01.000Z","updated":"2020-05-20T10:06:07.196Z","comments":true,"path":"2019/04/02/Javascript基础知识二/","link":"","permalink":"https://abluecup.github.io/2019/04/02/Javascript基础知识二/","excerpt":"本篇主要介绍的是变量的提升机制、面向对象、原型链等内容","text":"本篇主要介绍的是变量的提升机制、面向对象、原型链等内容 变量提升机制123456789101112/** 一般都把js放到body的末尾1.为啥？等待DOM加载完成后再执行2.放在head中可不可以，如何放到head中也可以实现放到body末尾的效果代码放在window.onload事件中使用defer3.script标签中有两个属性，defer / async, 这两个属性是做什么的defer时立即加载，完成后暂缓执行async时异步加载，完成后立即执行可以实现JS放在head中但是最后执行，但是兼容性不好，一般我们还是放在body末尾最好*/ 栈内存：作用域， 1. 提供供JS代码自上而下执行的环境（代码都是在栈中执行）； 2. 由于基本类型值比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存储进去； =&gt; 当栈内存被销毁，存储的那些基本值也随之而销毁； 堆内存：引用值对应的空间 存储引用类型值（对象：键值对；函数：代码字符串;） =&gt; 当前堆内存销毁，那么引用值彻底没了 =&gt; 堆内存的释放： 当堆内存没有被任何的变量或者其他东西所占用，浏览器会在空闲的时候，自主进行内存回收，把所有不被占用的内存销毁掉。（webkit内核浏览器） xxx = null;通过空对象指针null可以让原始变量或者其他东西谁都不指向，原先被占用的堆内存就没有被东西占用了，浏览器会销毁它。 12var ary1 =[1,2,4];ary1= null; // 释放堆内存 概念：当栈内存（作用域）形成，JS自上而下执行之前，浏览器首先会把所有带var / function关键字的进行提前的声明或者定义，这种预先处理机制称之为变量提升； 声明： declare // var a ;function aa; (默认值undefined) 定义： defined a=12; (定义就是赋值) =&gt; 带var的只声明，未定义；带function的声明和赋值都完成了；变量提升只发生在当前作用域在全局作用域下声明的变量是全局变量，在私有作用域下声明的变量是私有变量 （带 var , function 的才是声明）浏览器很懒，做过的事情不会重复第二遍，即当代码执行遇到创建函数这部分代码的时候，直接跳过（在变量提升阶段，已经完成函数的赋值操作） 在ES3或者ES5语法规范中，只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存 带var 和不带var 的区别123456console.log(a);'a' in window; // in 用来检测属性是否隶属于对象var a=12;console.log(a);console.log(window.a); // window对象的一个属性 在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性的值；私有作用域下声明的私有变量和window没啥关系；全局变量和win中的属性存在映射机制； 12345678910// 不加var,本质是window下的属性，不存在变量提升机制； 加var，本质是变量，存在变量提升机制console.log(a); // Uncaught ReferenceError: a is not defined 按照变量的机制处理，且window下并没有window.a的属性console.log('a' in window);//false undefined, 对象没有这个属性，打印undefinedconsole.log(window.a); // undefineda=12;// window.a=12的简写；console.log(a); //12， 不存在变量a,但是window对象下有a属性console.log(window.a); //12， var a = b =12; // 这样写b是不带var的；var a = 12, b=12;// 这样写，b是带var的； 12345678910111213141516console.log(a,b); // undefined, undefined;var a=12,b=12;function fn()&#123; /** 私有作用域下，带var不带var也有区别 带var的在私有作用域变量提升阶段，都声明为私有变量，和外界没有任何关系； 不带var的不是私有变量，会向上级查找，看是否为上级的变量，不是，继续向上查找，一直找到window为止； 我们把这种查找机制叫做作用域链；也就是我们在私有作用域中操作的这个非私有变量，是一直操作的别人的； */ console.log(a,b); // 形成一个私有作用域，变量提升， a=undefined, b =window.b =12; var a = b=13; // window.b被修改为13 console.log(a,b); //私有作用域 13 ,13&#125; // 跳过函数创建的代码，继续执行fn();console.log(a,b); // 12 ， 13// 被覆盖了 作用域链12345678console.log(b); // 报错function fn()&#123; console.log(b); b=13; console.log(b); // 13&#125;fn();console.log(b); //13 1.变量提升（没有）2.执行fn,没有变量提升；b在fn和window下都没有；在作用域查找的过程中，如果找到win也没有这个变量，相当于给win设置了一个属性b window.b=13; 只对等号左边进行变量提升12345678910111213141516fn(); // fn is not a function fn此时是undefined,不是函数sum(); // 2 普通函数在变量提升阶段已经声明且赋值// 匿名函数之函数表达式var fn = function()&#123; console.log('1'); &#125;// 普通函数function sum()&#123; console.log(2);&#125;;fn(); // 1 当代码执行到这一行的时候，会把函数赋值给fnsum(); // 2 真实项目中，常常采用函数表达式这种方式 条件判断下的变量提升123456789 //在当前作用域中，不管条件是否成立都要进行变量的提升 // 带var的还是只声明 // 带function的在老版本浏览器渲染机制下，声明+定义都处理，但是为了迎合ES6中的块级作用域，新版本浏览器对于函数（在条件判断中的函数），不管条件是否成立，都只是先声明，没有定义，类似于var console.log(a); // undefinedif('a' in window)&#123; var a =100; &#125;console.log(a); // 100 12345678910111213141516171819202122 f = function() &#123; return true &#125;; g = function() &#123; return false &#125;; ~ function() &#123; if (g() &amp;&amp; [] == ![]) &#123; // Uncaught typeError: g is not a function// 新版本浏览器中只声明，未赋值，g=undefined, undefined不是函数，报错；老版本浏览器中g() = true; f = function() &#123; return false &#125;; function g() &#123; return true; &#125;; &#125; &#125;(); console.log(f()); console.log(g()); 同名问题处理1234567891011121314151617181920212223242526272829303132/* * 1.带var和function关键字声明相同的名字，这种也算是重名了（其实是一个FN，只是存储的值不同） */ /* * 2. 关于重名的处理：如果名字重复了，不会重新的声明，但是是会重新的定义：（重新赋值）【不管是变量提升还是代码执行阶段皆是如此】 */ /* *变量提升： fn = ...(1) = ...(2) =...(3) =...(4) */ function fn() &#123; console.log(1); &#125; fn(); // 4 function fn() &#123; console.log(2); &#125; fn(); // 4 var fn = 100; // 带var的在变量提升阶段只是把声明处理了，没有执行赋值操作，所以在代码执行的时候需要完成赋值； fn(); // Uncaught TypeError: fn is not a function; function fn() &#123; console.log(3); &#125; fn(); function fn() &#123; console.log(4); &#125; fn(); let创建的变量不存在变量提升 在ES6中基于let或const创建变量或者函数，不存在变量提升机制, 且切断了全局变量和window属性的映射机制； 在同一个作用域中，基于let不能声明相同的变量； 浏览器在作用域形成之后，执行代码之前，会有一个变量查重机制（语法检测）,发现有重复声明的变量,报错 Uncaught SyntaxError虽然没有把变量提前声明定义，但是浏览器已经记住了，当前作用域下有哪些变量;不管用什么方式，在当前作用域下声明了变量，再次使用let创建都会报错。 123456b =12; // window.b=12console.log(b);a=12; // console.log(a); //Uncaught ReferenceError: a is not definedlet a = 12;console.log(window.a); // undefined ES6 JS中暂时性死区问题12345678910var b = 12;if (true) &#123; console.log(b); // Uncaught ReferenceError: a is not defined let b = 13; // 基于let创建变量，会把大部分&#123;&#125;当成一个私有的块级作用域（类似于函数的私有作用域），在这里也是重新检测语法规范，看一下是否是基于新语法创建的变量，如果是按照新语法来解析&#125;console.log(typeof a);// 在原有浏览器的渲染机制下，基于typeof等逻辑运算符检测一个违背声明过得变量，不会报错，返回undefined console.log(typeof c); // Uncaught ReferenceErrorlet c; //如果当前变量是基于ES6语法处理，在没有声明这个变量的时候，使用TYPEOF检测，会直接报错，不会是undefined,解决了原有的暂时性死区问题 闭包作用域(scope)123456789101112131415var a = 12, b = 13, c = 14;function fn(a) &#123; // 形成作用域后，变量提升前，需要做形参赋值 a =12; // 在私有作用域中，只有以下两种情况是私有变量 A: 声明过的变量 ；B:形参也是私有变量； // 剩下的都不是自己私有的变量，都需要基于作用域链的机制向上查找 console.log(a, b, c); // 12 undefined 14 var b = c = a = 20; // var b=20; c=20;a=20; console.log(a, b, c); // 20,20,20&#125;fn(a); // 执行fn(小括号中是实参：值) -&gt; 执行fn把全局变量a的值12当作实参传递给函数的形参 =&gt; fn(12)console.log(a, b, c); //12,13,20 123456789101112131415// [12,23] -&gt; [100,23] var ary = [12, 23]; function fn(ary) &#123; // 形参赋值赋的是引用地址 // ary = [12,23] console.log(ary); // [12,23] ary[0] = 100; //[100,23] 修改了应用地址中的数据 ary = [100]; // 修改了引用地址 ary[0] = 0; console.log(ary); // [0] &#125; fn(ary); console.log(ary); // [100,23] 查找上级作用域123456789101112131415// 当前函数执行，形成呢个一个私有作用域A，A的上级作用域是谁，和他在哪执行的没有关系，和他在哪创建的有关系，在哪创建的，他的上级作用域就是谁。var a = 12;function fn() &#123; // arguments.callee:函数本身 // arguments.callee.caller: 当前函数在哪执行的caller就是谁（记录的是他的宿主环境）;在全局下执行是null console.log(arguments.callee);&#125;function sum() &#123; var a = 120; fn();&#125;sum(); // 1234567891011121314151617// 当前函数执行，形成呢个一个私有作用域A，A的上级作用域是谁，和他在哪执行的没有关系，和他在哪创建的有关系，在哪创建的，他的上级作用域就是谁。var n = 10;function fn() &#123; var n = 20; function f() &#123; n++; console.log(n); &#125; f(); return f;&#125;var x = fn();x();x();console.log(n); 堆栈内存释放JS中的内存分为堆内存和栈内存堆内存：存储引用类型数据（对象：键值对 函数：代码字符串）栈内存：提供JS代码执行的环境和存储基本类型值 【堆内存释放】 让所有引用堆内存地址的变量赋值为null即可（没有变量占用这个堆内存了）浏览器会在空闲的时候把它释放掉 【栈内存释放】 一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉，但是也有特殊不销毁的存在： 1. 函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放，一旦释放，外面的变量找不到原有的内容了 2. 全局栈内存只有在页面关闭的时候才会被释放掉 如果当前内存没有被释放，那么之前在栈内存中能够存储的基本值也不会被释放，能够一直保存下来。 12345678910111213141516171819var i = 1;function fn(i) &#123; //var i=2; return function(n) &#123; console.log(n + (++i)); &#125;&#125;var f = fn(2); // 先把fn执行，实参2，把fn执行的返回结果（return 后面的值）赋值给ff(3); // 返回的结果执行fn(5)(6); // 和上面两步类似，都是先执行fn,把fn的返回结果再执行fn(7)(8);f(4);// 6,12,16,8// i++ :自身+1 // ++i :自身+1// 区别是在和别人运算的时候，i++,先拿原有的值进行运算，运算结束后，本身累加1； ++i 先自身累加1，再拿累加后的结果进行运算 闭包的作用： 保护私有变量不受外界干扰；形成一个不受外界干扰的栈内存，保存内部的私有变量； 闭包【概念】： 函数执行，形成一个私有作用域，保护里面的私有变量不受外界的干扰，这种保护机制称为“闭包”； =&gt; 市面上开发者认为的闭包：形成一个不销毁的私有栈内存（作用域）才是闭包 123456789101112// =&gt; 闭包：柯里化函数function fn()&#123; return function()&#123; &#125;&#125;var f=fn();//=&gt; 闭包：惰性函数var utils = (function()&#123; return &#123;&#125;&#125;)() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103 // 闭包项目实战应用 // 真实项目中为了保证JS的性能（对栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的） // 1.闭包具有保护作用：保护私有变量不受外界干扰 // 在真实项目中，尤其是团队协作开发中，应该尽可能的减少全局变量的使用， //以防止相互之间的冲突（“全局变量污染”），此时我们完全可以把这一部分内容封装到一个闭包中， //让全局变量转化为私有变量 (function() &#123; var n = 12; function fn() &#123; &#125; // ... &#125;)() // 不仅如此，我们封装类库的时候，也会把自己的程序都存放在闭包中保护起来， //防止和用户的程序冲突，但是我们又需要暴露一些方法给客户使用，这样我们如何处理呢 ？ // JQ这种方式，把需要暴露的方法抛到全局 (function() &#123; function jQuery() &#123; //... &#125; window.jQuery = window.$ = jQuery; // 把需要供外面使用的方法，通过给WIN设置属性的方式暴露出去； &#125;)() // zepto这种方式，基于return把需要供外面使用的方法暴露出去 var Zepto = (function()&#123; return &#123; xxx:function()&#123;&#125; &#125; &#125;)(); // 2.闭包具有保存作用：形成不销毁的栈内存，把一些值保存拿下来，方便后面的调取使用var oBox = document.getElementById('box'); var TabList = oBox.getElementsByTagName('li'); var divList = oBox.getElementsByTagName('div'); function changeTab(curIndex) &#123; for (var i = 0; i &lt; TabList.length; i++) &#123; TabList[i].className = ''; divList[i].className = ''; &#125; TabList[curIndex].className = 'active'; divList[curIndex].className = 'active'; &#125; /* for (var i = 0; i &lt; TabList.length; i++) &#123; (function(i) &#123; TabList[i].onclick = function() &#123; changeTab(i); &#125; &#125;)(i); &#125; changeTab(0);*/ // 执行方法：形成一个私有的栈内存，遇到变量I，I 不是私有变量，向上一级作用域查找（上级作用域window） changeTab(0); // 所有的绑定事件都是异步编程，（同步变成：一件事一件事做，当前这件事没完成，下一个任务不能处理； 异步编程：当前这件事件没有彻底完成，不再等待，继续执行下面的任务），绑定事件后，不需要等待执行，继续执行下一个循环任务，所以当我们点击执行方法的时候，循环早已经结束（全局的I是最后的循环结果） // 解决方案1：自定义属性 for (var i = 0; i &lt; TabList.length; i++) &#123; TabList[i].myIndex = i; TabList[i].onclick = function() &#123; changeTab(this.myIndex); //=&gt; this:给当前元素的某个事件绑定方法，当事件触发，方法执行的时候，方法中的this是当前操作的元素对象 &#125; &#125; // 解决方案2 闭包 /* for (var i = 0; i &lt; TabList.length; i++) &#123; TabList[i].onclick = (function(n) &#123; //让自执行函数执行，把执行的函数返回值赋值给onclick, //此处Onclick绑定的是返回的小函数,点击的时候执行的是小函数， //自执行函数在给事件赋值的时候就已经执行了 return function() &#123; changeTab(n); // 上级作用域：自执行函数执行的时候形成的作用域 &#125; &#125;)(i); // i:把本次全局变量i传递给内部函数的形参n &#125;*/ // 总结：循环三次，形成三个不销毁的私有作用域（），而每一个不销毁的栈内存中都存储了一个私有变量，形参n的值；点击的时候，执行返回的小函数，遇到变量n,就是上级作用域中的n // 基于ES6来执行 for (let i = 0; i &lt; TabList.length; i++) &#123; TabList[i].onclick = function() &#123; changeTab(i); &#125; &#125; // 基于ES6中的let来创建变量是存在块级作用域的（类似于私有作用域）； // 作用域： 栈内存 // 1全局作用域 // 2 私有作用域 （函数执行） // 3 块级作用域（一般用&#123;&#125;包起来的都是块级作用域，前提是ES6语法） /* &#123; let a = 1; console.log(a); // 1 &#125; // cosole.log(a); // 报错 for (let i = 0; i &lt; 5; i++) &#123; // 循环也是块级作用域，初始值设置的变量是当前本次会计作用域中的变量（形成了五个块级作用域） &#125; switch case // 块级作用域 let obj = &#123;&#125;; // =&gt; 对象不是块级作用域*/ 面向对象编程（OOP Object Oriented Programming）单例设计模式 singleton pattern12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 单例设计模式 * 1. 表现形式 * var obj=&#123;xxx:xxx,...&#125; * 在单例设计模式中，obj不仅仅是对象名，它被称为“命名空间”（NameSpace）, * 把描述事物的属性存放到命名空间中，多个命名空间是独立分开的，互不冲突。 * 2. 作用 * 把描述同一件事务的属性和特征进行“分组、归类”，（存储在不同堆内存中） * 因此避免了全局变量之间的冲突和污染 * 3.单例设计模式命名的由来：每一个命名空间都是JS中Object这个内置基类的实例， * 而实例之间是相互独立，互不干扰的，所以我们称之为单例（单独的实例） * *//* * 高级单例模式 * 1. 再给命名空间赋值的时候，不是直接赋值一个对象，而是先执行匿名函数， * 形成一个私有作用域（不销毁的栈内存），在这个私有作用域aa中创建一个堆内存， * 把堆内存的地址赋值给命名空间 * 2. 这种模式的好处：我们完全可以在AA中创造很多内容（变量or函数）， * 哪些需要供外面调取使用的，我们暴露到返回的对象中（模块化实现的一种思想） */var nameSpace = (function() &#123; function fn() &#123; &#125;; return &#123; fn: fn &#125;&#125;)();/* * this * 1，给当前元素的某个事件绑定方法，当事件触发方法执行的时候， * 方法中的this是当前操作的元素 * 2, 普通函数执行，函数中的this取决于执行的主体，谁执行的， * this就是谁（执行主体：方法执行看方法名前面是否有点,有的话， * 点前面是谁this就是谁，没有,this是window） * 3, 自执行函数执行，方法中的this是window */var n = 2;var obj = &#123; n: 3, fn: (function(n) &#123; n *= 2; var n = 5; this.n += 2; return function(m) &#123; this.n *= 2; //console.log(m++(++n)); console.log(m + (++n)); &#125; &#125;)(n) // 自执行函数执行的时候，堆内存的键值对还没有存储完，它和obj还没有关系，此时obj=undefined,obj.n会报错&#125;var fn = obj.fn;fn(3); // obj.fn(3);console.log(n, obj.n); 123456789101112131415161718192021222324252627282930313233343536/* * 模块化开发： * 1, 团队协作开发的时候，会把产品按照功能板块进行划分， * 每一个功能板块有专人负责开发; * 2, 把各个板块之间公用的部分进行提取分装， * 后期再想实现这些功能，直接调取引用即可（模块封装）; */var utils = (function() &#123; return &#123; aa: function() &#123;&#125;; &#125;;&#125;;)();var skipRender = (function() &#123; var fn = function() &#123; &#125;; return &#123; init: function() &#123; &#125;; &#125;;&#125;)();skipRender.init();var weatherRender = (function() &#123; var fn = function() &#123; &#125;; return &#123; initi: function() &#123; fn(); //调取自己模块中的方法，直接调取即可； skipRender.fn(); //调取别人模块中的方法 &#125;; &#125;;&#125;)(); 12345/* * 工厂模式(factory pattern)： * 1, 把实现相同功能的代码进行封装，以此来实现“批量生产”（后期要实现这个功能，我们只需要执行函数即可） * 2, 低耦合高内聚：减少页面中的冗余代码，提高代码的重复使用率 */ oop面向对象JS是一门编程语言，具有编程思想【面向对象】js/java/php/c#/ruby/python/c++【面向过程】c面向对象编程需要掌握：对象、类、实例的概念 对象万物及对象 类对象的具体细分（按照功能特点进行分类，有大类，也有小类） 实例类中具体的一个事物（拿出类别中的具体一个实例进行研究，那么当前类别下的其他势力也具备这些特点和特征）; 整个JS就是基于面向对象设计和开发的语言，我们学习和实战的时候，也要按照面向对象的思想去体会和理解； JS中的内置类Object: Number,String, Boolean,Null,Undefined,Array,Date,Rex,…,HTMLCollection,NodeList,EventTagert(node(Element,),…) JS中创建值的两种方式12345678910111213141516171819202122232425262728293031323334/* * 基于构造函数创建自定义类(constructor) * 1. 在普通函数执行的基础上\"new xxx()\",这样就不是普通函数执行了， * 而是构造函数执行，当前的函数名称之为“类名”， * 接收的返回结果是当前类的一个实例 * 2. 自己创建的类名，最好第一个单词首字母大写 * 3. 这种构造函数设计模式执行，主要用于组件、类库、插件、 * 框架等的封装，平时编写业务逻辑一般不这样处理 */function Fn() &#123;&#125;;Fn(); //普通函数执行var f = new Fn(); //=&gt; Fn是类，f是类的一个实例var f2 = new Fn(); // f2也是Fn的一个实例，f2和f是独立分开的，互不影响/* * JS中创建值有两种方式 * 1 字面量表达式 * 2 构造函数模式 */var obj = &#123;&#125;; // 字面量方式var obj = new Object(); //构造函数模式// 不管是哪一种方式，创造出来的都是Object类的实例，//而实例之间是独立分开的，所以var xxx=&#123;&#125;这种模式就是JS中的单例模式//基本数据类型值基于两种不同的方式创建出来的值是不一样的//基于字面量方式创建出来的是基本类型值，//基于构造函数创建出来的是引用类型值// num2是数字类Number的一个实例，num1也是数字类的实例，//它只是JS表达数字的方式之一，都可以使用数字类提供的属性和方法var num1 = 12; // 12 numbervar num2 = new Number(12); // Number&#123;12&#125; object 构造函数机制 细节12345678910111213141516171819202122232425function Fn() &#123; var n = 10; this.m = n; return '哈哈哈'; //这样执行，结束了代码执行，但是不会覆盖实例&#125;// 构造函数执行var f = new Fn();/* * 构造函数执行，浏览器会默认返回创建的实例 * return的是一个基本值，返回的依然是类的实例，没有影响，如果返回的是引用值， * 则会把默认返回的实例覆盖，此时接收到的结果就不再是当前类的实例 * 构造函数执行的时候，尽量减少return的使用，防止覆盖实例 */// new Fn === new Fn(); 在构造函数执行的时候，如果Fn不需要传参，//我们可以省略小括号,意思还是创建实例（和加小括号没有区别）// instanceof: 检测某一个实例是否隶属于某个类 f instanceof Fn 实例 instanceof 类名// in ：检测当前对象是否存在某个属性 'm' in f, //不管当前这个属性是对象的私有属性还是公有属性，只要有，结果就是true. //'toString' in f 结果是true， toString是它的公有属性// hasOwnProperty用来检测当前属性是否为对象的私有属性： 不仅要有这个属性，还必须要是私有属性才可以f.hasOwnProperty('m'); // truef.hasOwnProperty('toString'); // false 这个是公有属性 思考：编写一个方法hasPubProperty，检测当前属性是否为对象的公有属性，和hasOwnProperty对应1234567function hasPubProperty(obj, attr) &#123; if (attr in obj &amp;&amp; obj.hasOwnProperty(attr) === false) &#123; return true; &#125;; return false;&#125;&#125; 原型和原型链 （prototype &amp; proto）1234567891011121314151617181920212223242526272829/* * [函数] * 普通函数、类（所有的类：包含内置类和自己创建的类） * [对象] * 普通对象、数组、正则、Math、实例（是对象类型，除了基本类型的字面量创建的值） * prototype的值，arguments * 函数也是对象类型…… * 1, 所有的函数数据类型都天生自带一个属性叫prototype(原型), 这个属性的值是一个对象，浏览器会默认给它开辟一个堆内存; * 2, 浏览器给prototype开辟的堆内存当中，有一个天生自带的属性，叫constructor,这个属性存储的值是当前这个函数本身； * 3, 每一个对象都有一个_proto_的属性，这个属性指向当前实例所属类的prototype（如果不能确定是谁的实例，都是Object的实例） */function Fn() &#123; var n = 100; this.AA = function () &#123; console.log('AA私有'); &#125;; this.BB = function () &#123; console.log('BB私有'); &#125;;&#125;;Fn.prototype.AA = function () &#123; console.log('AA公有');&#125;;var f1 = new Fn;var f2 = new Fn;console.log(f1.n); // undefined 没有这个属性// f1._proto_.AA === f2._proto_.AA = Fn.prototype.AA // TRUEf1.name = 'f1的私有属性';f1._proto_.name = 'f1原型上的公有属性'; // 每个实例都可以用这个公有属性 练习题12345678910111213141516171819202122232425262728293031var a = 4;function b(x, y, a) &#123; // arguments：函数内置的实参集合，不管是否设置实参，都存在；但是在非严格Js模式下，函数中的形参变量和arguments存在映射机制（映射：相互之间影响） console.log(a); arguments[2] = 10; console.log(a);&#125;;a = b(1, 2, 3); // 函数b并没有return,默认函数的返回值是undefinedconsole.log(a);// 3,10，undefinedfunction fn(x, y) &#123; /* * 形参： x=10, y=undefined // y也是私有变量，赋值为undefined * arg和形参之间的映射关系是以arg的索引为基础完成的，arg中有这个索引，浏览器会完成与对应的形参变量中的映射机制搭建，如果形参比arg中个数多，那么多出来的形参是无法和arg中对应的索引形成映射关系的。 映射机制在一开始就会建立 */ var arg = arguments; console.log(arg); console.log(arguments); arg[0] = 100; console.log(x); // 100 arg[1] = 200; console.log(y); // undefined console.log(arg); console.log(arguments);&#125;;fn(10);// 1234567891011121314151617181920212223242526272829303132// JS严格模式，在当前作用域的第一行加上 \"use strict\"即可，这样在当前作用域中，就开启了Js的严格模式// \"use strict\"; // 整个Js都开启了严格模式，只对当前这个JS文件中的代码生效，下一个JS文件需要开启严格模式，第一行还是需要再次编写use strict; 真实项目中我们一般都会把JS文件合并压缩成一个导入页面/*function fn() &#123; \"use strict\"; // 只在当前作用中使用严格模式&#125;*/// 1. 严格模式下不支持arguments.callee/arguments.callee.caller// 2. 严格模式下arguments和形参没有映射机制// 3. 严格模式下不允许给一个对象设置重复属性名的// 4. 严格模式下函数执行，如果没有明确指定执行的主体（函数前面没有点.,不再像非严格模式下指向window,而是让this指向undefined,代表没有执行主体）严格模式下有执行主体，this就是谁，没有执行主体，就是undefined.~ function () &#123; \"use strict\"; function fn(a) &#123; arguments[0] = 100; console.log(a); &#125; fn(10); //10 var obj = &#123; n: 10, n: 20 &#125; console.log(obj.n);&#125;();~ function () &#123; function fn(a) &#123; arguments[0] = 100; console.log(a); &#125; fn(10); //100&#125;(); 1234567891011121314151617181920212223242526// 逻辑与&amp;&amp;,逻辑或||//1.在条件判断当中 if(1===1 &amp;&amp; 2===2)//2.在赋值操作中，有时也会用到； var a=1 || 2; 首先验证1是真假，如果为真，1赋值给a,反之，将2赋值给a;// var b=1 &amp;&amp; 2; 先验证1的真假，为真，结果是2,反之，将1赋值给bfunction fn(x, y) &#123; //验证传递的参数值，如果没有传递实参，让其默认值为零； x = x || 0; // 这种赋值方式并不严谨，x传值为false时，依然赋值0;但是项目中却非常常用，因为简单。 y = y || 0;&#125;function fn(callback) &#123; /* if(typeof callback==='function')&#123; callback(); &#125;*/ callback &amp;&amp; callback(); //上面if判断的简写版：默认callback要不然传函数，要不然就不传&#125;//3.逻辑与和逻辑或的混合模式 // 优先级： 逻辑与的优先级高于逻辑或//0 || 1 &amp;&amp; 2 || 2 &amp;&amp; 0 = 1 || 2 || 0 = 1//4.逻辑或的实战应用：形参赋值默认值（初始化形参）//在ES6新语法规范中可以直接给形参设置默认值function fn(x = 0) &#123; //如果x没有传递值，默认值是零，一旦传递值，不管传递的是啥，都是按照传递的值处理 console.log(x);&#125; 123456789101112131415// 5 5 6 2var a = 9;function fn() &#123; a = 0; return function (b) &#123; return b + a++; // b + a之后a自身再累加 &#125;&#125;var f = fn();console.log(f(5));console.log(fn()(5));console.log(f(5));console.log(a); 123456789101112var ary = [1, 2, 3, 4];function fn(ary) &#123; //传递进来的堆内存地址相同，所以第一步修改的是同一个堆内存中的ary[0] ary[0] = 0; // ary = [0]; // 修改了堆内存地址，与外部的已经不是同一个堆内存 ary[0] = 100; return ary;&#125;var res = fn(ary);console.log(ary);console.log(res); 1234567891011function fn(i) &#123; return function (n) &#123; console.log(n + i++); &#125;&#125;var f = fn(10);f(20);fn(20)(40);fn(30)(50);f(30);// 30,60,80,41 1234567891011121314var i = 10;function fn() &#123; return function (n) &#123; console.log(n + (++i)); &#125;&#125;var f = fn();f(20);fn()(20);fn()(30);f(30);// 31,32,43,44 12345678910111213141516171819202122232425262728293031323334353637383940/* * 1 和 new Number&#123;1&#125; * 区别： * 前面是基本数据类型，后面是引用数据类型值 * 相同点： * 都是Number类的实例 *//* * 函数类型： * 普通函数 * 构造函数（类：内置类和自己创建的类） * 对象类型： * 普通对象 * Math\\Json * 类的实例（数组、正则、日期等） * prototype或者_proto_ * arguments或者元素集合等类数组 * 函数也是一种对象 * -&gt; 万物皆对象 *//* * 1. 每一个函数（类）都有一个prototype（原型）属性，属性值是一个对象，这个对象中存储了供实例调取和使用的公有属性和方法； * 2. 在浏览器默认给原型prototype开辟的堆内存中，有一个属性叫constructor,存储的是当前类的函数； * 3. 每一个对象（实例）都有一个_proto_（原型链）属性，这个属性指向当前实例所属类的原型（不确定所属的类，都指向Object.prototype）。 */function Fn() &#123; this.x = 100; this.y = 200; this.getX = function () &#123; console.log(this.x); &#125;&#125;Fn.prototype.getX = function () &#123; console.log(this.x);&#125;Fn.prototype.getY = function () &#123; console.log(this.y);&#125;var f1=new Fn();var f2= new Fn(); 12345678910111213141516171819202122232425262728/* * 1 为啥不行？ * 事件绑定是异步编程，当触发点击行为，绑定的方法执行的时候，外层循环已经结束；方法执行产生私有作用域，用到的变量i不是私有变量，按照作用域查找机制，找到的是全局变量i（此时全局的i已经成为循环最后一次的结果） * * 2 如何解决 * 自定义属性 * 闭包 * ES6 */var box = document.getElementById(\"box\");var btnList = box.getElementsByTagName('button');for (var i = 0; i &lt; btnList.length; i++) &#123; btnList[i].onclick = (function (i) &#123; return function () &#123; console.log(i + 1); &#125; &#125;)(i);&#125;//每一轮循环都执行自执行函数，形成一个私有作用域（不销毁），里面设定一个私有变量i，让存储后期需要用到的索引// 点击触发方法执行，用到变量i，向对应的上级作用域查找i的值，而上级作用域中存储的i就是我们需要的索引// 基于闭包解决非常占用内存//ES6和闭包的机制类似，ES6中使用let创建变量，会形成块级作用域，当前案例中，每一轮循环都会形成一个块级作用域，把后续需要用到的索引i存储到自己的作用域中for(let i=0;i&lt;btnList.length;i++)&#123; btnList[i].onclick=function()&#123; console.log(i);&#125;&#125; 12345678910111213// 你以为你以为的就是你以为的var fullName = 'language';var obj = &#123; fullName: 'javascript', prop: &#123; getFullName: function () &#123; return this.fullName; &#125; &#125;&#125;console.log(obj.prop.getFullName()); // undefinedvar test = obj.prop.getFullName;console.log(test()); // language 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * 在实际项目中，基于面向对象开发的时候（构造原型设计模式），我们根据需要，很多时候会重定向类的原型（让类的原型指向自己开辟的堆内存） * 【存在的问题】 * 1,自己开辟的堆内存中没有constructor属性，导致类的原型构造函数缺失 * 解决方案：自己手动在堆内存中增加constructor属性 * 2,当原型重定向后，浏览器默认开辟的堆内存会被释放掉，如果原来已经存储了一些属性和方法，这些东西都会丢失 * 所以内置类的原型不允许重定向到自己开辟的堆内存中，因为内置类的原型上自带了很多属性和方法，重定向后都没了，这样是不被允许的。 */// 在原型上批量开发方法的时候，使用原型重定向function Fn() &#123;&#125;Fn.prototype = &#123; constructor: Fn, aa: 12, bb: 13, cc: 14&#125;function fun() &#123; this.a = 0; this.b = function () &#123; console.log(this.a); &#125;&#125;fun.prototype = &#123; b: function () &#123; this.a = 20; console.log(this.a); &#125;, c: function () &#123; this.a = 30; console.log(this.a); &#125;&#125;var my_fun = new fun();my_fun.b(); //0console.log(my_fun.a);my_fun.c(); //my_fun._proto_.c // 30console.log(my_fun.a);// 私有属性：自己堆内存中存储的属性相对自己来说是私有的// 公有属性：自己基于_proto_属性找到的属性相对自己来说是公有的 123456789101112131415161718192021222324252627282930313233var ary = [12, 23, 12, 23, 34, 34, 45];// 为啥ary.sort可以执行：因为sort是array.prototype上内置的属性方法，而ary是它的一个实例，可以基于_proto_找到原型上的这个方法，然后调取使用ary.sort(function (a, b) &#123; return a - b;&#125;);/* * 基于内置类的原型扩展方法，供他的实例调取使用 * 1. 我们增加的方法最好设置“my”前缀(前缀可以随便定义)，防止把内置方法重写 */Array.prototype.kpUnique = function kpUnique() &#123; // 方法中的this一般都是当前的实例，也就是我们要操作的数组 // ary._proto_.kpUnique() IE浏览器中屏蔽了我们对_proto_的操作 // Array.prototype.myUnique() ;// 这种方法极少使用 var obj = &#123;&#125;; for (var i = 0; i &lt; this.length; i++) &#123; var item = this[i]; obj.hasOwnProperty(item) ? (this[i] = this[this.length - 1], this.length--, i--) : obj[item] = item; &#125;; obj = null; return this;&#125;/*var a = ary.kpUnique(); // this:ary, 我们操作this相当于操作ary，方法执行完成，就会修改原数组// 此时方法执行的返回值是undefined; 原数组改变console.log(a);console.log(ary);// 执行sort返回的是排序后的数组，执行reverse()返回的也是数组，执行pop返回的是返回的那一项ary.sort(function (a, b) &#123; return a - b;&#125;).reverse().pop(); // js中的链式写法：保证每一个方法执行返回的依然是当前类的实例，这样就可以继续调取方法使用了。*/var max = ary.kpUnique().sort(function (a, b) &#123; return a - b&#125;).pop();console.log(ary); 12345678910// document.parentNode 和 document.parentnode的区别// 怎么规避多人开发函数重名问题使用单例模式规避把当前模块的属性和方法放在一个命名空间中（笔试的时候不要写太详细，阐述题不会表达可以手写代码）// javascript如何实现面向对象中的继承// 你理解的闭包是什么，优缺点？","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://abluecup.github.io/tags/javascript/"}]},{"title":"Javascript基础知识一","slug":"Javascript基础知识一","date":"2019-04-02T03:19:50.000Z","updated":"2020-05-19T09:25:30.678Z","comments":true,"path":"2019/04/02/Javascript基础知识一/","link":"","permalink":"https://abluecup.github.io/2019/04/02/Javascript基础知识一/","excerpt":"JavaScript，通常缩写为JS，是一种高级的，解释执行的编程语言。 JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。 它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。","text":"JavaScript，通常缩写为JS，是一种高级的，解释执行的编程语言。 JavaScript是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。 它提供语法来操控文本、数组、日期以及正则表达式等，不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。 简介javascript是轻量级的客户端脚本编程语言。 编程语言编程语言是具备一定逻辑的，拥有自己的编程思想（面向对象编程[oop]、 面向过程编程）（HTML + CSS是标记语言） 面向对象编程 java c++ php c# (.net) js.. 面向过程编程 c.. 目前的JS已经不仅仅是客户端语言了，基于Node可以做服务器端程序，所以js是全栈编程语言 JS 包括三部分 ECMAscript（ES） js语法核心 DOM document object model 文档对象模型， 提供各种API供js获取和操作html元素（dom元素）（见本页DOM及常用方法） BOM brower object model 浏览器对象模型，提供各种API供js操作浏览器 ECMAScript它是Js的语法规划，JS中的变量、数据类型、语法规范、操作语句、设计模式等等都是ES规定的 变量(variable)定义：它不是具体的值，只是一个用来存储具体值的容器或者代名词 存储的值可以改变，所以称为变量 基于ES语法规范，在js中创建变量有以下规范 - var (ES3) - function (ES3) 创建函数（函数也是变量，只不过存储的值是函数类型而已） - let (ES6) - const (ES6) 创建常量 - import (ES6) 基于ES6的模块规范导出需要的信息 - class (ES6) 基于ES6创建类 123456789101112/** *语法： var [变量名] = 值; / *let [变量名] = 值; / *const [变量名] = 值; *function 函数名()&#123;&#125;**/...var n = 13;n = 15;const m = 100; 创建变量的命名规范 严格区分大小写 遵循驼峰命名法：按照数字、字母、下划线命名，数字不能作为开头，命名基于英文单词，拼写成一个完整的名字（第一个单词字母小写，其余每一个有意义的单词首字母大写） 语义化强一些 不能使用关键字和保留字： 在js中有特殊含义的叫关键字，未来可能成为关键字的叫做保留字 数据类型数据值是一门编程语言进行生产的材料。JS中包含的值有一下数据类型：1, 基本数据类型 （值） + 数字 number + 字符串 string + 布尔值 boolean + null + undefined 2, 引用数据类型 + 对象object + 普通对象 + 数组对象 + 正则对象 + 日期对象 + ... + 函数 function 3, ES6中新增加的一个特殊的数据类型Symbol(唯一的值) 12345678910111213141516171819202122[基本数据类型] 数字类型中有一个特殊的值，叫 NaN (not a number 代表不是一个有效的数字，但是属于number类型) JS中所有用单引号或者双引号包裹起来的都是字符串，里面的内容是当前字符串中的字符（一个字符串由0到多个字符自称） boolean: true false[引用数据类型]var o=&#123;name: &apos;name&apos;, age: 9&#125; =&gt; 普通对象 由大括号包裹起来，里面包含多组属性名和属性值（包含多组键值对） &#123;&#125; 空对象var array = [1,2,3]; // =&gt; 中括号包裹起来， 包含零到多项内容，这种是数组对象 []空数组var reg = /-?(d|[1-9]\\d+))(\\.\\d+)?/g; /=&gt; 由元字符组成一个完整的正则 //不是空正则 当行注释 ^=^function fn()&#123;&#125;[Symbol] 创建出来的是一个唯一的值 var a = Symbol(&apos;珠峰&apos;); var b = Symbol(&apos;珠峰&apos;); a==b =&gt; false; const a = Symbol(&apos;flag&apos;); a 是唯一且不能改变的量 扩展： JS代码如何运行以及运行后如何输出结果[如何被运行] 把代码运行在浏览器中，浏览器内核来渲染解析； 基于Node来运行（Node也是基于V8引擎渲染和解析JS的工具) [如何输出结果] alert： 在浏览器中通过弹框的方式输出（浏览器提示框）； 12345alert();// =&gt; window.alert()alert(1+1) =&gt; &apos;2&apos; 基于alert输出的结果都会转换成字符串：把值（如果是表达式先计算出结果）通过toString()这个方法转化成字符串，然后再输出alert([12,23]) =&gt; &quot;12,23&quot;alert(&#123;name:&apos;xx&apos;&#125;) =&gt; &apos;[object Object]&apos; 对象.toString()结果是[object Object] confirm 和alert用法一致，只不过提示的框中有确定和取消两个按钮，所以它是确认提示框 123456var flag = confirm(&apos;确定要退出吗&apos;);if(flag)&#123; // 用户点击的是确定按钮&#125;else&#123; //用户点击的取消按钮&#125; prompt 在confirm的基础上增加输入框 console.log :在浏览器控制台输出日志控制台简介： Elements: 当前页面中的元素和样式在这里都可以看见，还可以调节样式修改结构等； Console: 控制台 可以在JS代码中通过.log输出到这里，也可以在这里直接编写JS代码； Source: 当前网站的源文件都在这里 …… console.dir 比log的输出更详细（尤其是输出对象数据值的时候） console.table: 把一个JSON数据按照表格的方式输出.. (更多的console输出方法) 数据类型的详细剖析number数字类型NaN： not a number， 但它是数字类型isNaN: 检测当前值是否不是有效数字，返回true 代表不是有效数字，返回false代表是有效数字123456789101112131415161718192021222324252627282930313233343536isNaN([value])isNaN(&apos;13&apos;) =&gt; falseisNaN(&apos;AA&apos;) =&gt; trueisNaN(true) =&gt; falseisNaN(false) =&gt; falseisNaN(null) =&gt; falseisNaN(undefined) =&gt; trueisNaN(&#123;age:9&#125;) =&gt; trueisNaN([12,23]) =&gt; trueisNaN([12]) =&gt; falseisNaN(/DS/) =&gt; trueisNaN(function()&#123;&#125;) =&gt; true重要： isNaN检测的机制1、首先验证当前要检测的值是否为数字类型的值，如果不是，浏览器会默认的把值转换为数字类型； 把非数字类型转化为数字 -其他基本类型转换为数字： 直接使用Number这个方法； [字符串转化为数字] 如果当前字符串中出现任意一个非有效数字字符，结果为NaN Number(&apos;13&apos;) =&gt; 13 Number(&apos;13a&apos;) =&gt; NaN Number(&apos;13.5&apos;) =&gt; 13.5 可以识别小数点 [布尔转数字] Number(true) =&gt; 1 Number(false) =&gt; 0 [其他] Number(null) =&gt; 0 Number(undefined) =&gt; NaN - 把引用数据类型值转换为数字： 先把引用值调取toString转化为字符串，然后把字符串调取Number转化为数字 Number(&apos;&apos;) =&gt; 0 ([]).toString =&gt; &apos;&apos;; isNaN([]) =&gt; false 2、当前检测的值已经是数字类型，是有效数字返回false,不是返回true (数字类型中只有NaN不是有效数字，其余都是有效数字)其他类型转换为数字类型为0的是： null [] &apos;&apos; false, &apos; &apos;, parseInt parseFloat 等同于Number,也是为了把其他值转化为数字类型和Number的区别在于字符串转换分析上Number出现任意非有效字符，即为NaNparseInt: 把一个字符串中的整数部分解析出来parseFloat: 把一个字符串中的小数（浮点数）解析出来 123456parseInt(&apos;13.5px&apos;) =&gt; 13parseFloat(&apos;13.5px&apos;) = 13.5parseInt(&apos;w13.5&apos;) =&gt; NaNparseInt从字符串最左边字符开始查找有效数字字符，并且转化为数字，但是一旦遇到非有效数字字符，查找结束parseFloat多识别一个字符. parseFloat(&apos;.2p&apos;) =&gt; 0.2 NaN的比较123(NaN == NaN) =&gt; false NaN和谁都不相等，包括和自己也不相等` 思考题： 有一个变量，存储的值不知道，我想检测它是否为一个有效数字，下面的方案是否可以123if(Number(num) == NaN)&#123; // 条件永远不成立 alert(&quot;num不是有效数字&quot;);&#125; 只有一种方案 1234567if(isNaN(num))&#123; alert(&quot;num不是有效数字&quot;);&#125;if(typeof num === &quot;number&quot; &amp;&amp; !isNaN(num))&#123; console.log(&quot;num是有效数字类型值&quot;);&#125; 布尔类型 只有两个值 true/false如何把其他类型转化为布尔类型 Boolean123Boolean(1) =&gt; trueBoolean(0) =&gt; false数字类型值里面只有0和NaN是false,其余都是true ! 1!&apos;st&apos; 非、取反，先把其他数据类型转化为布尔类型，然后取反 !! 1否定之否定，肯定 规律 在js中只有 0 null undefined NaN 空字符串 转化为布尔类型的false,其余都转化为true“ “不是空字符串，转化为boolean类型值是trueNumber(“”)值为0， Number(“ “)的值也为0. null &amp; undefined 都代表空null ：空对象指针undefined ：未定义 null 一般是意料之中的没有（通俗理解都是认为手动的设置为null, 后面的程序中我们会再次给它赋值）1var num = null; // =&gt;null 是手动赋值的, 预示着我会把num变量的值修改 undefined 代表着没有，一般都不是人为控制的，大部分都是浏览器自主为空，后面可以赋值，也可以不赋值； 12var num;// 此时num会被浏览器分配一个值 undefined, 后面可以赋值，也可以不赋值 string其他数据类型转化为string类型().toString() 基本数据类型转化为string类型，直接使用引号包裹住字符； 引用类型转化为string类型 function(){} 直接使用引号包裹 普通对象， [object Object] 数组 [] =&gt; ‘’; [12] =&gt; ‘12’; [12,23] =&gt; ‘12, 23’; 正则对象，日期对象，直接使用引号包裹； object对象数据类型分为四类 普通对象特点 - 由大括号包裹起来； - 由0到多组属性名和属性值（键值对）组成； 属性是用来描述当前对象特征的，属性值是对这个特征的描述；(属性：键[key] 属性值：值[value])1234567891011121314151617181920212223242526272829var obj = &#123; name: &apos;kyle&apos;, age: 9&#125;// 对象的操作：对键值对的增删改查[获取] 语法： 对象.属性名 / 对象[属性名]obj.nameobj[&apos;name&apos;] 一般来说属性名都是字符串格式，属性值不固定，任何格式都可以[增/改]js对象中属性名是不允许重复的，是唯一的。obj.name = &apos;xxx&apos;;// 原有对象中存在name属性，此处是修改属性值obj.sex = &apos;man&apos;; // 原对象中不存在sex属性，此处是新增属性obj[&apos;age&apos;] = 12;[删]彻底删除delete obj.age // delete obj[&apos;age&apos;] 对象中不存在age属性了假删除：并没有移除属性，只是让当前属性的值为空obj.sex = null;// obj[&apos;sex] = null;obj.class // undefined;在获取属性值的时候，如果当前对象有这个属性名，可以正常取值(哪怕是null),但是如果没有这个属性名，则获取的值是undefinedvar obj = &#123;name:&apos;kyle&apos;, age: 9&#125;var name = &apos;peng&apos;;obj.name =&gt; &apos;kyle;obj[&apos;name&apos;] =&gt; &apos;kyle&apos;;obj[name] =&gt; undefined; 此处的name是一个变量，我们要获取的并不是属性名叫name,而是储存在name中的值 &apos;peng&apos;; 一个对象中的属性名不仅仅是字符串格式，还有可能是数字格式,遇到其他格式的先转化为字符串格式 123456789// chrome控制台下shift+enter换行var obj = &#123; name: 'kyle', 0:9&#125;// 数字格式用obj[0]和obj['0'],但是不能用obj.0// SyntaxError 语法错误 当我们存储的属性名不是字符串也不是数字格式时，会调用.toString()转化为字符串格式后，再进行存储 null undefined boolean 引用类型都可以先转化为字符串再储存值obj[{}] = 300; obj = {‘[object Object]’:300}, 获取的时候也是先把{}转化为字符串，然后再获取值 数组对象（对象由键值对组成）var oo = {a:12}var ary=[12,23];//=&gt; 12,23都是属性值，属性名呢？通过观察结果：数组对象的属性名是数字，我们把数字属性名成为当前对象的索引。ary[0], ary[‘0’] 数组和对象的关系： 数组是一种特殊的对象，属性名是数字 浅分析js的运行机制1、当浏览器(他的内核/引擎)解析和渲染JS的时候，会提供一个供JS代码运行的环境，我们把这个环境称为全局作用域(global scope);2、代码自上而下执行（之前还有一个变量提升阶段） =&gt;基本数据类型的值会存储在当前作用域下 var a =12; 有三步操作 1）在当前环境下开辟一个空间存储12； 2）声明一个变量名 a; 3) 把声明的变量和值关联起来，赋值操作叫做定义 var b=a; 基本数据类型值也叫值类型，是按照值来操作的：把原有的值复制一份放到新的空间或位置上，和原来的值没有关系. 1) 在当前环境下开辟一个空间存储12； 2） 声明变量 b 3) b 和 12 关联； a 和 b 没有关系； b =13 1) 开辟空间存储13; 2) b和13关联 变量和基本类型数据是一一对应关系； =&gt; 引用数据类型的值不能存储在当前的作用域下，因为可能存储的内容过于复杂，我们需要先开辟一个新的空间，把内容存储到这个空间中 1）开辟一个新的空间，把对象中的键值对依次存储起来（为了保证后面可以找到这个空间，此空间有一个16进制的地址） 2）声明一个变量 3）让变量和空间地址关联在一起（把空间的地址赋值给变量） 引用类型不是按值操作，是按照引用的地址操作：把原来空间的地址赋值给新的变量，但是原来的空间没有被克隆。这样就会出现多个变量关联的是同一个空间，相互之间就会存在影响。 作用域叫栈内存，存储引用类型数据值的叫堆内存栈内存：本身就是供JS代码执行的环境，所有的基本类型值都会直接在栈内存中开辟一个位置；堆内存：独立于栈内存的内存，存储引用类型中的数据值；对象存储的键值对，函数存储的是代码字符串 隔三行变色123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!Doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;style&gt;.box&#123; margin: 20px auto; width:300px;&#125;.box li&#123; line-height: 35px; padding: 0 5px; border-bottom: 1px dash #aaa; text-overflow: ellipsis; white-space: nowrap; overflow: hidden;&#125;.bg0&#123; background-color:pink;&#125;.bg1&#123; background-color:lightGreen;&#125;.bg2&#123; background-color:lightBlue;&#125;.hover&#123; background-color: orange;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=\"box\" id=\"box\"&gt;&lt;li&gt;剴；开放日哦个人头&lt;/li&gt;&lt;li&gt;jk;;;ssd&lt;/li&gt;&lt;li&gt;受到攻击；哦哦人啊个今儿个‘&lt;/li&gt;&lt;li&gt;地方igoerg'e'a'eanj；反对党哦【思伽尔和&lt;/li&gt;&lt;li&gt;让他脚痛医脚他已经对方如何【&gt;&lt;/li&gt;&lt;li&gt;kl;'df 梵蒂冈阿尔贡哦哦人啊个&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;// var oBox = document.getElementById(\"box\");//var oList = oBox.getElementsByTagName(\"li\");//console.log(oList);//var arr = ['red', 'green', 'blue'], n;//for(var i=0;i&lt;oList.length; i++)&#123; /**n = i % 3; oList[i].style.backgroundColor = arr[n];*/ //oList[i].className = 'bg' + i%3; // oList[i].style.backgroundColor = i%3 == 0 ? 'lightBlue' : (i % 3 == 1 ? 'lightGreen': 'red');////&#125;function changeColor()&#123; var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); var arr = ['pink','lightGreen','lightBlue']; for(var i = 0; i&lt;oList.length; i++)&#123; oList[i].style.backgroundColor = arr[i % 3]; //oList[i]. &#125;&#125;function changeColor2()&#123; var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); var arr = ['pink', 'lightBlue', 'lightGreen']; for(var i=0; i&lt; oList.length;i++)&#123; if(!(i % 3))&#123; oList[i].style.backgroundColor='lightBlue'; &#125;else&#123; if(i%3 == true)&#123; oList[i].style.backgroundColor='lightGreen'; &#125;else&#123; oList[i].style.backgroundColor='pink'; &#125; &#125; &#125; &#125;function changeColor3()&#123; // 每次循环一组，但是会出现当前这一组不够三个，这样会报错 var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); for(var i=0;i&lt;oList.length;i+=3)&#123; oList[i].style.backgroundColor = 'red'; // if(i+1 &lt;= oList.length -1;) oList[i+1].style.backgroundColor = 'green'; // if(i+2 &lt;= oList.length - 2) oList[i+2].style.backgroundColor = 'blue'; &#125;&#125; changeColor();/**三种方案：1. 依次遍历每一个Li，通过索引除3的余数，设置当前行的样式；2.*/function highLight()&#123; var oBox = document.getElementById(\"box\"); var oList = oBox.getElementsByTagName(\"li\"); var arr = ['red', 'green','blue']; var arr1 = ['pink','lightGreen','lightBlue']; var n; for(var i=0;i&lt;oList.length;i++)&#123; //n = i % 3; //console.log(n); oList[i].myIndex = i;// 每一次循环的时候都给每一,个li设置一个自定义属性，属性值存储的是当前li的索引 oList[i].addEventListener('mouseover', function()&#123; // 有回调函数，一般是异步执行，放在任务队列里 this.style.background = arr[this.myIndex % 3]; &#125;); oList[i].addEventListener('mouseout', function()&#123; this.style.background = arr1[this.myIndex % 3]; &#125;);// 绑定方法的时候，还没有执行，存储的是字符串,当循环结束，我们手动去操作li的时候，方法才会才会执行，此时changTab(i)的变量i 已经是3了 &#125;&#125;// css 优先级： 行内，ID，样式类，标签highLight();/***css 我们把hover 放在bg的后面，当元素的class=\"bg hover\"的时候，元素呈现hover的样式鼠标滑过，新增样式类hover,鼠标离开，把新增的样式类移除**/&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS中的数据类型转换JS中的数据类型【基本数据类型】 数字 number 字符转 string boolean null undefined [引用类型数据] 对象 普通对象 数组对象 正则对象 日期对象 数学对象 … 函数 function 真实项目中，根据需求，我们往往需要把数据类型之间进行转换（规则和规则之间是相互独立的） 把其他数据类型转化为number类型1. 发生的情况 isNaN检测的时候，当检测的值不是数字类型，浏览器会自己调用Number方法把它转化为数字类型，然后再检测是否为非数字； 123isNaN('3') =&gt; falseNumber('3') =&gt; 3isNaN(3)=&gt; false 基于parseInt / parseFloat 去手动转化为数字； 数学运算 + - * / (+ 不仅仅是数学运算，还可能是字符串拼接) 1234567893 -1 =&gt; 2Number(3) =&gt; 3'3PX -1' =&gt; NaN'3PX' + 1 =&gt; 3PX1var i = '3';i+1 =&gt; '31'i += 1 =&gt; '31'i++ =&gt; 4 i++就是单纯的数学运算，已经摒弃掉字符串拼接的规则 基于 “==” 比较的时候，有时候也会把其他值转化为数字类型 … 2. 转化规律 //=》 转换的方法： Number(浏览器自行转换都是基于这个方法完成的) 12345678910111213141516【把字符串转化为数字】只要遇到一个非有效数字，结果就是NaN; ''变成数字类型是0' '=&gt; 0;' '=&gt;0;'\\n' =&gt; 0; 换行符（多个空格）'\\t' =&gt; 0; 制表符（一个tab键是四个空格）【布尔类型】true =&gt; 1false =&gt; 0;[把没有转换为数字]null =&gt; 0;undefined =&gt; NaN[引用类型转换为数字]首先转换为字符串（toString()）,然后再转换为数字（Number） 把其他类型值转换为字符串1. 发生的情况 基于alert / confirm / prompt /document.write等方法输出内容的时候，会把输出的值转换为字符串，然后再输出 1alert(1) =&gt; '1' 基于 + 进行字符串拼接的时候 把引用值转换为数字类型值的时候，首先会转换为字符串，然后再转换为数字 给对象设置属性名，若属性名不是字符串，先转换为字符串，然后再当作字符串存储到对象中（对象的属性名只能是字符串或者数字） 手动调用toString/toFixed/join/String等方法的时候，也是为了转换为字符串 1234var n = Math.PI; // 圆周率n.toFixed(2) // '3.14'var ary = [12,23,34]ary.join('+') // 12+23+34; … 2. 转换规律123456789101112// 浏览器默认调用的方法都是 toString()[除了对象，都是你理解的转换，也就是直接加引号]1 // '1';null =&gt; 'null'[] =&gt; '';[12] =&gt; '12';[12,23] =&gt; '12,23'(function()&#123;&#125;).toString() // \"function()&#123;&#125;\"【对象】&#123;name:'xxx'&#125; =&gt; '[object Object]'&#123;&#125; =&gt; '[object Object]'不管是什么样的普通对象，最后结果都一样 把其他值转为布尔类型值1.发生的情况 基于!/!!/Boolean()方法转换； 条件判断中的条件最后都会转换为布尔类型 …123456if(n)&#123; // 把n的值转换为不二验证条件的真假&#125;if('3px' + 3)&#123; // 先计算表达式的结果'3px3',把结果转换为布尔类型值true,&#125; 2.转换规律除了 ‘’（空字符串）， null， undefined， 0， NaN转换为boolean是false外，其他都是true. 特殊情况：数学运算和字符串拼接 “+”123456789当表达式中出现字符串，就是字符串拼接，否则就是数学运算1+ true // 2 数学运算\"1\" + true // \"1true\" 字符串拼接[12] + 10 // '1210' 虽然现在没看到字符串，但是引用类型转换为数字，会先转换为字符串，所以变为了字符串拼接（&#123;&#125;）+ 10 // \"[object Object]10\"[] + 10 // '10'&#123;&#125; + 10 // 10 这个和以上说的没有任何关系，因为他根本就不是数学运算，也不是字符串拼接，他是两部分代码 &#123;&#125;代表一个代码块（块级作用域），+10才是我们的操作；严格来说应该分成两部分：&#123;&#125;;+10; 1234512 + true + false + null + undefined + [] + 'hello' + null +undefined + [] + true // \"NaNhellonullundefinedtrue\"13 + NaN = NaNNaN +[] = \"NaN\"12+[]// '12' 特殊情况：&quot;==&quot;在进行比较的时候，如果左右两边数据类型不一样，则先转换为一样的类型，再进行比较。 对象 == 对象；不一定相等，因为对象操作的是引用地址，地址不相同，则不相等 12345&#123;name:'xx'&#125; == &#123;name:'xx'&#125; //falsevar obj1=&#123;&#125;;var obj2 = obj1;obj2 == obj1 //true 对象==数字，把对象转换为数字，然后再比较； 对象==布尔：把对象转换为数字，把布尔也转换为数字； 对象==字符串：把对象转化为数字，把字符串也转化为数字 字符串 == 数字： 字符串转化为数字 字符串== 布尔： 都转化为数字 布尔==数字：把布尔转换为数字1234567不同类型值的比较，都是把其他值转换为数字类型值，在进行比较null == undefined //truenull === undefined //falsenull 和 undefined 和其他值都不相等NaN == NaN //false以上需要特殊记忆的 123456789101==true // true2==true //false 两个情况比较的时候，都转化为数字，这里是把true变为1，而不是把2变为true[] == [] // false 同类型之间直接比较，对象的引用地址不一样，所以是false![]==[]// ![]是false,类型不一样，转化为数字是0，[]转化为数字是0 ，结果是true[]==false// true 0 == 0[] == false // true 都转化为数字 0==0[]==true // false![] == false; // 先算![] == false; false == false ; 结果是true![]==true;// false 操作数组的常用方法数组也是对象数据类型的，也是由键值对组成的123456789101112 var ary =[12,23,34];/***结构* 0： 12* 1：23* 2：34*length:3*/1.以数字为索引，从零开始递增；2、有一个length属性存储的是数组的长度ary[0]// 获取第一项ary[2] ary[ary.length-1] // 获取最后一项 数组中每一项的值可以是任何数据类型的12345// 多维数组var ary = [ &#123;name:&apos;xx&apos;,age:9&#125;, &#123;name:&apos;yy&apos;,age:10&#125;]; 数组当中的常用方法 按照四个维度记忆： 方法的作用 方法的参数 方法的返回值 原有的数组是否改变 push 向数组 末尾 追加新的内容 \\参数：追加的内容，可以是一个，也可以是多个\\返回值： 新增后数组的长度\\原有数组改变 1234567var ary = [12,23,34]ary.push(100); // 4ary // [12,23,34,100]ary.push(200,300);//6ary //[12,23,34,100.200.300]ary.push(&#123;name:'xx'&#125;)//7ary // [12,23,34,100,200,300, &#123;name:'xx'&#125;] pop 删除数组最后一项\\无\\返回值： 被删除的那一项内容\\原有数组改变 123var ary = [12,23,34];ary.pop(); // 34ary // [12,23] shift 作用：删除数组中的第一项\\参数：无\\返回值：被删除的那一项\\原数组改变 基于shift删除数组中的第一项，第一项被删除后，原有后面的每一i选哪个的索引都要向前提一位 unshift 作用：向数组开始位置追加新内容给\\参数：新增的内容\\返回值：新增后数组的长度\\原有数组改变 splice 基于splice可以对数组进行很多操作：删除指定位置的内容，向数组指定位置增加内容，还可以修改指定位置的内容 删除 12345语法：ary.splice(n,m) // 从索引n开始删除m个内容参数：n -&gt; 索引； m -&gt; 要删除的个数返回值： 把删除的部分以一个新数组返回原有数组改变m不写的话或者删除的个数大于最大长度，是指从索引开始删除到数组末尾 新增 1234ary.splice(n,0,x,...)从索引n开始删除0项，把x或者更多内容存放到数组中索引n的前面返回值： [] 因为一项都没有删除原有数组改变 修改 123ary.splice(n,m,x,...)修改的原理就是把原有的内容删除掉，然后把新的内容放入数组返回值是删除内容组成的数组 12345678910需求扩展1、删除数组最后一项，有几种办法： ary.pop();ary.splice(ary.length-1);ary.length--;// 不建议基于delete删除，虽然内容没有了，但是数组的length没有改变1、向数组末尾追加新的内容，有几种办法；ary.push();ary.splice(ary.length,0,x); // x是要添加到索引的前面，所以不能是ary.length-1ary[ary.length] = x; slice作用：在一个数组中，按照条件查找出其中的部分内容；参数： 两个参数 n,m; 从索引n开始找到索引m处，但是不包含m; m不写的话，查到数组末尾返回值： 以一个新数组存储查找的内容；原有数组不会改变； ary.slice(0);ary.slice(); // 数组克隆数组 concat作用：实现多个数组（或者值）的拼接参数：数组或者值返回值：拼接后的新数组原有数组不变ary1.concat(ary2,’kyle’,ary3)[].concat(ary1,ary2,’kyle’,ary3) 可以基于空数组作为拼接的开始，再括号中排列拼接的顺序 toString作用：把数组转化为字符串参数：无返回值：数组中每一项用逗号分隔的字符串原有数组不变 join作用：和toString类似，也是把数组转化为字符串，但是可以设置变为字符串之后每一项和每一项之间的连接符参数：指定的连接符返回：字符串原有数组不变 reverse作用：把数组倒过来排列参数：无返回值：排列后的新数组原有数组改变 sort作用：给数组排序参数：无或者是个函数返回值：排序后的新数组原有数组改变 sort在不传递参数的情况下只能处理10以内的排序在真实项目中，基于sort排序，我们都需要传递参数123ary.sort(function(a, b)&#123; return a-b; //升序 return b-a 降序&#125;) indexOf / lastIndexOf这两个方法不兼容IE低版本浏览器(IE678)作用：返回当前项在数组中第一次和最后一次出现的索引参数：要检测的索引返回：索引原有数组不变1234// 验证数组中是否含有某一项if(ary.indexOf(100) &gt; -1)&#123;// 验证数组中是否含有100&#125; 数组去重123456789101112131415161718192021/*** 1. 定义一个空对象；* 2. 将数组中的值以当作属性名和属性值存入obj中，之前要先判断obj中是否含有此属性名， typeof ,有则删除，没有则赋值*/var ary = [1, 3, 5, 4, 3, 34, 56, 43, 34];var obj = &#123;&#125;;for (var i = 0; i &lt; ary.length; i++) &#123; var item = ary[i]; if (typeof obj[item] !== 'undefined') &#123; // 存在删除 //ary.splice(i, 1, ary[ary.length - 1]); // 为避免因数组过长而引起的数组塌陷，我们将数组末尾的值赋值给当前值，因为当前值已经在obj中存在，所以没有必要再替换，直接删除最后一项即可； ary[i] = ary[ary.length - 1]; ary.length--; i--; // 当前项已经不是原来的值了，要重新检测当前值，所以i--; continue; &#125; else &#123; obj[item] = item; &#125;&#125; 字符串中的常用方法JS中关于JS的一些细节知识 在JS中所有用单引号或者双引号包起来的都是字符串，每一个字符串是有0到多个字符组成；12345var str = 'kylepeng';str.length // 字符串长度str[100] -&gt; undefined;字符串中的每一个字符都有一个自己对应的索引，也有类似于数组一样的length代表自己的长度 字符串是基本类型数据，字符串的每一次操作都是值直接的进行操作，不想数组一样是基于空间地址来操作的，所以不存在原有字符串是否改变这一说，肯定都是不变的 常用方法charAt/charCodeAt作用：charAt根据索引获取指定位置的字符； charCodeAt不仅仅获取字符，它获取的是字符对应的Unicode编码值（ASC II码值）参数：索引返回值：字符或者对应的编码123456789 var str = 'sdfsdfse'; str.charAt(0) // s str.charAt(100) // ''空字符串 str[100] // undefined //当索引不存在的时候，str[x]获取的值和数组一样，结果是undefined;str.charCodeAt(0) //115 得到的编码是ASC II中对应的十进制编码'你'.charCodeAt() //20320 中文也有对应的编码//String.fromCharCode(122) // 'z' 通过编码找到对应的字符 indexOf/lastIndexOf获取当前字符在字符串中第一次出现或最后一次出现的索引，用以判断字符串中是否包含某个字符，有这个字符，返回索引，没有这个字符，返回-1 slice作用：str.slice(n,m)从索引n开始到索引m止，不包含m,把找到的字符当作新字符串返回 substring和slice语法一摸一样唯一的区别在于，slice支持负数索引，substring不支持负数索引str.substring(-3,-1) // “”str.substring(-3,1) // “s”12345var str='abcdefg';str.slice(-3,-1); // efstr.slice(-3,1);// ''str.substring(-3,-1);// ''str.substring(-3,1);//a substr也是字符串截取的方法str.substr(n,m) 从索引n开始，截取m个字符支持负数索引，负数索引指的是字符串总长度+负数索引和substring一样，第二个参数不写，截取到末尾，但是支持第一个索引为负数 toUpperCase / toLowerCase实现字符大小写的转化 split和数组中的join相对应，join是把数组中的每一项按照指定的连接符变成字符串，split是把字符串按照指定的分隔符，拆分成数组中的每一项。 replace把字符串中的原有字符进行替换参数： 原有字符， 要替换的新字符返回值： 替换后的字符串// =》在不使用正则的请情况下，每执行一次replace,只能替换一次 真实项目需求时间字符串格式化有一个时间字符串 ‘2018-4-4 16:6:8’, 我们想基于这个字符串获取到”04月04日 16时06分” 123456789101112131415161718192021222324252627282930313233343536// 2018-4-4 16:6:8 =&gt; 04月04日 16时06分 var str = '2018-4-4 16:6:8'; var ary = str.split(' '); var ary1 = ary[0].split('-'); var ary2 = ary[1].split(':'); var month = ary1[1], date = ary1[2], hour = ary2[0], minute = ary2[1]; function addZero(n) &#123; if (n &lt; 10) &#123; n = '0' + n; &#125; return n; &#125; var newStr = addZero(month) + '月' + addZero(date) + '日 ' + addZero(hour) + '时' + addZero(minute) + '分'; console.log(newStr); // 正则方法 ~ function(pro) &#123; pro.formatTime = function(template) &#123; template = template || '&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒'; var ary = this.match(/\\d+/g); template = template.replace(/\\&#123;(\\d+)\\&#125;/g, function() &#123; var n = arguments[1]; val = ary[n] || '0'; val &lt; 10 ? val = '0' + val : null; return val; &#125;); return template; &#125; &#125;(String.prototype); console.log(str.formatTime()); console.log(str.formatTime('&#123;1&#125;月&#123;2&#125;日')); URL地址问号传参解析12345678910111213141516171819202122232425262728/** *https://www.zhufeng.cn/stu/?lx=1&amp;name=aa&amp;sex=man#teacher // #后面的成为哈希值HASH,这个值可能有，可能没有，我们需*要处理，有的话我们需要过滤掉 * 1、先找到问号，把问号后面的信息截取下来即可 * A、首先我们需要验证是否存在#哈希值，存在我们从问号开始截取到#，不存在我们直接截取到字符串末尾 * 2、以&amp;进行拆分（数组） * 3、 遍历数组中的每一项，把每一项按照=拆分，把拆分后的第一项作为对象的属性名，第二项作为属性值进行存储即可 */function getURL(url) &#123; //var str = url.substring(str); var indexASK = url.indexOf('?'); var indexWell = url.indexOf('#'); var str; // # 可能有，可能没有 if (indexWell &gt; -1) &#123; // # 存在 str = url.substring(indexASK+1,indexWell); &#125; else &#123;// 截取到末尾 str = url.substr(indexASK+1); &#125; var ary = str.split('&amp;'); var obj=&#123;&#125;; for(var i=0;i&lt;ary.length;i++)&#123; var item =ary[i], itemAry = item.split('='); obj[itemAry[0]]=itemAry[1]; &#125; return obj;&#125;console.log(getURL('https://www.zhufeng.cn/stu/?lx=1&amp;name=aa&amp;sex=man#teacher')); JS中的MathMath称为数学函数，但是它属于对象类型的之所以叫做数学函数，是因为Math这个对象中提供了很多操作数字的方法 Math.abs取绝对值 Math.ceil / Math.floor向上或者向下取整 Math.round四舍五入 Math.round(-10.5) =&gt; -10; Math.round(-10.51) =&gt; -11 Math.sqrt开平方 pow取幂 n的m次方Math.pow(2,10) =&gt; 1024 max/min获取最大值和最小值 Math.PI圆周率 Math.random()获取0到1之间的随机小数Math.ceil(Math.random()10); // 1-10之间的随机整数Math.floor(Math.random()(m-n)+n);获取n-m之间的随机整数 JS中的判断语句 if/else if/else在JS中检测数据类型的方式： typeofinstanceofconstructorObject.prototype.toString.call() 1234567typeof value //检测value的数据类型返回值：使用typeof检测出来的结果是一个字符串，字符串中包含着对应的数据类型：\"number\",'string','object','undefined','function','boolean'typeof null // object null代表空对象指针，没有指向任何的内存空间typeof // 检测数组/正则/对象，返回结果都是object,也就是基于这种方式无法细分对象 typeof // 是逻辑运算符，不是方法 三元运算符语法： 条件？成立做的事：不成立做的事；12345678910 if(num&gt;10)&#123;num++&#125;else&#123;num--&#125;num&gt;10? num++ : num--;//如果三元运算符当中，如果有一步步需要做任何处理，我们用 null/undefined/void 0占位即可if(num&gt;10)&#123;num++&#125;num&gt;10? num++ : null;// 如果需要执行多项任务，用小括号括起来，每条操作语句之间用逗号隔开num&gt;10? (num++, num+=10):null; switch case用于变量或者表达式等在不同之情况ia的不同操作，每一种case结束后都要加break(结束整个判断)12345678910111213141516171819202122switch(n)&#123; case x: ... break; case y: ... break; default: z; &#125;// switch case 中每一种case情况的比较都是基于 === 绝对相等来完成的。//不加break，后面的条件不管是否成立，都会被执行，利用此机制，我们可以完成一些特殊的处理，例如：如果num等于10和5，都做同一种事情,那么不用加break,写在一块即可。switch(num)&#123; case 10: case 5: num++; break; default: num=0; &#125;// 真实项目中，我们基本使用===,保证代码的严谨性 函数函数在js中，函数就是一个方法（一个功能体），基于函数一般都是为了实现某个功能；函数诞生的目的就是为了实现封装：把闪现一个功能的代码封装到一个函数中，后期想要实现这个功能，只需要把函数执行即可，不必要再次编写重复的代码，起到了 低耦合，高内聚（减少页面中的冗余代码，提高代码的重复使用率）的作用 语法：ES3 标准创建函数function 函数名([参数]){ 函数体；实现功能的代码} 函数名(); 执行函数 ES6标准：创建箭头函数let 函数名(变量名) = ([参数]) =&gt; { 函数体}函数名();123let fn=()=&gt;&#123; //...&#125; 函数作为引用类型的一种，它也是按照引用地址来操作的 函数的运行机制 函数也是引用类型，首先会开辟一个新的堆内存，把函数体中的代码当作字符串存储到内存中（对象向内存中存储的是字符串） 把开辟到堆内存的地址赋值给函数名； 此时我们输出fn代表当前函数本身，fn()是执行函数fn,所以是否加()是两种不同本质的操作； 【函数执行】目的：把之前存储在堆内存中的字符串变为真正的JS代码自上而下执行，从而实现应用的功能；1.函数执行，首先会形成一个私有作用域：一个供代码执行的环境，也是也个栈内存；2.把之前在堆内存中存储的代码字符串复制过来，变为真正的JS代码，在新开辟的栈内存中自上而下执行 【函数中的参数】参数：是函数的入口，当我们在函数中封装一个功能，发现一些原材料不确定，需要执行函数的时候用户传递进来才可以，此时，我们就基于参数的机制，提供出入口即可。12345678function sum(a, b) &#123; //此处的参数叫形参，形参变量 // a , b分别对应两个数字； return a + b;&#125;sum(1, 2); // 1,2是实参，是具体的数据值sum(10) // a =10, b = undefined;sum() // a= undefined b=undefined;sum(1, 2, 3); // a=1,b=2;3没有形参变量接收,实参一定是具体的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .tabBox &#123; width: 500px; margin: 20px auto; &#125; .tabBox ul &#123; position: relative; top: 1px; /* 相对自己之前的位置向下移动1px;*/ &#125; .tabBox ul li &#123; display: inline-block; margin-right: 10px; padding: 0 10px; line-height: 33px; border: 1px solid #aaa; cursor: pointer; &#125; .tabBox ul li.active &#123; font-weight: bold; border-bottom-color: #fff; /* 当前Li的下边框覆盖了div的边框，我们让li的下边框的颜色是白色，这样看上去没有边框了*/ &#125; .tabBox div &#123; display: none; line-height: 148px; text-align: center; border: 1px solid #aaa; &#125; .tabBox div.active &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"tabBox\" id=\"tabBox\"&gt; &lt;ul&gt; &lt;li class=\"active\"&gt;新闻&lt;/li&gt; &lt;li&gt;电影&lt;/li&gt; &lt;li&gt;音乐&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"active\"&gt;金三胖来华访问&lt;/div&gt; &lt;div&gt;红海行动&lt;/div&gt; &lt;div&gt;fadden&lt;/div&gt; &lt;/div&gt; &lt;script&gt; /* * [思路] * 1. 给所有的Li绑定点击事件，当点击任何一个Lide时候，都做第二步骤 * 2. 可以先让所有的li &amp; div的class（className = ''）都为空，再让 当前点击的这个li和对应的div有active这个样式类即可 */ var tabBox = document.getElementById('tabBox'); var tabList = tabBox.getElementsByTagName('li'); var divList = tabBox.getElementsByTagName('div'); for (var i = 0; i &lt; tabList.length; i++) &#123; // tabList[i] : 每一轮循环当前要操作的对象 tabList[i]['myIndex'] = i; tabList[i].onclick = function() &#123; //事件绑定：给当前元素的某一个事件绑定一个方法，绑定的时候方法没有执行（属于创建一个方法），挡在页面中手动触发点击事件的时候绑定的方法才会执行 // tabList[i] // this代表当前的li changeTab(this.myIndex); &#125; &#125; /* * 自定义属性方案 obj.属性名 = 属性值 */ //=&gt; 封装一个方法，完成页卡切换 function changeTab(n) &#123; // n是形参，当执行这个方法的时候，会把当前点击的这个li的索引传递过来 //=&gt; 1. 所有都没有选中样式 for (var i = 0; i &lt; tabList.length; i++) &#123; tabList[i].className = ''; divList[i].className = ''; &#125; //=&gt; 2. 当前点击的有选中样式 tabList[n].className = 'active'; divList[n].className = 'active'; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 隔行变色12345678910111213141516171819 /* nth-child(N) : 当前容器所有子元素的第N个 .box li:nth-child(1): box容器中所有子元素中的第一个并且标签名是Li // 先获取第一个，在验证第一个是不是Li nth-of-type(n): 先给当前容器按照某一个标签名进行分组，获取分组中的第n个 .box li:nth-of-type(1) 先获取box中所有的li,再获取Li中的第一个 even 是偶数 odd 是奇数 */ ul.box &#123; list-style: none; &#125;/* .box li:nth-of-type(even) &#123; background-color: #0b5d81; &#125;*/ 1234567891011121314151617181920212223242526272829303132333435/* * document.getElementById 在整个文档中，通过元素的id获取元素对象 * getElementById 是获取元素的方法，document限定了获取元素的范围，我们把这个范围称之为：“上下文”[context] * class一般都是设置样式，id一般都是供js获取元素 * 1. 通过getElementById获取的元素是一个对象数据类型的值（里面包含内置的属性）typeof oBox =&gt; 'object' * 2. 分析包含的属性： * className:存储的是一个字符串，代表当前元素的样式类名； * id:存储的是当前元素的id值，也是字符串类型 * innerHTML: 存储当前元素中所有的内容，包含html标签 * innerText: 存储当前元素中所有的文本内容，不包含html标签 * onclick: 元素的一个事件属性，基于这个属性，可以给当前对象绑定事件 * onmouseover(鼠标滑过) onmouseout（鼠标离开） * style: 存储当前元素的 行内样式值 ；获取和操作的都只能是标签上的行内样式，写在样式表中的样式，无法基于这个属性获取到 */var oBox = document.getElementById('box');/* * 想要修改元素样式，有两种方法： * 1. 通过style修改行内样式 * 2. 基于className属性修改box的样式类，从而改变样式；oBox.className += \" bgColor\"; *//* * [context].getElementsByTagName ： 在指定上下文中，通过元素的标签名获取一组元素集合，上下文是我们自己来指定的 * 1. 获取的结果是一个元素集合(HTMLCollection)，它也是对象数据类型，结构和数组相似（数字索引，length代表长度），但是不是数组，我们把它叫做“类数组”； * 2. 通过索引获取到具体的某一个li即可， oList.length代表长度； * 3. 集合中的每一项存的值又是一个元素对象，包含很多内置属性，例如id/className */var oList = oBox.getElementsByTagName('li');//console.log(typeof oList);for (var i = 0; i &lt; oList.length; i++) &#123; if (i % 2 !== 0) &#123; // oList[i].style.backgroundColor = 'lightblue'; oList[i].className += 'bgColor'; &#125;&#125; 扩展：除自定义属性外，还有 let方案 柯里化 惰性函数123for(let i=0;i&lt;tabList.length;i++)&#123; changeTab(i); &#125; 函数执行的时候，都会形成一个全新的私有作用域（私有栈内存），目的是： 把原有堆内存中存储的字符串变为JS执行 保护里面的私有变量不受外界的干扰（和外界是隔离的）我么把函数执行的这种保护机制，称为闭包； 函数的入口：形参函数的出口：返回值 return 把函数运行的结果（或者函数体中的部分信息）拿到函数外面去使用return 返回的永远是一个值，即函数处理的结果fn(10,20) =&gt; 代表的是函数执行（不仅如此，他还代表函数执行后，返回的结果）如果当前函数没有return, 或者return啥也没有返回，则函数执行的结果是undefinedreturn 还有一个作用，类似与循环中的break,能强制结束函数体中的代码的执行 arguments形参是有自己的局限性的，我们需要具体的知道函数执行的时候传递的实参数量、顺序等，才可以使用形参变量定义对应的入口arguments:函数内置的实参集合（内置：函数天生就存在的机制，不管你是否设置了形参，也不管你是否传递了实参，arguments都有，始终存在） arguments 是类数组（不是数组，不能使用数组中的方法） 即使设置形参变量，形参该是什么值还是什么值，但是arg始终存储的是所有的传递进来的实参 argumnents.callee 存储的是当前函数本身 arguments.callee === fn1234567891011// 任意值求和 function sum() &#123; //console.log(arguments); var total = null; for (var i = 0; i &lt; arguments.length; i++) &#123; total += (isNaN(Number(arguments[i])) ? null : Number(arguments[i])); &#125; return total; &#125; console.log(sum(1, 2, '6')); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; #codeBox &#123; display: inline-block; width: 80px; height: 35px; line-height: 35px; border: 1px solid #aaa; text-align: center; font-size: 18px; letter-spacing: 5px; &#125; #link &#123; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"codeBox\"&gt;&lt;/div&gt; &lt;a id=\"link\" href=\"javascript:;\"&gt;看不清楚，换一张&lt;/a&gt; &lt;!--阻止a标签跳转--&gt; &lt;script&gt; /* * 生成一个四位随机验证码 * =&gt; 数字+字母 * =&gt; 照图片 * =&gt; 滑动拼图 * =&gt; 问答类 * =&gt; 点击汉字拼成语 * =&gt;把倒着的文字或者图片正过来 */ var codeBox = document.getElementById('codeBox'), link = document.getElementById('link'); //=&gt;编写一个生成四位随机验证码的方法 function queryCode() &#123; // 准备验证码获取的范围 //2.我们只需要准备四个索引，即可在codeare中通过charAt方法获取到四个字符，把四个字符拼接成字符串就是我们需要的验证码 var str = ''; for (var i = 0; i &lt; 4; i++) &#123; var char = codeArea.charAt(Math.floor(Math.random() * codeArea.length)); if (str.indexOf(char) &gt; -1) &#123; i--; continue; &#125; str += char; &#125;; return str; &#125;; function queryCode2() &#123; var codeArea = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890'; var result = ''; while (result.length &lt; 4) &#123; var n = Math.floor(Math.random() * 62); var char = codeArea.charAt(n); if (result.indexOf(char) === -1) &#123; result += char; &#125; &#125; return result; &#125; link.onclick = function() &#123; codeBox.innerHTML = queryCode(); &#125; codeBox.innerHTML = queryCode(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DOM及常用方法DOM树（DOM tree）当浏览器加载HTML页面的时候，首先就是DOM结构的计算，计算出来的DOM结构就是DOM树（把页面中的HTML标签像树状结构一样，分析出之间的层级关系）；window -&gt; document -&gt;htmlDOM树描述了标签和标签之间的关系，我们只要知道任何一个标签，都可以依据DOM中提供的属性和方法，获取到页面中任意一个标签或者节点 JS中获取DOM元素的方法getElementById通过元素的id获取指定的元素对象 document.getElementById,此处的document限定了获取元素的范围，我们称之为上下文context getElementById的上下文只能是document; 严格意义上一个页面中的id是不能重复的，浏览器规定在整个文档中即可以获取这个唯一的id 2.如果页面中的id重复了，我们基于这个方法，只能获取到第一个元素，后面相同的id元素，无法获取3.在IE67浏览器中能够，会把表单元素input的name属性值当作Id来使用（建议：以后使用表单元素的时候，不要让Name和id有冲突）[context]getElementsByTagName在指定的上下文中，根据标签名获取一组元素集合（HTMLCollection）；1.获取的元素集合是类数组，不能直接使用数组中的方法；2.它会把当前上下文中子子孙孙（后代）层级内的标签都获取到（获取到的不仅仅是子集元素）；3.基于这个方法，获取到的永远都是一个集合（不管里面是否有内容，也不管具体有多少项，他都是一个容器或者集合），如果想操作集合中的具体的某一项，需要基于索引获取才可以。[context]getElementsByClassName在指定的上下文中，基于元素的样式类名（class=’xxx’）获取到一组元素集合真实项目中，我们经常基于样式类来给元素设置样式，所以在JS中，我们也会经常基于样式类来获取元素，但是此方法在IE678下不兼容getElementsByName1.上下文只能是document,在整个文档中，基于元素的name值获取一组节点集合（也是一个类数组）2.在IE浏览器中（IE9及以下版本），只对表单元素的name属性起作用（正常来说，我们项目中只会给表单元素设置name,给非表单元素设置name,其实是一个不太合规范的操作）querySelector[context].querySelector()在指定的上下文中，基于选择器（类似于css选择器），获取到指定的节点对象（获取的是一个元素，哪怕选择器匹配了多个，我们只获取第一个）1document.querySelector('#id, .className,div'); querySelectorAll在querySelector的基础上，我们获取到选择器匹配到的所有元素，结果是一个节点集合；querySelector/querySelectorAll都是不兼容IE6-8(不考虑兼容的情况下，我们能用byid或者其他方式获取的，也尽量不要用这两个方法，这两个方法性能消耗大);document.head获取head元素对象document.body获取body元素对象document.documentElement获取html元素对象123// 获取浏览器一屏幕的宽度和高度（兼容所有浏览器）document.documentElement.clientWidth || document.body.clientWidthdocument.documentElement.clientHeight || document.body.clientHeight 面试题：获取当前页面中所有ID为haha的(兼容所有浏览器)123456789101112131415// 因为要兼容所有浏览器，不能使用querySelectorAll// 思路：1，获取当前文档中所有的Html标签// 2，依次遍历这些元素对象，谁的id等于haha,我们就把谁存储起来即可 function queryAllById(id) &#123; var nodeList = document.getElementsByTagName('*'); // 基于通配符*获取到所有的Html标签 // 遍历集合中的每一项，把元素ID和传递ID相同的这一项存储起来 var ary = []; for (var i = 0; i &lt; nodeList.length; i++) &#123; var item = nodeList[i]; id === item.id ? ary.push(item) : null; &#125; return ary; &#125;// 也可以直接使用 console.log(id), 因为浏览器中，JS默认会把元素的id设置为变量，不需要自己设置，而且id重复的话，获取的结果就是一个集合，包含所有ID项，不重复，就是元素对象 节点（node）在一个HTML文档中，出现的所有东西都是节点（标签、文字、注释） 元素节点(html标签) 文本节点（文字内容） 注释节点（注释内容） 文档节点（document） … 每一种类型的节点都会有一些属性区分自己的特性和特征 nodeType 节点类型 nodeName 节点名称 nodeValue节点值 元素节点nodeType: 1nodeName: 大写标签名nodeValue: null 文本节点nodeType: 3nodeName: ‘#text’nodeValue: 文本内容 在标准浏览器中，会把空格、换行都当作文本节点 注释节点nodeType: 8nodeName: ‘#comment’nodeValue: 注释内容 文档节点nodeType: 9nodeName: ‘#document’nodeValue: null 描述节点之间关系的属性parentNode获取当前节点唯一的父亲节点 childNodes获取当前节点的所有子节点（只获取儿子级别的,包含元素节点、文本节点等） children获取当前当前元素的元素子节点（在IE6-8下会把注释节点也当作元素节点，所以兼容性不太好） previousSibling获取当前节点的上一个节点（可能是元素，也可能是文本、注释等） previousElementSibling 获取当前节点的上一个元素节点（不兼容IE6-8） nextSibling获取当前节点的下一个节点 nextElementSibling 获取当前节点的下一个元素节点（不兼容IE6-8） firstChild获取当前节点的第一个节点 firstElementChild 获取第一个元素子节点（不兼容IE6-8） lastChild获取当前节点的最后一个节点 lastElementChild 获取当前元素的最后一个元素子节点（不兼容IE6-8） 需求一：获取当前元素的所有元素子节点 基于children 不兼容IE低版本浏览器，会把注释当作元素节点1234567891011121314151617/* * children: Get all the element nodes of the current element * @parameter: * curEle: [object]current element * return: [array] all the element nodes * by author on 2019/04/01 17:39 * update xx on xxxxx */function children(curEle) &#123; // 1获取当前元素下所有的子节点，2 遍历所有子节点，筛选出nodeType = 1的元素节点 var nodeList = curEle.childNodes, result = []; for (var i = 0; i &lt; nodeList.length; i++) &#123; nodeList[i].nodeType == 1 ? result.push(nodeList[i]) : null; &#125; return result;&#125; 需求二：获取当前元素的上一个元素节点123456789101112131415161718192021/* * prev ： Get prvious element node of the current node * @parameter * curEle: [object] current element * @return * [object] * by xx onxx */function prev(Ele) &#123; //先找当前元素的哥哥节点，看是否为元素节点，不是的话，基于该节点，找上一个节点，直到找到元素节点，或者找完为止（说明我是老大） var pre = Ele.previousSibling; while (pre &amp;&amp; pre.nodeType !== 1) &#123; /* * pre &amp;&amp; pre.nodeType !== 1 * pre是验证还有没有，这样写代表有，没有pre是null * pre.nodeType !== 1表示不是元素类型 */ pre = pre.previousSibling; &#125; return pre;&#125; 扩展： next下一个弟弟节点元素节点， prevAll获取所有哥哥元素的节点，nextAll获取所有弟弟元素节点， sibling获取所有兄弟元素节点，index获取当前元素的索引next下一个元素节点123456789101112131415/* * next ： Get next element node of the current node * @parameter * curEle: [object] current element * @return * [object] * by xx onxx */function next(Ele) &#123; var next = Ele.nextSibling; while (next &amp;&amp; next.nodeType !== 1) &#123; next = next.nextSibling; &#125; return next;&#125; prevALL所有的哥哥元素节点1234567891011121314151617/* * prevAll ： Get all the previous element nodes of the current node * @parameter * curEle: [object] current element * @return * [array] * by xx onxx */function prevAll(Ele) &#123; var ary = [], pre = Ele.previousSibling; while (pre) &#123; pre.nodeType === 1 ? ary.unshift(pre) : null; pre = pre.previousSibling; &#125; return ary;&#125; nextAll1234567891011121314151617/* * nextAll ： Get all the next element nodes of the current node * @parameter * curEle: [object] current element * @return * [array] * by xx onxx */function nextAll(Ele) &#123; var ary = [], next = Ele.nextSibling; while (next) &#123; next.nodeType === 1 ? ary.push(next) : null; next = next.nextSibling; &#125; return ary;&#125; 12345678910111213141516171819202122/* * sibling ： Get all the sibling element nodes of the current node * @parameter * curEle: [object] current element * @return * [array] * by xx onxx */function sibling(Ele) &#123; var pre = Ele.previousSibling; var ary = []; while (pre) &#123; pre.nodeType === 1 ? ary.unshift(pre) : null; pre = pre.previousSibling; &#125; var next = Ele.nextSibling; while (next) &#123; next.nodeType === 1 ? ary.push(next) : null; next = next.nextSibling; &#125; return ary;&#125; index12345678910111213141516171819/* * index ： Get index of the current node * @parameter * curEle: [object] current element * @return * number * by xx onxx */function index(Ele) &#123; var pre = Ele.previousSibling; var ary = []; while (pre) &#123; pre.nodeType === 1 ? ary.unshift(pre) : null; pre = pre.previousSibling; &#125; return ary.length;&#125; DOM的增删改createElement, createTextNode,appendChild, insertBefore,clone,removeChild,set/get/removeAttribute createElement创建一个元素标签/元素对象语法：document.createElement(标签名) appendChild把一个元素对象插入到指定容器的末尾[container].appendChild([newEle]); insertBefore把一个元素对象插入到指定容器中某一个元素标签之前[container].insertBefore([newEle],[oldEle]); cloneNode把某一个节点进行克隆[curEle].cloneNode(); 浅克隆，只克隆当前标签[curEle].cloneNode(true); 深克隆，当前标签及里面的内容都克隆过来 removeChild在指定元素对象中删除指定元素[container].removeChild([curEle]); set/get/removeAttribute设置/获取/删除当前元素的某一个属性1234567891011121314var newP = document.createElement('p'); newP.innerHTML = 'I am p'; document.body.appendChild(newP); var newA = document.createElement('a'); newA.innerHTML = 'I am a' document.body.insertBefore(newA, newP); // 把创建的a克隆一份放到body末尾 var cloneA = newA.cloneNode(); document.body.appendChild(cloneA); var cloneAB = newA.cloneNode(true); document.body.appendChild(cloneAB); document.body.removeChild(newP); var oBox = document.getElementById('box'); oBox.myIndex = 10; 把元素当作一个对象，在对象对应的堆内存中新增一个自定义属性oBox.myIndex =10// 设置 oBox[‘myIndex] // 获取delete oBox[‘myIndex] // 删除 // =&gt;基于attribute等DOM方法完成自定义属性的设置oBox.setAttribute(‘mycolor’,’red’);oBox.getAttribute(‘mycolor’);oBox.removeAttribut(‘mycolor); 上下两种机制属于独立的运作体制，不能互相混合使用第一种是基于对象键值对操作方式，修改当前元素的堆内存空间来完成第二种是直接修改页面中的HTML标签的结构来完成（此种办法设置的自定义属性可以在结构上呈现出来） 基于setAttribute设置的自定义属性值都是字符串 需求：解析一个URL字符串问好传参和HASH值部分1234567891011121314151617181920212223242526function queryURLParameter(str) &#123; //1.创建一个a标签，把需要解析的地址当作a标签的href赋值 var link = document.createElement('a'); link.href = str; //页面中不需要展示a，我们只是想要利用它的属性而已，所以无需添加到页面当中 //2.a元素对象的HASH和search两个属性，分别存储了哈希值和参数值 var search = link.search.substr(1), hash = link.hash.substr(1); // 3. 分别解析出HASH和参数即可 var obj = &#123;&#125;; hash ? obj.HASH = hash : null; if (search) &#123; //先按照&amp;拆分， search = search.split('&amp;'); for (var i = 0; i &lt; search.length; i++) &#123; var itemAry = search[i].split(\"=\"); obj[itemAry[0]] = itemAry[1]; &#125; &#125; return obj;&#125;var str = 'https://wwww.zhufengpeixun.cn/stu?lx=1&amp;name=AA&amp;age=20#teacher';var obj = queryURLParameter(str);console.log(obj); 扩展：原生JS获取元素样式ele.style获取元素的行内样式，这个必须是写在行内的style属性里面的才能获取到，卸载其他地方（比如&lt;head&gt;&lt;/head&gt;中的&lt;style&gt;&lt;/style&gt;里面或者引入的css样式表里面就无法获取到） getComputedStyle()获取当前元素所有css属性的方法。语法： window.getComputedStyle(‘元素对象’[，’伪类’]);12var obj = document.getElementById('id');var cssStyleCollectiion = window.getComputedStyle(obj, null); getPropertyValue()获取css样式某一属性的值，只可读，需要与getComputedStyle结合使用123var obj = document.getElementById('id');var cssStyleCollection = window.getComputedStyle(obj, null);var bgColor = cssStyleCollection.getPropertyValue('background-color');","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://abluecup.github.io/tags/javascript/"}]},{"title":"NPM & GIT概念解析","slug":"NPM Git","date":"2019-03-13T01:35:00.000Z","updated":"2020-04-23T05:11:47.290Z","comments":true,"path":"2019/03/13/NPM Git/","link":"","permalink":"https://abluecup.github.io/2019/03/13/NPM Git/","excerpt":"我们在引入插件和管理项目的时候，常常会使用到npm和git,本篇将对它们做详细的介绍：","text":"我们在引入插件和管理项目的时候，常常会使用到npm和git,本篇将对它们做详细的介绍： node并不是一门语言，它是一个工具或者环境， 基于V8引擎（webkit）渲染和解析JS的； 单线程； 无阻塞I/O操作； 事件驱动之所以把node称为服务器端语言，是因为node基于JS操作服务器端的能力：我们在服务器端安装node,使用JS完成服务器端需要处理的一些事情，最后把写好的js代码交给Node环境运行即可； 在node环境中把JS代码执行 REPL命令（Read - Evaluate -Print -Loop:输入-求职-输出-循环） // 先执行node 基于node xxx.js命令执行 基于WB这类编辑工具直接执行 常用DOS命令ping www.baidu.com -t : 测试网速Ctrl + c : 结束当前正在运行的操作exit: 退出当前窗口ipconfig -all ：查看当前电脑的Ip地址 物理地址 子网掩码 DNS等信息cls: 清屏cd + 详细目录地址： 切盘 （win里面不能切磁盘，切磁盘的时候直接E: 打磁盘名称加:）cd .. 返回上级目录cd ./ 当前目录cd / 根目录dir 查看当前目录下文件mkdir 创建目录copy con xx.xx 创建文件 ctrl + c 保存并退出del xx.xx 删除文件rmdir xx 删除目录 NPM模块管理安装完成Node之后，基本上自带npm模块管理器我们需要一个第三方（别人写的）模块、插件、类库、框架等，需要提前下载安装才可以使用 百度搜索，找到下载地址，然后基于浏览器下载即可（资源比较混乱，不好搜索） 也可以基于npm等第三方包管理器下载（yarn bower …都是第三方模块管理器） npm下载资源都是在http://www.npmjs.com/中下载的npm install xxx：把资源或者第三方模块下载到当前目录下npm install xxx -g (--global): 把资源或者第三方模块安装到全局环境下（目的：以后可以基于命令来操作一些事情）npm uninstall xxx: 从本地卸载 基于npm的一些细节点 需要联网（基于npm是从国外服务器上下载资源，所以下载速度较慢） 下载成功后，当前目录中多增加一个node_modules文件夹，在这个文件夹中找到我们安装的模块 一般来说，下载下来的内容包含源码和最后宫开发者使用的压缩版本 解决下载慢的问题 123456789101112131. 基于nrm切换到国内下载源（一般是淘宝镜像） 1&gt; 安装nrm到全局环境（因为我们需要使用命令） npm install nrm -g 2&gt; 安装完成之后，我们可以使用nrm命令 nrm ls 查看当前可用源 nrm use xx 使用某个源 // nrm use taobao 切换源还是基于npm安装2.可以基于yarn来安装 1&gt; 安装yarn到全局环境中,然后基于yarn安装我们需要的模块 ,只能安装到本地，不能安装到全局 yarn add xx yarn remove xx 安装了一个新的模块管理器3 基于cnmp淘宝镜像来处理 安装了一个新的管理器 3.解决版本安装问题 1)首先查看当期那模块的历史版本信息 npm view jquery &gt; jquery.version.json 把当前模块的历史信息输出到具体的某个文件中（文件名自己随便起） 2） 安装指定的版本 npm install jquery@1.11.3 @后面 + 版本号 yarn add jquery@1.11.3 课后扩展： bower是从github下载安装，熟悉下它的使用； 在全局中安装less/babel-cli githubgithub是一个提供代码管理的公共平台，我们以及众多开发者会把自己生产的组件、类库、插件、框架等托管到这个平台中，供别人使用和研究。github中，我们可以创建仓库来管理自己的项目文件，而github支持开发者通过git操作，把本地的项目代码推送到指定的仓库中，它还提供静态的web页面的发布等。国内有一个和github类似的网站：coding，和github类似，也是提供代码管理的平台。 基于github创建仓库，管理代码 Git基础管理 git是一个分布式代码版本管理控制系统 记录当前产品代码的所有版本信息，而且方便快速回退到某一个具体的版本； 方便团队协作开发，能够检测代码冲突，能够合并代码等； 123svn: 在git诞生前就已经存在的版本控制系统，不过他是集中式管理git: 是分布式代码管理系统 1） 集中式版本控制系统 中央服务器：版本信息记录，和最新代码管理都在这；每次开发前，需要从中央服务器把代码拉取下来；本地开发完成后，在提交到中央服务器上（但是没提交之前，本次内容不是一个新的版本） 提交一次，记录一个新的历史版本（当前版本的代码就存储起来了，以后可以对比或者回滚到这个版本）2） 分布式版本控制系统 每个开发者的本地都是一个git仓库，在本地就可以生成历史版本 集中服务器用来(github) 本地仓库：自己的代码和版本信息同步或推送到中央服务器 CDN加速 地域式服务器分布管理 git的工作管理和基础操作 在本地创建git仓库,管理本地代码 初次使用git,先在本地配置一些基础信息 12345$ git config -l $ git config --global user.name xxx$ git config --global user.eamil xxxx# 配置用户名和用户邮箱和gitHub保持一致（这样以后在本地想gitHub推送内容的时候，能够展示出是谁推送的） 1$ git init // 初始化目录，创建仓库 会在当前目录中创建一个空的仓库，文件目录中生成一个.git的隐藏文件，这个文件和重要，我们本地仓库的版本信息 在当前目录(git仓库根目录)创建一个 ‘.gitignore’文件. 这个文件中存储了当git提交的时候所忽略的文件 可以基于WB创建基于Linux命令 $touch .gitignore 1234567891011121314151617181920212223# dependenciesnode_modules# testing/coverage# production/build# misc.DS_Store.env.local.env.development.local.env.test.local.env.production.local# npm or yarnnpm-debug.log*yarn-debug.log*yarn-error.log*# webStorm.idear 12345678910111213141516171819//数据交换var a=1;var b=2;var c = a;a = b;b =c;var e =10;var f =20;e = e + f;f = e -f;e = e -f;var m = 100;var n =200;[m,n] = [n,m];console.log(m);console.log(n); GIT工作原理及操作当我们在本地创建一个git仓库后，我们可以基于这个仓库管理我们的代码； git的工作流程 每一个git仓库都划分为三个区 工作区：编辑代码的地方 暂存区：临时存储要生成版本代码的地方 历史区： 存储是的生成的每一个版本代码 123456789101112131415161. 工作区到暂存区$ git status 查看文件的状态，按颜色区分：红色表示当前文件在工作区，还没有提交到暂存区；绿色表示文件在暂存区，还没有提交到历史区；如果没有文件，表示三个区域代码已经同步；$ git add .gitignore$ git add -A // 所有$ git add . // 所有工作区提交到暂存区，暂存区提交到历史区。暂存区始终存放提交的内容，并不消失。以后工作区有内容修改，会和暂存区做对比，以此来判断哪些是新处理的。2. 暂存区到历史区$ git commit这样执行后，会弹出一个提交文本输入界面，需要我们编写本次提交到离市区，给当前版本填写备注信息；$ git commit -m &apos;自己需要编写的备注信息&apos;; git和github同步1.让本地仓库和远程仓库建立关联12345678$ git remote -v查看所有关联信息$ git remote add xx [远程仓库git地址] 建立关联$ git remote remove xxx移除关联 我们远程仓库关联在一起的名字默认是： origin， 当然自己可以随意修改 把本地的代码推送到远程仓库上，或者从远程仓库上拉去最新的信息到本地仓库 我们本地推送和拉取的信息，既有代码也有版本信息，所以说与其说是推送和拉取，不如说是和远程仓库保持信息的同步； 123456在同步之前，我们都应该先拉取$ git pull origin (这个名字就是和远程仓库管理啊的名字，以自己设置的为主) master从远程仓库master分支拉取信息；$ git push origin master把本地信息推送到远程仓库master分支下。 以上是操作知识点，真实项目开发流程如下：1.LEADER会首先创建一个远程仓库（这个仓库可能是空的，也可能是包含了项目需要的基础的结构信息）； 作为开发者我们需要在本地创建一个本地仓库，还需要让当前本地的仓库与远程仓库保持关联 123456原始做法：git initgit remote add origin [git 仓库地址]简单做法：git clone [远程仓库地址]（克隆后的名字，可以不设置，默认是仓库名） 在本地开发产品，需要同步的时候，我们首先把工作区内容放到历史区，生成版本信息（git add . / git commit -m ‘’ ），再把本地试试去的信息推送到远程仓库上： （git pull/ git push） 在团队协作开发的时候，leader会在自己的github账号下创建一个远程仓库，那么团队其他成员在向这个远程仓库推送信息的时候，使用自己的账号是没有推送权限的，我们需要把当前这个远程仓库，在github中创建工作群组，让更多人用自己的账号也有操作权限小组成员在自己的邮箱中收到一份邀请邮件，确认参加；","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://abluecup.github.io/tags/git/"}]},{"title":"css基础","slug":"css基础","date":"2019-03-11T08:37:23.000Z","updated":"2020-05-20T01:56:39.012Z","comments":true,"path":"2019/03/11/css基础/","link":"","permalink":"https://abluecup.github.io/2019/03/11/css基础/","excerpt":"本篇是对CSS基础知识的阐述。","text":"本篇是对CSS基础知识的阐述。 行内元素和块级元素的特点行内元素 a button big span input td datalist em i strong s b small u sup sub input mark select textarea 1，不独占一行 2, 排列方式： 左-&gt;右 3，设置宽高不起作用，它的宽高是它本身内容的宽高。如果要要起作用，需要转化为块|行内块 block|inline-block; 4，天生自带 display:inline; 6, 行内元素不能嵌套块(a除外)，a里面也不能嵌套a 块级元素 table dl dt dd figure figcaption div hr h1-h6 ul li ol nav header footer section main p 1，独占一行 2, 排列方式： 上-&gt;下 3, 可以设置宽高和盒子模型的其他属性，不设置宽高的情况下，它的宽度是父元素的宽度，高度是本身内容的高度。 4, 天生自带 display:block; 5，块级元素可以嵌套行内(ul,ol下面只能是Li，dl下面只能是dt dd, p元素里面不能嵌套任何块级元素，包括它自己，可以嵌套行内元素) 行内块 img input display: inline-block 标签语义化1，有利于SEO优化2，样式丢失的时候，也可以很好的呈现结构3，更好的支持各种终端，例如无障碍阅读和有声小说4，增强代码可读性，利于团队开发和维护 技巧1，尽量减少无意义标签的使用 div, span2, 尽量不使用标签本身的css属性，例如b, s等标签，如果需要，那么使用css样式进行添加3，在需要强调的部分，使用strong,em， 但是样式尽量用css样式描述4，表格搭建时，使用表格头部表格内容表格尾部5，列表搭建时，使用ul ol dl列表 css引入方式-外链式和导入式的区别1，link是html标签，@import完全是css提供的方式，要卸载css文件或者style标签中2，加载顺序不同，页面加载的时候，link引入的css文件会同时加载，而@import导入的文件则需要在页面加载完成后再加载3，使用js控制DOM去改变css样式的时候，只能使用link标签，因为import不受DOM控制123&lt;style&gt;@import 'index.css';&lt;/style&gt; css常用命名头： header内容： content | container尾部： footer导航： nav侧栏： sidebar栏目：column页面外围控制整体布局宽度：wrapper左右中： left right center登录条； loginbar标志： logo广告： banner页面主体： main热点：hot新闻：news下载：download子导航： subnav菜单： menu子菜单： submenu搜索：search友情链接： friendlink版权： copyright投票：vote合作伙伴 partner滚动：scroll内容：content标签页：tab文章列表: list提示信息: msg小技巧： tips栏目标题：title加入： joinUs指南：guild服务：service注册: register状态：status css伪类a:link 没有访问之前a的样式，一般不用a:visiteda:hovera:activeinput:focus css3新增的选择器：:not():nth-of-type(1) 集合中第一个元素:first-of-type 第一个:last-of-type 最后一个:nth-child(n) n表示数字，odd/2n+1表示奇数，even/2n表示偶数 ,第几个子元素:first-child 第一个子元素:last-child 最后一个子元素:only-child 匹配没有任何兄弟元素的元素.等效的选择器还可以写成 :first-child:last-child或者:nth-child(1):nth-last-child(1):only-of-type 没有兄弟元素的元素:empty 内容为空的元素:checked 被选中 css元素p:first-line 第一行p:last-line 最后一行p:first-letter 第一个字母/数字/汉字:before{ 元素之前添加内容 content:’’ // 不能省略，即使没有内容}:after{ 元素之后添加内容 content:’’ // 不能省略，即使没有内容}只要碰到:before, :after 就要加content:’’,只要宽度不起作用，就要设置display:block|inline-block; 权重和权重计算【基本选择器】标签选择器 1类选择器 10id选择器 100通配符选择器* 0-1 后代子代交集并集相邻兄弟兄弟 =&gt; 权重：每个单独的基本选择器的相加之和 属性伪类伪元素 权重相同的情况下：遵循就近原则，下面的会覆盖上面的权重相同的情况下，不遵循就近原则，就想遵循上面的样式，加!important; css中可继承和不可继承的属性无继承的属性1, diplay2, 文本属性vertical-aligntext-decorationtext-shadowwhite-spaceunicode-bidi… 3盒子模型属性width,height,margin,padding,border… 4,背景属性background,background-color… 5，浮动 6，定位类 可继承属性1，字体系列属性font,font-size,color,font-weight,…2, 文本系列属性text-alignline-heightword-spacingtext-indent margin的兼容和传递margin的兼容问题：margin-top的传递问题大盒子里面嵌套小盒子，给小盒子加margin-top值，不但没有实现和大盒子之间的间距，反而传递到大盒子上，导致机体下移。解决方法1，父元素overflow:hidden; 不是溢出隐藏，是为了解决margin-top的传递问题2，父元素padding-top: 20px; 这种方法会影响最后实际的宽高，需要在width/height的基础上减掉，才不会影响实际的宽高。3，父元素添加边框 border: 颜色最好使用通明， transparent overflow:hidden的多种作用1，溢出隐藏2，清除子元素浮动对父元素产生的影响3，解决子元素margin-top的传递问题 面试题多个元素在一行显示1，display: inline | inline-block. inline-block 中间会有空格, 给父元素添加 font-size:0;的属性，此时子元素的字体继承了父元素的font-size属性，需要重新设置 (推荐使用) display:inline-block;在IE(6-7)中不兼容： dispaly:inline;(css hack) zoom:1;(触发layout)2，利用浮动，需要清浮动 单行文本出现省略号123456&#123; /*设置一定的宽度*/ overflow:hidden; /*溢出隐藏*/ white-space:nowrap; /*强制不换行*/ text-overflow:ellipsis; /*文字以省略号的样式隐藏*/&#125; 多行文本出现省略号123456&#123; display:-webkit-box; /*弹性盒子模型*/ -webkit-box-orient:vertical; /*规定元素的排列方式：垂直方向*/ -webkit-line-clamp:2; /*文字的行数*/ overflow:hidden;&#125; float浮动元素的特点1，在一行显示2，设置left,从左向右排列；right,从右向左浮动3，脱离文档流，导致下面没有浮动的元素会往上跑，占领浮动元素的位置4，父元素浮动，子元素会跟随父元素的浮动来到新的位置，但是子元素不会继承浮动属性，子元素之间的排列不会发生变化；如果也让子元素在一行显示，那就给子元素也加上浮动。5，浮动元素自动具有块元素的特点，可以设置行高.不管浮动元素是块元素还是行内元素6，所有元素都可以使用浮动属性，浮动元素下面的元素无法识别浮动元素的位置和高度。 文档流和脱离文档流文档流：指的是元素的排列方式，正常情况下，从左往右，从上往下排。 行内元素和块级元素的特点 需求：多个块级元素在一行显示 脱离文档流：元素的正常排列方式会被打破1，float2, 定位 浮动产生的影响1，给父元素设置背景颜色不起作用；2，给父元素设置边框border属性没有被撑开；3，给父元素设置内边距padding属性也没有被撑开 clear:left; 元素的左边不允许有浮动元素；clear:right; 元素的右边不允许有浮动元素；clear:both; 元素的两边不允许有浮动元素；clear:none; 元素两边允许有浮动元素 清除浮动的方法 1, 给父元素手动添加一个height;(不推荐使用)2, 给父元素设置 overflow:hidden|auto;3, 在浮动元素结束标签之前加一个具有块元素特点的标签，给元素添加一个 clear:both; &lt;span style=&quot;display:block;clear:both;&quot;&gt;&lt;/span&gt;4, clearfix1234567891011121314.clearfix:after&#123; content:''; display:block; clear:both; /* 可以省略的属性 */ height:0; font-size:0; overflow:hidden; visibility:hidden;&#125;.clear&#123; *zoom:1; /*兼容IE7及以下*/&#125; overflow:hidden, visibility:hidden, display:none之间的区别 overflow:hidden 是超出盒子的内容隐藏；display:none; 盒子完全从页面中消失，不在占据文档流；visibility:hidden; 盒子隐藏，但是所占的大小依然还在opacity:0; 不透明度为0 :before, :after都是行内元素 z-index1，默认是书写顺序在后的元素覆盖书写在前的元素；2，可以使用z-index属性修改层级关系；3，所有定位元素的默认值都是一样的；4，没有单位，支持负数；5，一般都是同级元素进行比较6， 当参照物是绝对或者相对定位的时候，父级元素之间没有z-index值，子元素的z-index值会出来做比较；","categories":[],"tags":[]},{"title":"在Github搭建博客（二）","slug":"config-theme","date":"2018-06-05T08:45:35.000Z","updated":"2019-06-27T09:38:03.290Z","comments":true,"path":"2018/06/05/config-theme/","link":"","permalink":"https://abluecup.github.io/2018/06/05/config-theme/","excerpt":"在搭建好博客之后，我们会选择博客的主题，本篇就是对这一问题的介绍","text":"在搭建好博客之后，我们会选择博客的主题，本篇就是对这一问题的介绍 选择主题我们搭建好博客后，会选择其他的主题而不是hexo自身携带的主题。网上可以搜索到许多的主题，可以击这里查看。我最初选择的是yilia，后来因为嫌字体太大（16px),想修改字体的大小，弄了半天也没弄好，干脆就放弃了，选择了next(它的字体是14px)。 安装next next的地址README中详细地介绍了next的安装方法，我之前在windows10中安装了git，所以选择的方法是在git bash控制台切换到blog目录下输入命令1git clone https://github.com/iissnan/hexo-theme-next themes/next 之后在目录 blog/theme/下会看到目录 next,里面包含了next的主题文件。我们此时打开blog的 _config.yml 文件，找到theme那一行，主题修改为next，如下图所示在cmd控制台依次运行命令123hexo generatehexo server 在浏览器中输入 localhost:4000就可以查看了 next配置的选择建议先阅读整篇文档，尤其是里面的英文注释，有助于帮助理解。在这里，我写下自己做的配置 布局样式的选择四个布局样式都很不错，简洁大方，选择比较随意。 social的选择 menu 的选择 遇到的问题的解决方法标签和分类页面打不开安装和配置好next后，点击标签页和分类页，都出现了Error.原因是找不到页面。在menu的选择图中可以看到，我们将标签和分类的路径设置为 /tags/和/categories/，但是实际上这两个路径并不存在，这就需要我们新建这两个路径,在blog根目录下输入下面的命令行123hexo new page &quot;tags&quot;hexo new page &quot;categories&quot; 路径建好了，我到相应的路径下找到对应的页面进行修改，tags的页面中，要添加type: &quot;tags&quot;,categories的页面中，要添加type: &quot;categories&quot;,如下图所示 如何插入图片图片可以使用本地图片，也可以使用网络服务器上的图片，储存图片的服务器，叫图床。（图柜也比图床好理解吧） 修改hexo的配置文件_config.yml,找到post_asset_folder,将它的值改为true. 这样，当你hexo new &quot;post&quot;的时候，会生成与文件名相同的目录 安装hexo-asset-image插件，它是一个图片路径转换的插件， 1npm install https://github.com/CodeFalling/hexo-asset-image --save 之后就可以将图片放入相应的文件目录中，使用Markdown语法插入图片了 1![alt name](name.png) 这里有一个需要注意的地方就是，图片格式的大小写要一致，比如png不能写成PNG，至于为什么，还不清楚","categories":[{"name":"系统","slug":"系统","permalink":"https://abluecup.github.io/categories/系统/"}],"tags":[{"name":"搭建环境","slug":"搭建环境","permalink":"https://abluecup.github.io/tags/搭建环境/"}]},{"title":"vim的使用","slug":"vim的使用","date":"2018-06-04T09:00:52.000Z","updated":"2020-04-23T05:04:16.221Z","comments":true,"path":"2018/06/04/vim的使用/","link":"","permalink":"https://abluecup.github.io/2018/06/04/vim的使用/","excerpt":"Vim 是高度可配置的编辑器，用于高效创建和修改各类文本。它包含在UNIX系统和苹果 OS X 系统的 vi中。","text":"Vim 是高度可配置的编辑器，用于高效创建和修改各类文本。它包含在UNIX系统和苹果 OS X 系统的 vi中。 参考链接http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/https://coolshell.cn/articles/5426.html上面的博客无论是原文还是翻译都比较有趣，本文是对这两篇博客的阅读笔记。 vim是什么？Vim is a highly configurable text editor for efficiently creating and changing any kind of text. It is included as “vi” with most UNIX systems and with Apple OS X.官网上的解释如上，翻译下就是： Vim 是高度可配置的编辑器，用于高效创建和修改各类文本。它包含在UNIX系统和苹果 OS X 系统的 vi中。 学习VIM的四个阶段（Survive）存活 i 进入insert模式（插入模式），按Esc回到Normal模式（普通模式）；x 删除当前光标所在的一个字符；:wq w(存盘) q(退出)；dd 删除当前行；p 粘贴hjkl 按照左下上右的顺序移动光标:help 命令的说明 (Feel Comfortable) 感觉舒适1、Insert mode variations（插入字符或行的命令）: a -&gt; 在光标后插入字符；o -&gt; 在当前行下插入新的一行；O -&gt; 在当前行上插入新的一行；cw -&gt; 删除当前光标所在位置的字符到一个单词结尾的字符 2、(Basic moves) 基本的移动命令 hjkl-&gt; 左下上右0 -&gt;(数字0) 移动到当前行的第一个字符；$ -&gt; 移动到当前行的最后一个字符；^ -&gt; 移动到不是blank的第一个字符；g_ -&gt;移动到不是blank的最后一个字符；/pattern -&gt;寻找字符pattern 3、(copy/paster)复制粘贴 yy -&gt; 复制；p -&gt; 粘贴； 4、(Undo/Redo)撤销/重复 u 撤销之前一步的动作；ctr-r 重复之前的命令 5、Load/Save/Quit/Change File (Buffer)下载/保存/退出/改变 文件（缓冲），即对已经完成的文件和正在修改的文件操作的命令 :e&lt;path/to/file&gt; 打开一个文件:saveas &lt;path/to/file&gt; 文件另存为:w 保存但是不退出;:x ZZ :wq 保存并退出:q! 退出但是不保存；:qa! 强制退出:bn :bp 展示下一个文件（同时打开多个文件的时候使用） (Better. Stronger. Faster.)更好 更强 更快Better . (点)重复上一个命令N 重复命令N次举例说明: 2dd 删除两行3p 粘贴文本3次100idesu[ESC] 写一百遍desu. 再写一百遍desu 再写3遍desu Stronger N(G) 光标移动到行Ngg 光标移动到第一行G 光标移动到最后一行Word moves w 移动到下一个word的首字母e 移动到本word的结尾W(大写) 定义WORD是一组word,以blank隔开，移动到下一个WORD的开头E 移动到本WORD的结尾 和 # ，移动到光标所在word相匹配的下一个word,或者上一个word * 下一个，# 上一个% 匹配括号移动，包括 (, {, [.(不理解什么意思) Faster一般的命令格式 &lt;command命令&gt;&lt;结束位置&gt;举例说明0y$ 0 表示光标移动到本行的开始位置；y 开始复制$ 复制到本行结束 另外附加的三个命令v 可视化gU 变成大写gu 变成小写 Vim SuperPowers(Vim超级编辑器)Move on current line (0 ^ $ g_ f F t T , ;) 在当前行移动命令(0 ^ $ g_ f F t T , ; 0 → go to column 0^ → go to first character on the line$ → go to the last columng_ → go to the last character on the linefa → go to next occurrence of the letter a on the line., (resp. ;) will find the next (resp. previous) occurrence.t, → go to just before the character ,.3fa → find the 3rd occurrence of a on this line.F and T → like f and t but backward.","categories":[{"name":"系统","slug":"系统","permalink":"https://abluecup.github.io/categories/系统/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://abluecup.github.io/tags/vim/"}]},{"title":"在Github上搭建博客","slug":"在Github上搭建博客","date":"2018-05-30T07:04:47.000Z","updated":"2020-05-20T01:57:29.529Z","comments":true,"path":"2018/05/30/在Github上搭建博客/","link":"","permalink":"https://abluecup.github.io/2018/05/30/在Github上搭建博客/","excerpt":"写在前面 为什么自己搭建博客？ 知乎上有关于这个问题的很详尽的回答？链接：https://www.zhihu.com/question/19916345。 参考链接 教你免费搭建个人博客。 系统 windows 10 64位，编辑器：sublime text3，控制台：cmd","text":"写在前面 为什么自己搭建博客？ 知乎上有关于这个问题的很详尽的回答？链接：https://www.zhihu.com/question/19916345。 参考链接 教你免费搭建个人博客。 系统 windows 10 64位，编辑器：sublime text3，控制台：cmd 搭建博客使用 hexo+Github 什么是hexo?Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。官方文档 什么是Github?GitHub is a development platform inspired by the way you work. From open source to business, you can host and review code, manage projects, and build software alongside millions of other developers. (GitHub是一个受你工作方式启发的开发平台。 从开源到商业，您可以托管和查看代码，管理项目，并与数百万其他开发人员一起构建软件。) click me 准备工作 配置 Github首先，你需要有一个Github的账号。在Github网站上注册账号，并记住自己的Username。我的Username是abluecup。登录，在网页左上方找到 New repository 按钮，点击创建名称为username.github.io的仓库。我的是username是abluecup,我创建的仓库名称就是abluecup.github.io 环境搭建 安装Node.js https://nodejs.org/en/ 安装 Git https://github.com/waylau/git-for-winNode.js和Git的安装，我都是全部默认安装的。当然，你可以根据自己的需要安装。关于Git的教程，推荐廖雪峰的教程。在这里给自己刨个坑，自己以后也会写关于Git的博客。-安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，打开界面：输入 123git config --global user.name &quot;username&quot;git config --global user.email &quot;your email&quot;# username是你注册Github的username,your email是你注册Github时的email 安装Hexo打开cmd, 安装hexo,输入命令然后等待hexo安装完成： 1npm install -g hexo-cli 初始化博客 新建目录test. 进入gitbash控制界面，切换目录到test目录下，输入： 123hexo init blog# 成功提示INFO Start blogging with Hexo! 初始化完成之后，切换目录到blog下，输入命令： 1$ hexo generate 12345# 启动本地服务器$ hexo server# 在浏览器输入 http://localhost:4000/就可以看见网页和模板了INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问 http://localhost:4000/ ，我们会看到网站初始的模样 设置秘钥现在我们可以暂时关闭hexo的本地服务，在git的管理界面输入以下命令:1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一路按Enter键过来就好，最后会得到信息： 1Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. 找到该文件，打开（sublime text），Ctrl + a复制里面的所有内容，然后进入Sign in to GitHub：https://github.com/settings/sshNew SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key 配置博客在blog目录下，用sublime打开_config.yml文件，修改参数信息特别提醒，在每个参数的：后都要加一个空格修改网站相关信息12345678# Sitetitle: 卡而的博客subtitle:副标题description: 描述keywords:关键词author: 作者language:zh-CNtimezone:Asia/Shanghai 配置部署（我的是abluecup，修改成自己的）1234deploy: type: git repo: http://github.com/ABlueCup/ABlueCup.github.io branch: master 发布文章1hexo deploy 后续更新：MarkDown语法链接 遇到的问题： 执行 hexo deploy时，出现错误 error deployer not found:git执行如下代码 1npm install hexo-deployer-git --save 执行 hexo clean , hexo generate , hexo server , hexo deploy等命令时，当前目录必须是在博客根目录下，即 blog/ 文件夹 blog里面","categories":[{"name":"系统","slug":"系统","permalink":"https://abluecup.github.io/categories/系统/"}],"tags":[{"name":"搭建环境","slug":"搭建环境","permalink":"https://abluecup.github.io/tags/搭建环境/"}]},{"title":"反思室","slug":"反思室","date":"2018-01-27T06:59:51.000Z","updated":"2020-06-30T07:23:38.513Z","comments":true,"path":"2018/01/27/反思室/","link":"","permalink":"https://abluecup.github.io/2018/01/27/反思室/","excerpt":"“吾日三省吾身，为人谋而不忠乎，与朋友交而不信乎，传不习乎？” —— 曾参","text":"“吾日三省吾身，为人谋而不忠乎，与朋友交而不信乎，传不习乎？” —— 曾参 金刚经金刚经 第一品 法会因由分 如是我闻，一时，佛在舍卫国祗(zhī)树给孤独园，与大比丘众千二百五十人俱。尔时，世尊食时，著衣持钵，入舍卫大城乞食。于其城中，次第乞已，还至本处。饭食讫，收衣钵，洗足已，敷座而坐。[^_^]: 金刚经 第二品 善现启请分 时，长老须菩提在大众中即从座起，偏袒右肩，右膝着地，合掌恭敬而白佛言：“希有世尊！如来善护念诸菩萨，善付嘱诸菩萨。世尊！善男子、善女人，发阿耨/nòu/多罗三藐三菩提心，云何应住，云何降伏其心？”佛言：“善哉，善哉。须菩提！如汝所说，如来善护念诸菩萨，善付嘱诸菩萨。汝今谛听！当为汝说：善男子、善女人，发阿耨多罗三藐三菩提心，应如是住，如是降伏其心。”“唯然，世尊！愿乐欲闻。” 金刚经 第三品 大乘正宗分 佛告须菩提：“诸菩萨摩诃萨应如是降伏其心！所有一切众生之类：若卵生、若胎生、若湿生、若化生；若有色、若无色；若有想、若无想、若非有想非无想，我皆令入无余涅盘而灭度之。如是灭度无量无数无边众生，实无众生得灭度者。何以故？须菩提！若菩萨有我相、人相、众生相、寿者相，即非菩萨。”[^_^]: 金刚经 第四品 妙行无住分 “复次，须菩提！菩萨于法，应无所住，行于布施，所谓不住色布施，不住声香味触法布施。须菩提！菩萨应如是布施，不住于相。何以故？若菩萨不住相布施，其福德不可思量。 须菩提！于意云何？东方虚空可思量不？”“不也，世尊！”“须菩提 南西北方四维上下虚空可思量不不也，世尊须菩提 菩萨无住相布施 福德亦复如是，不可思量。须菩提 菩萨但应如所教住[^_^]: 金刚经 第五品 如理实见分 “须菩提！于意云何？可以身相得见如来不？”“不也，世尊！不可以身相得见如来。何以故？如来所说身相，即非身相，是名身相。”佛告须菩提：“凡所有相，皆是虚妄。若见诸相非相，即见如来。”[^_^]: 金刚经 第六品 正信希有分 须菩提白佛言：“世尊！颇有众生，得闻如是言说章句，生实信不？”佛告须菩提：“莫作是说。如来灭后，后五百岁，有持戒修福者，于此章句能生信心，以此为实，当知是人不于一佛二佛三四五佛而种善根，已于无量千万佛所种诸善根，闻是章句，乃至一念生净信者，须菩提！如来悉知悉见，是诸众生得如是无量福德。何以故？是诸众生无复我相、人相、众生相、寿者相；无法相，亦无非法相。何以故？是诸众生若心取相，则为著我人众生寿者。若取法相，即著我人众生寿者。若取非法相，即著我人众生寿者，是故不应取法，不应取非法。以是义故，如来常说：‘汝等比丘，知我说法，如筏喻者；法尚应舍，何况非法。’” 金刚经 第七品 无得无说分 “须菩提！于意云何？如来得阿耨多罗三藐三菩提耶？如来有所说法耶？”须菩提言：“如我解佛所说义，无有定法名阿耨多罗三藐三菩提，亦无有定法，如来可说。何以故？如来所说法，皆不可取、不可说、非法、非非法。所以者何？一切圣贤，皆以无为法而有差别。” 金刚经 第八品 依法出生分 “须菩提！于意云何？若人满三千大千世界七宝以用布施，是人所得福德，宁为多不？”须菩提言：“甚多，世尊！何以故？是福德即非福德性，是故如来说福德多。”“若复有人，于此经中受持，乃至四句偈/jié/等，为他人说，其福胜彼。何以故？须菩提！一切诸佛，及诸佛阿耨多罗三藐三菩提法，皆从此经出。须菩提！所谓佛法者，即非佛法。” [^_^]： 感觉看前面面八段就可以了，后面都是反复说。 ====================== 金刚经 第九品 一相无相分 “须菩提！于意云何？须陀洹/huán/能作是念：‘我得须陀洹果’不？”须菩提言：“不也，世尊！何以故？须陀洹名为入流，而无所入，不入色声香味触法，是名须陀洹。”“须菩提！于意云何？斯陀含能作是念：‘我得斯陀含果’不？”须菩提言：不也，世尊！何以故？斯陀含名一往来，而实无往来，是名斯陀含。”“须菩提！于意云何？阿那含能作是念：‘我得阿那含果’不？”须菩提言：“不也，世尊！何以故？阿那含名为不来，而实无不来，是名阿那含。”“须菩提！于意云何？阿罗汉能作是念，‘我得阿罗汉道’不？”须菩提言：“不也，世尊！何以故？实无有法名阿罗汉。世尊！若阿罗汉作是念：‘我得阿罗汉道’，即著我人众生寿者。世尊！佛说我得无诤三昧，人中最为第一，是第一离欲阿罗汉。我不作是念：‘我是离欲阿罗汉’。世尊！我若作是念：‘我得阿罗汉道’，世尊则不说须菩提是乐阿兰那行者！以须菩提实无所行，而名须菩提是乐阿兰那行”。 金刚经 第十品 庄严净土分 佛告须菩提：“于意云何？如来昔在然灯佛所，于法有所得不？”“不也，世尊！如来在然灯佛所，于法实无所得。”“须菩提！于意云何？菩萨庄严佛土不？”“不也，世尊！何以故？庄严佛土者，即非庄严，是名庄严。”“是故须菩提！诸菩萨摩诃萨应如是生清净心，不应住色生心，不应住声香味触法生心，应无所住而生其心。须菩提！譬如有人，身如须弥山王，于意云何？是身为大不？”须菩提言：“甚大，世尊！何以故？佛说非身，是名大身。” 金刚经 第十一品 无为福胜分 “须菩提！如恒河中所有沙数，如是沙等恒河，于意云何？是诸恒河沙宁为多不？”须菩提言：“甚多，世尊！但诸恒河尚多无数，何况其沙。”“须菩提！我今实言告汝：若有善男子、善女人，以七宝满尔所恒河沙数三千大千世界，以用布施，得福多不？”须菩提言：“甚多，世尊！”佛告须菩提：“若善男子、善女人，于此经中，乃至受持四句偈等，为他人说，而此福德胜前福德。” 金刚经 第十二品 尊重正教分 “复次，须菩提！随说是经，乃至四句偈等，当知此处，一切世间、天人、阿修罗，皆应供养，如佛塔庙，何况有人尽能受持读诵。须菩提！当知是人成就最上第一希有之法，若是经典所在之处，则为有佛，若尊重弟子。” 金刚经 第十三品 如法受持分 尔时，须菩提白佛言：“世尊！当何名此经，我等云何奉持？”佛告须菩提：“是经名为《金刚般若波罗蜜》，以是名字，汝当奉持。所以者何？须菩提！佛说般若波罗蜜，即非般若波罗蜜。须菩提！于意云何？如来有所说法不？”须菩提白佛言：“世尊！如来无所说。”“须菩提！于意云何？三千大千世界所有微尘是为多不？”须菩提言：“甚多，世尊！”“须菩提！诸微尘，如来说非微尘，是名微尘。如来说世界，非世界，是名世界。须菩提！于意云何？可以三十二相见如来不？”“不也，世尊！何以故？如来说：三十二相，即是非相，是名三十二相。”“须菩提！若有善男子、善女人，以恒河沙等身布施；若复有人，于此经中，乃至受持四句偈等，为他人说，其福甚多。” 金刚经 第十四品 离相寂灭分 尔时，须菩提闻说是经，深解义趣，涕泪悲泣，而白佛言：“希有世尊！佛说如是甚深经典，我从昔来所得慧眼，未曾得闻如是之经。世尊！若复有人得闻是经，信心清净，则生实相，当知是人，成就第一希有功德。世尊！是实相者，即是非相，是故如来说名实相。世尊！我今得闻如是经典，信解受持不足为难，若当来世，后五百岁，其有众生，得闻是经，信解受持，是人则为第一希有。何以故？此人无我相、人相、众生相、寿者相。所以者何？我相即是非相,人相、众生相、寿者相，即是非相。何以故？离一切诸相，则名诸佛。”佛告须菩提：“如是！如是！若复有人得闻是经，不惊、不怖、不畏，当知是人甚为希有。何以故？须菩提！如来说第一波罗蜜，非第一波罗蜜，是名第一波罗蜜。须菩提！忍辱波罗蜜，如来说非忍辱波罗蜜，是名忍辱波罗蜜。何以故？须菩提！如我昔为歌利王割截身体，我于尔时，无我相、无人相、无众生相、无寿者相。何以故？我于往昔节节支解时，若有我相、人相、众生相、寿者相，应生嗔恨。须菩提！又念过去于五百世作忍辱仙人，于尔所世，无我相、无人相、无众生相、无寿者相。是故须菩提！菩萨应离一切相，发阿耨多罗三藐三菩提心，不应住色生心，不应住声香味触法生心，应生无所住心。若心有住，即为非住。是故佛说：‘菩萨应不住色布施。’须菩提！菩萨为利益一切众生，应如是布施。如来说：一切诸相，即是非相。又说：一切众生，即非众生。须菩提！如来是真语者、实语者、如语者、不诳语者、不异语者。须菩提！如来所得法，此法无实无虚。须菩提，若菩萨心住于法而行布施，如人入暗，即无所见。若菩萨心不住法而行布施，如人有目，日光明照，见种种色。须菩提！当来之世，若有善男子、善女人，能于此经受持读诵，则为如来以佛智慧，悉知是人，悉见是人，皆得成就无量无边功德。” 金刚经 第十五品 持经功德分 “须菩提！若有善男子、善女人，初日分以恒河沙等身布施，中日分复以恒河沙等身布施，后日分亦以恒河沙等身布施，如是无量百千万亿劫以身布施；若复有人，闻此经典，信心不逆，其福胜彼，何况书写、受持、读诵、为人解说。须菩提！以要言之，是经有不可思议、不可称量、无边功德。如来为发大乘者说，为发最上乘者说。若有人能受持读诵，广为人说，如来悉知是人，悉见是人，皆得成就不可量、不可称、无有边、不可思议功德。如是人等，即为荷担如来阿耨多罗三藐三菩提。何以故？须菩提！若乐小法者，著我见、人见、众生见、寿者见，则于此经，不能听受读诵、为人解说。须菩提！在在处处，若有此经，一切世间、天、人、阿修罗，所应供养；当知此处则为是塔，皆应恭敬，作礼围绕，以诸华香而散其处。” 金刚经 第十六品 能净业障分 “复次，须菩提！若善男子、善女人，受持读诵此经，若为人轻贱，是人先世罪业，应堕恶道，以今世人轻贱故，先世罪业则为消灭，当得阿耨多罗三藐三菩提。”“须菩提！我念过去无量阿僧祗劫，于然灯佛前，得值八百四千万亿那由他诸佛，悉皆供养承事，无空过者，若复有人， 于后末世，能受持读诵此经，所得功德，于我所供养诸佛功德，百分不及一，千万亿分、乃至算数譬喻所不能及。须菩提！若善男子、善女人，于后末世，有受持读诵此经，所得功德，我若具说者，或有人闻，心即狂乱，狐疑不信。须菩提！当知是经义不可思议，果报亦不可思议。” 金刚经 第十七品 究竟无我分 尔时，须菩提白佛言：“世尊！善男子、善女人，发阿耨多罗三藐三菩提心，云何应住？云何降伏其心？”佛告须菩提：“善男子、善女人，发阿耨多罗三藐三菩提者，当生如是心，我应灭度一切众生。灭度一切众生已，而无有一众生实灭度者。何以故？须菩提！若菩萨有我相、人相、众生相、寿者相，即非菩萨。所以者何？须菩提！实无有法发阿耨多罗三藐三菩提者。”“须菩提！于意云何？如来于然灯佛所，有法得阿耨多罗三藐三菩提不？”“不也，世尊！如我解佛所说义，佛于然灯佛所，无有法得阿耨多罗三藐三菩提。”佛言：“如是！如是！须菩提！实无有法如来得阿耨多罗三藐三菩提。须菩提！若有法得阿耨多罗三藐三菩提，然灯佛则不与我授记：汝于来世，当得作佛，号释迦牟尼。以实无有法得阿耨多罗三藐三菩提，是故然灯佛与我授记，作是言：‘汝于来世，当得作佛，号释迦牟尼。’何以故？如来者，即诸法如义。若有人言：‘如来得阿耨多罗三藐三菩提’。须菩提！实无有法，佛得阿耨多罗三藐三菩提。须菩提！如来所得阿耨多罗三藐三菩提，于是中无实无虚。是故如来说：一切法皆是佛法。须菩提！所言一切法者，即非一切法，是故名一切法。须菩提！譬如人身长大。”须菩提言：“世尊！如来说：人身长大，即为非大身，是名大身。”“须菩提！菩萨亦如是。若作是言：‘我当灭度无量众生’，即不名菩萨。何以故？须菩提！无有法名为菩萨。是故佛说：一切法无我、无人、无众生、无寿者。须菩提！若菩萨作是言，‘我当庄严佛土’，是不名菩萨。何以故？如来说：庄严佛土者，即非庄严，是名庄严。须菩提！若菩萨通达无我法者，如来说名真是菩萨。 金刚经 第十八品 一体同观分 “须菩提！于意云何？如来有肉眼不？”“如是，世尊！如来有肉眼。”“须菩提！于意云何？如来有天眼不？”“如是，世尊！如来有天眼。”“须菩提！于意云何？如来有慧眼不？”“如是，世尊！如来有慧眼。”“须菩提！于意云何？如来有法眼不？”“如是，世尊！如来有法眼。”“须菩提！于意云何？如来有佛眼不？”“如是，世尊！如来有佛眼。”“须菩提！于意云何？恒河中所有沙，佛说是沙不？”“如是，世尊！如来说是沙。”“须菩提！于意云何？如一恒河中所有沙，有如是等恒河，是诸恒河所有沙数，佛世界如是，宁为多不？”“甚多，世尊！”佛告须菩提：“尔所国土中，所有众生，若干种心，如来悉知。何以故？如来说：诸心皆为非心，是名为心。所以者何？须菩提！过去心不可得，现在心不可得，未来心不可得。” 金刚经 第十九品 法界通分分 “须菩提！于意云何？若有人满三千大千世界七宝以用布施，是人以是因缘，得福多不？”“如是，世尊！此人以是因缘，得福甚多。”“须菩提！若福德有实，如来不说得福德多；以福德无故，如来说得福德多。” 金刚经 第二十品 离色离相分 “须菩提！于意云何？佛可以具足色身见不？”“不也，世尊！如来不应以具足色身见。何以故？如来说：具足色身，即非具足色身，是名具足色身。”“须菩提！于意云何？如来可以具足诸相见不？”“不也，世尊！如来不应以具足诸相见。何以故？如来说：诸相具足，即非具足，是名诸相具足。” 金刚经 第二十一品 非说所说分 “须菩提！汝勿谓如来作是念：‘我当有所说法。’莫作是念，何以故？若人言：如来有所说法，即为谤佛，不能解我所说故。须菩提！说法者，无法可说，是名说法。”尔时，慧命须菩提白佛言：“世尊！颇有众生，于未来世，闻说是法，生信心不？”佛言：“须菩提！彼非众生，非不众生。何以故？须菩提！众生众生者，如来说非众生，是名众生。” 金刚经 第二十二品 无法可得分 须菩提白佛言：“世尊！佛得阿耨多罗三藐三菩提，为无所得耶？”佛言：“如是，如是。须菩提！我于阿耨多罗三藐三菩提乃至无有少法可得，是名阿耨多罗三藐三菩提。” 金刚经 第二十三品 净心行善分 复次，须菩提！是法平等，无有高下，是名阿耨多罗三藐三菩提；以无我、无人、无众生、无寿者，修一切善法，即得阿耨多罗三藐三菩提。须菩提！所言善法者，如来说即非善法，是名善法。 金刚经 第二十四品 福智无比分 “须菩提！若三千大千世界中所有诸须弥山王，如是等七宝聚，有人持用布施；若人以此《般若波罗蜜经》，乃至四句偈等，受持、为他人说，于前福德百分不及一，百千万亿分，乃至算数譬喻所不能及。” 金刚经 第二十五品 化无所化分 “须菩提！于意云何？汝等勿谓如来作是念：‘我当度众生。’须菩提！莫作是念。何以故？实无有众生如来度者。若有众生如来度者，如来则有我、人、众生、寿者。须菩提！如来说：‘有我者，则非有我，而凡夫之人以为有我。’须菩提！凡夫者，如来说即非凡夫。” 金刚经 第二十六品 法身非相分 “须菩提！于意云何？可以三十二相观如来不？”须菩提言：“如是！如是！以三十二相观如来。”佛言：“须菩提！若以三十二相观如来者，转轮圣王即是如来。”须菩提白佛言：“世尊！如我解佛所说义，不应以三十二相观如来。”尔时，世尊而说偈言：“若以色见我，以音声求我，是人行邪道，不能见如来” 金刚经 第二十七品 无断无灭分 “须菩提！汝若作是念：‘如来不以具足相故，得阿耨多罗三藐三菩提。’须菩提！莫作是念，‘如来不以具足相故，得阿耨多罗三藐三菩提。’须菩提！汝若作是念，发阿耨多罗三藐三菩提心者，说诸法断灭。莫作是念！何以故？发阿耨多罗三藐三菩提心者，于法不说断灭相。” 金刚经 第二十八品 不受不贪分 “须菩提！若菩萨以满恒河沙等世界七宝布施；若复有人知一切法无我，得成于忍，此菩萨胜前菩萨所得功德。须菩提！以诸菩萨不受福德故。”须菩提白佛言：“世尊！云何菩萨不受福德？”“须菩提！菩萨所作福德，不应贪著，是故说不受福德。” 金刚经 第二十九品 威仪寂净分 “须菩提！若有人言：如来若来若去、若坐若卧，是人不解我所说义。何以故？如来者，无所从来，亦无所去，故名如来。” 金刚经 第三十品 一合理相分 “须菩提！若善男子、善女人，以三千大千世界碎为微尘，于意云何？是微尘众宁为多不？”“甚多，世尊！何以故？若是微尘众实有者，佛则不说是微尘众，所以者何？佛说：微尘众，即非微尘众，是名微尘众。世尊！如来所说三千大千世界，即非世界，是名世界。何以故？若世界实有，即是一合相。如来说：‘一合相，即非一合相，是名一合相。’须菩提！一合相者，即是不可说，但凡夫之人贪著其事。” 金刚经 第三十一品 知见不生分 “须菩提！若人言：佛说我见、人见、众生见、寿者见。须菩提！于意云何？是人解我所说义不？”“不也，世尊！是人不解如来所说义。何以故？世尊说：我见、人见、众生见、寿者见，即非我见、人见、众生见、寿者见，是名我见、人见、众生见、寿者见。”“须菩提！发阿耨多罗三藐三菩提心者，于一切法，应如是知，如是见，如是信解，不生法相。须菩提！所言法相者，如来说即非法相，是名法相。” 金刚经 第三十二品 应化非真分 “须菩提！若有人以满无量阿僧祗世界七宝持用布施，若有善男子、善女人发菩提心者，持于此经，乃至四句偈等，受持读诵，为人演说，其福胜彼。云何为人演说，不取于相，如如不动。何以故？”“一切有为法，如梦幻泡影，如露亦如电，应作如是观”佛说是经已，长老须菩提及诸比丘、比丘尼、优婆塞、优婆夷，一切世间、天、人、阿修罗，闻佛所说，皆大欢喜，信受奉行。","categories":[],"tags":[{"name":"哲学","slug":"哲学","permalink":"https://abluecup.github.io/tags/哲学/"}]}]}