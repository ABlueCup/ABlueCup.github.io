<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="javascript," />





  <link rel="alternate" href="/rss.html" title="积步堂" type="application/atom+xml" />






<meta name="description" content="本篇主要介绍的是变量的提升机制、面向对象、原型链等内容">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript基础知识二">
<meta property="og:url" content="https://abluecup.github.io/2019/04/02/Javascript基础知识二/index.html">
<meta property="og:site_name" content="积步堂">
<meta property="og:description" content="本篇主要介绍的是变量的提升机制、面向对象、原型链等内容">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://abluecup.github.io/2019/04/02/Javascript基础知识二/Untitled.png">
<meta property="og:image" content="https://abluecup.github.io/2019/04/02/Javascript基础知识二/1.bmp">
<meta property="og:image" content="https://abluecup.github.io/2019/04/02/Javascript基础知识二/2.bmp">
<meta property="og:image" content="https://abluecup.github.io/2019/04/02/Javascript基础知识二/3.bmp">
<meta property="og:updated_time" content="2019-07-01T09:34:30.186Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript基础知识二">
<meta name="twitter:description" content="本篇主要介绍的是变量的提升机制、面向对象、原型链等内容">
<meta name="twitter:image" content="https://abluecup.github.io/2019/04/02/Javascript基础知识二/Untitled.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://abluecup.github.io/2019/04/02/Javascript基础知识二/"/>





  <title>Javascript基础知识二 | 积步堂</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/abluecup" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">积步堂</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">不积跬步，无以致千里；不积小流，无以成江海。</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-日程">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-公益">
          <a href="https://www.qq.com/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益
          </a>
        </li>
      
        
        <li class="menu-item menu-item-友情链接">
          <a href="https://www.luciustan.online/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-link"></i> <br />
            
            友情链接
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://abluecup.github.io/2019/04/02/Javascript基础知识二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="堂主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="积步堂">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Javascript基础知识二</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-02T11:24:01+08:00">
                2019-04-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/02/Javascript基础知识二/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2019/04/02/Javascript基础知识二/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本篇主要介绍的是变量的提升机制、面向对象、原型链等内容<br><a id="more"></a></p>
<h2 id="变量提升机制"><a href="#变量提升机制" class="headerlink" title="变量提升机制"></a>变量提升机制</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">一般都把js放到body的末尾</span></span><br><span class="line"><span class="comment">1.为啥？</span></span><br><span class="line"><span class="comment">2.放在head中可不可以，如何放到head中也可以实现放到body末尾的效果</span></span><br><span class="line"><span class="comment">3.script标签中有两个属性，defer / async, 这两个属性是做什么的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>栈内存：作用域，</p>
<pre><code>1. 提供供JS代码自上而下执行的环境（代码都是在栈中执行）；
2. 由于基本类型值比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存储进去；
    =&gt; 当栈内存被销毁，存储的那些基本值也随之而销毁；
</code></pre><p>堆内存：引用值对应的空间<br>    存储引用类型值（对象：键值对；函数：代码字符串;）<br>    =&gt; 当前堆内存销毁，那么引用值彻底没了<br>    =&gt; 堆内存的释放： 当堆内存没有被任何的变量或者其他东西所占用，浏览器会在空闲的时候，自主进行内存回收，把所有不被占用的内存销毁掉。（webkit内核浏览器）<br>    xxx = null;通过空对象指针null可以让原始变量或者其他东西谁都不指向，原先被占用的堆内存就没有被东西占用了，浏览器会销毁它。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ary1 =[1,2,4];</span><br><span class="line">ary1= null; // 释放堆内存</span><br></pre></td></tr></table></figure></p>
<h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>当栈内存（作用域）形成，JS自上而下执行之前，浏览器首先会把所有带var / function关键字的进行提前的声明或者定义，这种预先处理机制称之为变量提升；<br>    声明： declare // var a ;function aa; (默认值undefined)<br>    定义： defined a=12; (定义就是赋值)<br>    =&gt; 带var的只声明，未定义；带function的声明和赋值都完成了；<br>变量提升只发生在当前作用域<br>在全局作用域下声明的变量是全局变量，在私有作用域下声明的变量是私有变量 （带 var , function 的才是声明）<br>浏览器很懒，做过的事情不会重复第二遍，即当代码执行遇到创建函数这部分代码的时候，直接跳过（在变量提升阶段，已经完成函数的赋值操作）</p>
<p>在ES3或者ES5语法规范中，只有全局作用域和函数执行的私有作用域（栈内存），其他大括号不会形成栈内存</p>
<h2 id="带var-和不带var-的区别"><a href="#带var-和不带var-的区别" class="headerlink" title="带var 和不带var 的区别"></a>带var 和不带var 的区别</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> <span class="built_in">window</span>; <span class="comment">// in 用来检测属性是否隶属于对象</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// window对象的一个属性</span></span><br></pre></td></tr></table></figure>
<p>在全局作用域下声明一个变量，也相当于给window全局对象设置了一个属性，变量的值就是属性的值；私有作用域下声明的私有变量和window没啥关系；<br>全局变量和win中的属性存在映射机制；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加var,本质是window下的属性，不存在变量提升机制； 加var，本质是变量，存在变量提升机制</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// Uncaught ReferenceError: a is not defined 按照变量的机制处理，且window下并没有window.a的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> <span class="keyword">in</span> <span class="built_in">window</span>);<span class="comment">//false undefined, 对象没有这个属性，打印undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line">a=<span class="number">12</span>;<span class="comment">// window.a=12的简写；</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//12， 不存在变量a,但是window对象下有a属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//12， </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = b =<span class="number">12</span>; <span class="comment">// 这样写b是不带var的；</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>, b=<span class="number">12</span>;<span class="comment">// 这样写，b是带var的；</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a,b);  <span class="comment">// undefined, undefined;</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">12</span>,b=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">/** 私有作用域下，带var不带var也有区别</span></span><br><span class="line"><span class="comment">              带var的在私有作用域变量提升阶段，都声明为私有变量，和外界没有任何关系；</span></span><br><span class="line"><span class="comment">              不带var的不是私有变量，会向上级查找，看是否为上级的变量，不是，继续向上查找，一直找到window为止；</span></span><br><span class="line"><span class="comment">              我们把这种查找机制叫做作用域链；也就是我们在私有作用域中操作的这个非私有变量，是一直操作的别人的；</span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">              </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">    <span class="built_in">console</span>.log(a,b); <span class="comment">// 形成一个私有作用域，变量提升， a=undefined, b =window.b =12;</span></span><br><span class="line">    <span class="keyword">var</span> a = b=<span class="number">13</span>;   <span class="comment">// window.b被修改为13</span></span><br><span class="line">    <span class="built_in">console</span>.log(a,b);  <span class="comment">//私有作用域 13 ,13</span></span><br><span class="line">&#125;  <span class="comment">// 跳过函数创建的代码，继续执行</span></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">//  12 ， 13// 被覆盖了</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    b=<span class="number">13</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 13</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//13</span></span><br></pre></td></tr></table></figure>
<p>1.变量提升（没有）<br>2.执行fn,没有变量提升；b在fn和window下都没有；在作用域查找的过程中，如果找到win也没有这个变量，相当于给win设置了一个属性b window.b=13;</p>
<h2 id="只对等号左边进行变量提升"><a href="#只对等号左边进行变量提升" class="headerlink" title="只对等号左边进行变量提升"></a>只对等号左边进行变量提升</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fn(); <span class="comment">// fn is not a function  fn此时是undefined,不是函数</span></span><br><span class="line">sum(); <span class="comment">// 2 普通函数在变量提升阶段已经声明且赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数之函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// 1 当代码执行到这一行的时候，会把函数赋值给fn</span></span><br><span class="line">sum(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>真实项目中，常常采用函数表达式这种方式</strong></p>
<h2 id="条件判断下的变量提升"><a href="#条件判断下的变量提升" class="headerlink" title="条件判断下的变量提升"></a>条件判断下的变量提升</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">//在当前作用域中，不管条件是否成立都要进行变量的提升 </span></span><br><span class="line">    <span class="comment">// 带var的还是只声明</span></span><br><span class="line">    <span class="comment">// 带function的在老版本浏览器渲染机制下，声明+定义都处理，但是为了迎合ES6中的块级作用域，新版本浏览器对于函数（在条件判断中的函数），不管条件是否成立，都只是先声明，没有定义，类似于var</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'a'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> a =<span class="number">100</span>; </span><br><span class="line">   &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">    g = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ~ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g() &amp;&amp; [] == ![]) &#123; <span class="comment">// Uncaught typeError: g is not a function</span></span><br><span class="line"><span class="comment">// 新版本浏览器中只声明，未赋值，g=undefined, undefined不是函数，报错；老版本浏览器中g() = true;</span></span><br><span class="line">            f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="built_in">console</span>.log(f());</span><br><span class="line">    <span class="built_in">console</span>.log(g());</span><br></pre></td></tr></table></figure>
<h2 id="同名问题处理"><a href="#同名问题处理" class="headerlink" title="同名问题处理"></a>同名问题处理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   1.带var和function关键字声明相同的名字，这种也算是重名了（其实是一个FN，只是存储的值不同）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 2. 关于重名的处理：如果名字重复了，不会重新的声明，但是是会重新的定义：（重新赋值）【不管是变量提升还是代码执行阶段皆是如此】</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *变量提升： fn = ...(1)</span></span><br><span class="line"><span class="comment">                      = ...(2)</span></span><br><span class="line"><span class="comment">                      =...(3)</span></span><br><span class="line"><span class="comment">                      =...(4)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       fn(); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       fn(); <span class="comment">// 4</span></span><br><span class="line">       <span class="keyword">var</span> fn = <span class="number">100</span>; <span class="comment">// 带var的在变量提升阶段只是把声明处理了，没有执行赋值操作，所以在代码执行的时候需要完成赋值；</span></span><br><span class="line">       fn(); <span class="comment">// Uncaught TypeError: fn is not a function;</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       fn();</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       fn();</span><br></pre></td></tr></table></figure>
<h2 id="let创建的变量不存在变量提升"><a href="#let创建的变量不存在变量提升" class="headerlink" title="let创建的变量不存在变量提升"></a>let创建的变量不存在变量提升</h2><ol>
<li>在ES6中基于let或const创建变量或者函数，不存在变量提升机制, 且切断了全局变量和window属性的映射机制；</li>
<li>在同一个作用域中，基于let不能声明相同的变量；</li>
<li>浏览器在作用域形成之后，执行代码之前，会有一个变量查重机制（语法检测）,发现有重复声明的变量,报错 Uncaught SyntaxError<br>虽然没有把变量提前声明定义，但是浏览器已经记住了，当前作用域下有哪些变量;不管用什么方式，在当前作用域下声明了变量，再次使用let创建都会报错。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b =<span class="number">12</span>; <span class="comment">// window.b=12</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line">a=<span class="number">12</span>; <span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="ES6-JS中暂时性死区问题"><a href="#ES6-JS中暂时性死区问题" class="headerlink" title="ES6 JS中暂时性死区问题"></a>ES6 JS中暂时性死区问题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">13</span>; <span class="comment">// 基于let创建变量，会把大部分&#123;&#125;当成一个私有的块级作用域（类似于函数的私有作用域），在这里也是重新检测语法规范，看一下是否是基于新语法创建的变量，如果是按照新语法来解析</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br><span class="line"><span class="comment">// 在原有浏览器的渲染机制下，基于typeof等逻辑运算符检测一个违背声明过得变量，不会报错，返回undefined   </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c); <span class="comment">// Uncaught ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> c; <span class="comment">//如果当前变量是基于ES6语法处理，在没有声明这个变量的时候，使用TYPEOF检测，会直接报错，不会是undefined,解决了原有的暂时性死区问题</span></span><br></pre></td></tr></table></figure>
<h2 id="闭包作用域-scope"><a href="#闭包作用域-scope" class="headerlink" title="闭包作用域(scope)"></a>闭包作用域(scope)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>,</span><br><span class="line">    b = <span class="number">13</span>,</span><br><span class="line">    c = <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 形成作用域后，变量提升前，需要做形参赋值 a =12; </span></span><br><span class="line">    <span class="comment">// 在私有作用域中，只有以下两种情况是私有变量 A: 声明过的变量 ；B:形参也是私有变量； </span></span><br><span class="line">    <span class="comment">// 剩下的都不是自己私有的变量，都需要基于作用域链的机制向上查找</span></span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c); <span class="comment">// 12 undefined 14</span></span><br><span class="line">    <span class="keyword">var</span> b = c = a = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// var b=20; c=20;a=20;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c); <span class="comment">// 20,20,20</span></span><br><span class="line">&#125;</span><br><span class="line">fn(a); <span class="comment">// 执行fn(小括号中是实参：值) -&gt; 执行fn把全局变量a的值12当作实参传递给函数的形参 =&gt; fn(12)</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">//12,13,20</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [12,23] -&gt; [100,23]</span></span><br><span class="line">     <span class="keyword">var</span> ary = [<span class="number">12</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">ary</span>) </span>&#123; <span class="comment">// 形参赋值赋的是引用地址</span></span><br><span class="line">         <span class="comment">// ary = [12,23]</span></span><br><span class="line">         <span class="built_in">console</span>.log(ary); <span class="comment">// [12,23]</span></span><br><span class="line">         ary[<span class="number">0</span>] = <span class="number">100</span>; <span class="comment">//[100,23] 修改了应用地址中的数据</span></span><br><span class="line"></span><br><span class="line">         ary = [<span class="number">100</span>]; <span class="comment">// 修改了引用地址</span></span><br><span class="line">         ary[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">console</span>.log(ary); <span class="comment">// [0]</span></span><br><span class="line">     &#125;</span><br><span class="line">     fn(ary);</span><br><span class="line">     <span class="built_in">console</span>.log(ary); <span class="comment">// [100,23]</span></span><br></pre></td></tr></table></figure>
<h2 id="查找上级作用域"><a href="#查找上级作用域" class="headerlink" title="查找上级作用域"></a>查找上级作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前函数执行，形成呢个一个私有作用域A，A的上级作用域是谁，和他在哪执行的没有关系，和他在哪创建的有关系，在哪创建的，他的上级作用域就是谁。</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arguments.callee:函数本身</span></span><br><span class="line">    <span class="comment">// arguments.callee.caller: 当前函数在哪执行的caller就是谁（记录的是他的宿主环境）;在全局下执行是null</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">120</span>;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">sum(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前函数执行，形成呢个一个私有作用域A，A的上级作用域是谁，和他在哪执行的没有关系，和他在哪创建的有关系，在哪创建的，他的上级作用域就是谁。</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="built_in">console</span>.log(n);</span><br><span class="line">    &#125;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = fn();</span><br><span class="line">x();</span><br><span class="line">x();</span><br><span class="line"><span class="built_in">console</span>.log(n);</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/02/Javascript基础知识二/Untitled.png" alt="图解"></p>
<h2 id="堆栈内存释放"><a href="#堆栈内存释放" class="headerlink" title="堆栈内存释放"></a>堆栈内存释放</h2><p>JS中的内存分为堆内存和栈内存<br>堆内存：存储引用类型数据（对象：键值对  函数：代码字符串）<br>栈内存：提供JS代码执行的环境和存储基本类型值</p>
<p>【堆内存释放】<br>    让所有引用堆内存地址的变量赋值为null即可（没有变量占用这个堆内存了）浏览器会在空闲的时候把它释放掉</p>
<p>【栈内存释放】<br>    一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉，但是也有特殊不销毁的存在：</p>
<pre><code>1. 函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放，一旦释放，外面的变量找不到原有的内容了
2. 全局栈内存只有在页面关闭的时候才会被释放掉

如果当前内存没有被释放，那么之前在栈内存中能够存储的基本值也不会被释放，能够一直保存下来。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//var i=2;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n + (++i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn(<span class="number">2</span>); <span class="comment">// 先把fn执行，实参2，把fn执行的返回结果（return 后面的值）赋值给f</span></span><br><span class="line">f(<span class="number">3</span>); <span class="comment">// 返回的结果执行</span></span><br><span class="line">fn(<span class="number">5</span>)(<span class="number">6</span>); <span class="comment">// 和上面两步类似，都是先执行fn,把fn的返回结果再执行</span></span><br><span class="line">fn(<span class="number">7</span>)(<span class="number">8</span>);</span><br><span class="line">f(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6,12,16,8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// i++  :自身+1  </span></span><br><span class="line"><span class="comment">// ++i  :自身+1</span></span><br><span class="line"><span class="comment">// 区别是在和别人运算的时候，i++,先拿原有的值进行运算，运算结束后，本身累加1； ++i 先自身累加1，再拿累加后的结果进行运算</span></span><br></pre></td></tr></table></figure>
<p>闭包的作用： 保护私有变量不受外界干扰；形成一个不受外界干扰的栈内存，保存内部的私有变量；</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>【概念】： 函数执行，形成一个私有作用域，保护里面的私有变量不受外界的干扰，这种保护机制称为“闭包”；</p>
<p>=&gt; 市面上开发者认为的闭包：形成一个不销毁的私有栈内存（作用域）才是闭包</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =&gt; 闭包：柯里化函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f=fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt; 闭包：惰性函数</span></span><br><span class="line"><span class="keyword">var</span> utils = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 闭包项目实战应用</span></span><br><span class="line"> <span class="comment">// 真实项目中为了保证JS的性能（对栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）</span></span><br><span class="line"> <span class="comment">// 1.闭包具有保护作用：保护私有变量不受外界干扰</span></span><br><span class="line"> <span class="comment">// 在真实项目中，尤其是团队协作开发中，应该尽可能的减少全局变量的使用，</span></span><br><span class="line"> <span class="comment">//以防止相互之间的冲突（“全局变量污染”），此时我们完全可以把这一部分内容封装到一个闭包中，</span></span><br><span class="line"> <span class="comment">//让全局变量转化为私有变量</span></span><br><span class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> n = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line"> &#125;)()</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不仅如此，我们封装类库的时候，也会把自己的程序都存放在闭包中保护起来，</span></span><br><span class="line"> <span class="comment">//防止和用户的程序冲突，但是我们又需要暴露一些方法给客户使用，这样我们如何处理呢 ？</span></span><br><span class="line"> <span class="comment">// JQ这种方式，把需要暴露的方法抛到全局</span></span><br><span class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery; <span class="comment">// 把需要供外面使用的方法，通过给WIN设置属性的方式暴露出去；</span></span><br><span class="line"> &#125;)()</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// zepto这种方式，基于return把需要供外面使用的方法暴露出去</span></span><br><span class="line"> <span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">         xxx:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2.闭包具有保存作用：形成不销毁的栈内存，把一些值保存拿下来，方便后面的调取使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oBox = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line"> <span class="keyword">var</span> TabList = oBox.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"> <span class="keyword">var</span> divList = oBox.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">changeTab</span>(<span class="params">curIndex</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; TabList.length; i++) &#123;</span><br><span class="line">         TabList[i].className = <span class="string">''</span>;</span><br><span class="line">         divList[i].className = <span class="string">''</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     TabList[curIndex].className = <span class="string">'active'</span>;</span><br><span class="line">     divList[curIndex].className = <span class="string">'active'</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*   for (var i = 0; i &lt; TabList.length; i++) &#123;</span></span><br><span class="line"><span class="comment">        (function(i) &#123;</span></span><br><span class="line"><span class="comment">            TabList[i].onclick = function() &#123;</span></span><br><span class="line"><span class="comment">                changeTab(i);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;)(i);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    changeTab(0);*/</span></span><br><span class="line"> <span class="comment">// 执行方法：形成一个私有的栈内存，遇到变量I，I 不是私有变量，向上一级作用域查找（上级作用域window）</span></span><br><span class="line"> changeTab(<span class="number">0</span>);</span><br><span class="line"> <span class="comment">// 所有的绑定事件都是异步编程，（同步变成：一件事一件事做，当前这件事没完成，下一个任务不能处理； 异步编程：当前这件事件没有彻底完成，不再等待，继续执行下面的任务），绑定事件后，不需要等待执行，继续执行下一个循环任务，所以当我们点击执行方法的时候，循环早已经结束（全局的I是最后的循环结果）</span></span><br><span class="line"> <span class="comment">// 解决方案1：自定义属性</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; TabList.length; i++) &#123;</span><br><span class="line">     TabList[i].myIndex = i;</span><br><span class="line">     TabList[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         changeTab(<span class="keyword">this</span>.myIndex);</span><br><span class="line">         <span class="comment">//=&gt; this:给当前元素的某个事件绑定方法，当事件触发，方法执行的时候，方法中的this是当前操作的元素对象</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 解决方案2 闭包</span></span><br><span class="line"> <span class="comment">/*     for (var i = 0; i &lt; TabList.length; i++) &#123;</span></span><br><span class="line"><span class="comment">          TabList[i].onclick = (function(n) &#123;</span></span><br><span class="line"><span class="comment">              //让自执行函数执行，把执行的函数返回值赋值给onclick, </span></span><br><span class="line"><span class="comment">              //此处Onclick绑定的是返回的小函数,点击的时候执行的是小函数，</span></span><br><span class="line"><span class="comment">              //自执行函数在给事件赋值的时候就已经执行了</span></span><br><span class="line"><span class="comment">              return function() &#123;</span></span><br><span class="line"><span class="comment">                  changeTab(n); // 上级作用域：自执行函数执行的时候形成的作用域</span></span><br><span class="line"><span class="comment">              &#125;</span></span><br><span class="line"><span class="comment">          &#125;)(i); // i:把本次全局变量i传递给内部函数的形参n</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line"> <span class="comment">// 总结：循环三次，形成三个不销毁的私有作用域（），而每一个不销毁的栈内存中都存储了一个私有变量，形参n的值；点击的时候，执行返回的小函数，遇到变量n,就是上级作用域中的n</span></span><br><span class="line"> <span class="comment">// 基于ES6来执行</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; TabList.length; i++) &#123;</span><br><span class="line">     TabList[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         changeTab(i);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 基于ES6中的let来创建变量是存在块级作用域的（类似于私有作用域）；</span></span><br><span class="line"> <span class="comment">// 作用域： 栈内存</span></span><br><span class="line"> <span class="comment">// 1全局作用域</span></span><br><span class="line"> <span class="comment">// 2 私有作用域 （函数执行）</span></span><br><span class="line"> <span class="comment">// 3 块级作用域（一般用&#123;&#125;包起来的都是块级作用域，前提是ES6语法）</span></span><br><span class="line"> <span class="comment">/*     &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          let a = 1;</span></span><br><span class="line"><span class="comment">          console.log(a); // 1</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      // cosole.log(a); // 报错</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      for (let i = 0; i &lt; 5; i++) &#123;</span></span><br><span class="line"><span class="comment">          // 循环也是块级作用域，初始值设置的变量是当前本次会计作用域中的变量（形成了五个块级作用域）</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      switch</span></span><br><span class="line"><span class="comment">      case // 块级作用域</span></span><br><span class="line"><span class="comment">      let obj = &#123;&#125;; // =&gt; 对象不是块级作用域*/</span></span><br></pre></td></tr></table></figure>
<h2 id="面向对象编程（OOP-Object-Oriented-Programming）"><a href="#面向对象编程（OOP-Object-Oriented-Programming）" class="headerlink" title="面向对象编程（OOP Object Oriented Programming）"></a>面向对象编程（OOP Object Oriented Programming）</h2><h3 id="单例设计模式-singleton-pattern"><a href="#单例设计模式-singleton-pattern" class="headerlink" title="单例设计模式 singleton pattern"></a>单例设计模式 singleton pattern</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 单例设计模式</span></span><br><span class="line"><span class="comment"> * 1. 表现形式</span></span><br><span class="line"><span class="comment"> *  var obj=&#123;xxx:xxx,...&#125;</span></span><br><span class="line"><span class="comment"> *  在单例设计模式中，obj不仅仅是对象名，它被称为“命名空间”（NameSpace）,</span></span><br><span class="line"><span class="comment"> * 把描述事物的属性存放到命名空间中，多个命名空间是独立分开的，互不冲突。</span></span><br><span class="line"><span class="comment"> * 2. 作用</span></span><br><span class="line"><span class="comment"> *  把描述同一件事务的属性和特征进行“分组、归类”，（存储在不同堆内存中）</span></span><br><span class="line"><span class="comment"> * 因此避免了全局变量之间的冲突和污染</span></span><br><span class="line"><span class="comment"> * 3.单例设计模式命名的由来：每一个命名空间都是JS中Object这个内置基类的实例，</span></span><br><span class="line"><span class="comment"> * 而实例之间是相互独立，互不干扰的，所以我们称之为单例（单独的实例）</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 高级单例模式</span></span><br><span class="line"><span class="comment"> * 1. 再给命名空间赋值的时候，不是直接赋值一个对象，而是先执行匿名函数，</span></span><br><span class="line"><span class="comment"> * 形成一个私有作用域（不销毁的栈内存），在这个私有作用域aa中创建一个堆内存，</span></span><br><span class="line"><span class="comment"> * 把堆内存的地址赋值给命名空间</span></span><br><span class="line"><span class="comment"> * 2. 这种模式的好处：我们完全可以在AA中创造很多内容（变量or函数），</span></span><br><span class="line"><span class="comment"> * 哪些需要供外面调取使用的，我们暴露到返回的对象中（模块化实现的一种思想）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> nameSpace = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">                             </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fn: fn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this</span></span><br><span class="line"><span class="comment"> * 1，给当前元素的某个事件绑定方法，当事件触发方法执行的时候，</span></span><br><span class="line"><span class="comment"> * 方法中的this是当前操作的元素</span></span><br><span class="line"><span class="comment"> * 2, 普通函数执行，函数中的this取决于执行的主体，谁执行的，</span></span><br><span class="line"><span class="comment"> * this就是谁（执行主体：方法执行看方法名前面是否有点,有的话，</span></span><br><span class="line"><span class="comment"> * 点前面是谁this就是谁，没有,this是window）</span></span><br><span class="line"><span class="comment"> * 3, 自执行函数执行，方法中的this是window</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    n: <span class="number">3</span>,</span><br><span class="line">    fn: (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        n *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">var</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">this</span>.n += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.n *= <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//console.log(m++(++n));</span></span><br><span class="line">            <span class="built_in">console</span>.log(m + (++n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(n) <span class="comment">// 自执行函数执行的时候，堆内存的键值对还没有存储完，它和obj还没有关系，此时obj=undefined,obj.n会报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = obj.fn;</span><br><span class="line">fn(<span class="number">3</span>); <span class="comment">// </span></span><br><span class="line">obj.fn(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(n, obj.n);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模块化开发：</span></span><br><span class="line"><span class="comment"> *  1, 团队协作开发的时候，会把产品按照功能板块进行划分，</span></span><br><span class="line"><span class="comment"> * 每一个功能板块有专人负责开发;</span></span><br><span class="line"><span class="comment"> *  2, 把各个板块之间公用的部分进行提取分装，</span></span><br><span class="line"><span class="comment"> * 后期再想实现这些功能，直接调取引用即可（模块封装）;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> utils = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        aa: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> skipRender = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">skipRender.init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> weatherRender = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        initi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn(); <span class="comment">//调取自己模块中的方法，直接调取即可；</span></span><br><span class="line">            skipRender.fn(); <span class="comment">//调取别人模块中的方法</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 工厂模式(factory pattern)：</span></span><br><span class="line"><span class="comment"> * 1, 把实现相同功能的代码进行封装，以此来实现“批量生产”（后期要实现这个功能，我们只需要执行函数即可）</span></span><br><span class="line"><span class="comment"> * 2, 低耦合高内聚：减少页面中的冗余代码，提高代码的重复使用率</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="oop面向对象"><a href="#oop面向对象" class="headerlink" title="oop面向对象"></a>oop面向对象</h3><p>JS是一门编程语言，具有编程思想<br>【面向对象】<br>js/java/php/c#/ruby/python/c++<br>【面向过程】<br>c<br>面向对象编程需要掌握：对象、类、实例的概念</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>万物及对象</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>对象的具体细分（按照功能特点进行分类，有大类，也有小类）</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>类中具体的一个事物（拿出类别中的具体一个实例进行研究，那么当前类别下的其他势力也具备这些特点和特征）;</p>
<p>整个JS就是基于面向对象设计和开发的语言，我们学习和实战的时候，也要按照面向对象的思想去体会和理解；</p>
<h3 id="JS中的内置类"><a href="#JS中的内置类" class="headerlink" title="JS中的内置类"></a>JS中的内置类</h3><p>Object: Number,String, Boolean,Null,Undefined,Array,Date,Rex,…,HTMLCollection,NodeList,EventTagert(node(Element,),…)</p>
<h3 id="JS中创建值的两种方式"><a href="#JS中创建值的两种方式" class="headerlink" title="JS中创建值的两种方式"></a>JS中创建值的两种方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基于构造函数创建自定义类(constructor)</span></span><br><span class="line"><span class="comment"> * 1. 在普通函数执行的基础上"new xxx()",这样就不是普通函数执行了，</span></span><br><span class="line"><span class="comment"> * 而是构造函数执行，当前的函数名称之为“类名”，</span></span><br><span class="line"><span class="comment"> * 接收的返回结果是当前类的一个实例</span></span><br><span class="line"><span class="comment"> * 2. 自己创建的类名，最好第一个单词首字母大写</span></span><br><span class="line"><span class="comment"> * 3. 这种构造函数设计模式执行，主要用于组件、类库、插件、</span></span><br><span class="line"><span class="comment"> * 框架等的封装，平时编写业务逻辑一般不这样处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">Fn(); <span class="comment">//普通函数执行</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn(); <span class="comment">//=&gt; Fn是类，f是类的一个实例</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Fn(); <span class="comment">// f2也是Fn的一个实例，f2和f是独立分开的，互不影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * JS中创建值有两种方式</span></span><br><span class="line"><span class="comment"> * 1 字面量表达式</span></span><br><span class="line"><span class="comment"> * 2 构造函数模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; <span class="comment">// 字面量方式</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">//构造函数模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管是哪一种方式，创造出来的都是Object类的实例，</span></span><br><span class="line"><span class="comment">//而实例之间是独立分开的，所以var xxx=&#123;&#125;这种模式就是JS中的单例模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型值基于两种不同的方式创建出来的值是不一样的</span></span><br><span class="line"><span class="comment">//基于字面量方式创建出来的是基本类型值，</span></span><br><span class="line"><span class="comment">//基于构造函数创建出来的是引用类型值</span></span><br><span class="line"><span class="comment">// num2是数字类Number的一个实例，num1也是数字类的实例，</span></span><br><span class="line"><span class="comment">//它只是JS表达数字的方式之一，都可以使用数字类提供的属性和方法</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">12</span>; <span class="comment">// 12 number</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">12</span>); <span class="comment">// Number&#123;12&#125; object</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数机制"><a href="#构造函数机制" class="headerlink" title="构造函数机制"></a>构造函数机制</h4><p><img src="/2019/04/02/Javascript基础知识二/1.bmp" alt="Alert image"></p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">this</span>.m = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'哈哈哈'</span>; <span class="comment">//这样执行，结束了代码执行，但是不会覆盖实例</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数执行</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数执行，浏览器会默认返回创建的实例</span></span><br><span class="line"><span class="comment"> * return的是一个基本值，返回的依然是类的实例，没有影响，如果返回的是引用值，</span></span><br><span class="line"><span class="comment"> * 则会把默认返回的实例覆盖，此时接收到的结果就不再是当前类的实例</span></span><br><span class="line"><span class="comment"> * 构造函数执行的时候，尽量减少return的使用，防止覆盖实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new Fn === new Fn(); 在构造函数执行的时候，如果Fn不需要传参，</span></span><br><span class="line"><span class="comment">//我们可以省略小括号,意思还是创建实例（和加小括号没有区别）</span></span><br><span class="line"><span class="comment">// instanceof: 检测某一个实例是否隶属于某个类 f instanceof Fn  实例 instanceof 类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in ：检测当前对象是否存在某个属性 'm' in f, </span></span><br><span class="line"><span class="comment">//不管当前这个属性是对象的私有属性还是公有属性，只要有，结果就是true. </span></span><br><span class="line"><span class="comment">//'toString' in f 结果是true， toString是它的公有属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hasOwnProperty用来检测当前属性是否为对象的私有属性： 不仅要有这个属性，还必须要是私有属性才可以</span></span><br><span class="line">f.hasOwnProperty(<span class="string">'m'</span>); <span class="comment">// true</span></span><br><span class="line">f.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false 这个是公有属性</span></span><br></pre></td></tr></table></figure>
<p>思考：编写一个方法hasPubProperty，检测当前属性是否为对象的公有属性，和hasOwnProperty对应<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPubProperty</span>(<span class="params">obj, attr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (attr <span class="keyword">in</span> obj &amp;&amp; obj.hasOwnProperty(attr) === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="原型和原型链-（prototype-amp-proto）"><a href="#原型和原型链-（prototype-amp-proto）" class="headerlink" title="原型和原型链 （prototype &amp; proto）"></a>原型和原型链 （prototype &amp; <em>proto</em>）</h3><p><img src="/2019/04/02/Javascript基础知识二/2.bmp" alt="Alert image"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  [函数]</span></span><br><span class="line"><span class="comment"> *       普通函数、类（所有的类：包含内置类和自己创建的类）</span></span><br><span class="line"><span class="comment"> *   [对象]</span></span><br><span class="line"><span class="comment"> *       普通对象、数组、正则、Math、实例（是对象类型，除了基本类型的字面量创建的值） </span></span><br><span class="line"><span class="comment"> *          prototype的值，arguments</span></span><br><span class="line"><span class="comment"> *          函数也是对象类型……</span></span><br><span class="line"><span class="comment"> *      1, 所有的函数数据类型都天生自带一个属性叫prototype(原型), 这个属性的值是一个对象，浏览器会默认给它开辟一个堆内存;</span></span><br><span class="line"><span class="comment"> *      2, 浏览器给prototype开辟的堆内存当中，有一个天生自带的属性，叫constructor,这个属性存储的值是当前这个函数本身；</span></span><br><span class="line"><span class="comment"> *      3, 每一个对象都有一个_proto_的属性，这个属性指向当前实例所属类的prototype（如果不能确定是谁的实例，都是Object的实例）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.AA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'AA私有'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.BB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'BB私有'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Fn.prototype.AA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'AA公有'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn;</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Fn;</span><br><span class="line"><span class="built_in">console</span>.log(f1.n); <span class="comment">// undefined 没有这个属性</span></span><br><span class="line"><span class="comment">// f1._proto_.AA === f2._proto_.AA = Fn.prototype.AA // TRUE</span></span><br><span class="line">f1.name = <span class="string">'f1的私有属性'</span>;</span><br><span class="line">f1._proto_.name = <span class="string">'f1原型上的公有属性'</span>; <span class="comment">// 每个实例都可以用这个公有属性</span></span><br></pre></td></tr></table></figure></p>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x, y, a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arguments：函数内置的实参集合，不管是否设置实参，都存在；但是在非严格Js模式下，函数中的形参变量和arguments存在映射机制（映射：相互之间影响）</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">a = b(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 函数b并没有return,默认函数的返回值是undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3,10，undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  形参： x=10, y=undefined // y也是私有变量，赋值为undefined</span></span><br><span class="line"><span class="comment">     *  arg和形参之间的映射关系是以arg的索引为基础完成的，arg中有这个索引，浏览器会完成与对应的形参变量中的映射机制搭建，如果形参比arg中个数多，那么多出来的形参是无法和arg中对应的索引形成映射关系的。</span></span><br><span class="line"><span class="comment">     映射机制在一开始就会建立</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> arg = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    arg[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 100</span></span><br><span class="line">    arg[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(y); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">fn(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS严格模式，在当前作用域的第一行加上 "use strict"即可，这样在当前作用域中，就开启了Js的严格模式</span></span><br><span class="line"><span class="comment">// "use strict"; // 整个Js都开启了严格模式，只对当前这个JS文件中的代码生效，下一个JS文件需要开启严格模式，第一行还是需要再次编写use strict; 真实项目中我们一般都会把JS文件合并压缩成一个导入页面</span></span><br><span class="line"><span class="comment">/*function fn() &#123;</span></span><br><span class="line"><span class="comment">    "use strict"; // 只在当前作用中使用严格模式</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 严格模式下不支持arguments.callee/arguments.callee.caller</span></span><br><span class="line"><span class="comment">// 2. 严格模式下arguments和形参没有映射机制</span></span><br><span class="line"><span class="comment">// 3. 严格模式下不允许给一个对象设置重复属性名的</span></span><br><span class="line"><span class="comment">// 4. 严格模式下函数执行，如果没有明确指定执行的主体（函数前面没有点.,不再像非严格模式下指向window,而是让this指向undefined,代表没有执行主体）严格模式下有执行主体，this就是谁，没有执行主体，就是undefined.</span></span><br><span class="line">~ <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn(<span class="number">10</span>); <span class="comment">//10</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        n: <span class="number">10</span>,</span><br><span class="line">        n: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.n);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">~ <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    fn(<span class="number">10</span>); <span class="comment">//100</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑与&amp;&amp;,逻辑或||</span></span><br><span class="line"><span class="comment">//1.在条件判断当中 if(1===1 &amp;&amp; 2===2)</span></span><br><span class="line"><span class="comment">//2.在赋值操作中，有时也会用到； var a=1 || 2; 首先验证1是真假，如果为真，1赋值给a,反之，将2赋值给a;</span></span><br><span class="line"><span class="comment">//      var b=1 &amp;&amp; 2; 先验证1的真假，为真，结果是2,反之，将1赋值给b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//验证传递的参数值，如果没有传递实参，让其默认值为零；</span></span><br><span class="line">    x = x || <span class="number">0</span>; <span class="comment">// 这种赋值方式并不严谨，x传值为false时，依然赋值0;但是项目中却非常常用，因为简单。</span></span><br><span class="line">    y = y || <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* if(typeof callback==='function')&#123;</span></span><br><span class="line"><span class="comment">         callback();</span></span><br><span class="line"><span class="comment">     &#125;*/</span></span><br><span class="line">    callback &amp;&amp; callback(); <span class="comment">//上面if判断的简写版：默认callback要不然传函数，要不然就不传</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.逻辑与和逻辑或的混合模式 </span></span><br><span class="line"><span class="comment">// 优先级： 逻辑与的优先级高于逻辑或</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0 || 1 &amp;&amp; 2 || 2 &amp;&amp; 0 = 1 || 2 || 0 = 1</span></span><br><span class="line"><span class="comment">//4.逻辑或的实战应用：形参赋值默认值（初始化形参）</span></span><br><span class="line"><span class="comment">//在ES6新语法规范中可以直接给形参设置默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果x没有传递值，默认值是零，一旦传递值，不管传递的是啥，都是按照传递的值处理</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5 5 6 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b + a++; <span class="comment">// b + a之后a自身再累加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(fn()(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">ary</span>) </span>&#123; <span class="comment">//传递进来的堆内存地址相同，所以第一步修改的是同一个堆内存中的ary[0]</span></span><br><span class="line">    ary[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    ary = [<span class="number">0</span>]; <span class="comment">// 修改了堆内存地址，与外部的已经不是同一个堆内存</span></span><br><span class="line">    ary[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> ary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> res = fn(ary);</span><br><span class="line"><span class="built_in">console</span>.log(ary);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n + i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn(<span class="number">10</span>);</span><br><span class="line">f(<span class="number">20</span>);</span><br><span class="line">fn(<span class="number">20</span>)(<span class="number">40</span>);</span><br><span class="line">fn(<span class="number">30</span>)(<span class="number">50</span>);</span><br><span class="line">f(<span class="number">30</span>);</span><br><span class="line"><span class="comment">// 30,60,80,41</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n + (++i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn();</span><br><span class="line">f(<span class="number">20</span>);</span><br><span class="line">fn()(<span class="number">20</span>);</span><br><span class="line">fn()(<span class="number">30</span>);</span><br><span class="line">f(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 31,32,43,44</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  1 和 new Number&#123;1&#125;</span></span><br><span class="line"><span class="comment"> *  区别：</span></span><br><span class="line"><span class="comment"> *       前面是基本数据类型，后面是引用数据类型值</span></span><br><span class="line"><span class="comment"> *  相同点：</span></span><br><span class="line"><span class="comment"> *      都是Number类的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   函数类型：</span></span><br><span class="line"><span class="comment"> *       普通函数</span></span><br><span class="line"><span class="comment"> *       构造函数（类：内置类和自己创建的类）</span></span><br><span class="line"><span class="comment"> *   对象类型：</span></span><br><span class="line"><span class="comment"> *       普通对象</span></span><br><span class="line"><span class="comment"> *       Math\Json</span></span><br><span class="line"><span class="comment"> *       类的实例（数组、正则、日期等）</span></span><br><span class="line"><span class="comment"> *       prototype或者_proto_</span></span><br><span class="line"><span class="comment"> *       arguments或者元素集合等类数组</span></span><br><span class="line"><span class="comment"> *       函数也是一种对象</span></span><br><span class="line"><span class="comment"> *       -&gt; 万物皆对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  1. 每一个函数（类）都有一个prototype（原型）属性，属性值是一个对象，这个对象中存储了供实例调取和使用的公有属性和方法；</span></span><br><span class="line"><span class="comment"> *  2. 在浏览器默认给原型prototype开辟的堆内存中，有一个属性叫constructor,存储的是当前类的函数；</span></span><br><span class="line"><span class="comment"> *  3. 每一个对象（实例）都有一个_proto_（原型链）属性，这个属性指向当前实例所属类的原型（不确定所属的类，都指向Object.prototype）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">this</span>.getX = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.getX = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.getY = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> Fn();</span><br><span class="line"><span class="keyword">var</span> f2= <span class="keyword">new</span> Fn();</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/02/Javascript基础知识二/3.bmp" alt="Alert Image"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1 为啥不行？</span></span><br><span class="line"><span class="comment"> *   事件绑定是异步编程，当触发点击行为，绑定的方法执行的时候，外层循环已经结束；方法执行产生私有作用域，用到的变量i不是私有变量，按照作用域查找机制，找到的是全局变量i（此时全局的i已经成为循环最后一次的结果）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  2 如何解决</span></span><br><span class="line"><span class="comment"> *      自定义属性</span></span><br><span class="line"><span class="comment"> *      闭包</span></span><br><span class="line"><span class="comment"> *      ES6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line"><span class="keyword">var</span> btnList = box.getElementsByTagName(<span class="string">'button'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btnList.length; i++) &#123;</span><br><span class="line">    btnList[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每一轮循环都执行自执行函数，形成一个私有作用域（不销毁），里面设定一个私有变量i，让存储后期需要用到的索引</span></span><br><span class="line"><span class="comment">// 点击触发方法执行，用到变量i，向对应的上级作用域查找i的值，而上级作用域中存储的i就是我们需要的索引</span></span><br><span class="line"><span class="comment">// 基于闭包解决非常占用内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6和闭包的机制类似，ES6中使用let创建变量，会形成块级作用域，当前案例中，每一轮循环都会形成一个块级作用域，把后续需要用到的索引i存储到自己的作用域中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;btnList.length;i++)&#123;</span><br><span class="line">    btnList[i].onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你以为你以为的就是你以为的</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">'language'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fullName: <span class="string">'javascript'</span>,</span><br><span class="line">    prop: &#123;</span><br><span class="line">        getFullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fullName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.prop.getFullName()); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> test = obj.prop.getFullName;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// language</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在实际项目中，基于面向对象开发的时候（构造原型设计模式），我们根据需要，很多时候会重定向类的原型（让类的原型指向自己开辟的堆内存）</span></span><br><span class="line"><span class="comment"> * 【存在的问题】</span></span><br><span class="line"><span class="comment"> *   1,自己开辟的堆内存中没有constructor属性，导致类的原型构造函数缺失</span></span><br><span class="line"><span class="comment"> *      解决方案：自己手动在堆内存中增加constructor属性</span></span><br><span class="line"><span class="comment"> *   2,当原型重定向后，浏览器默认开辟的堆内存会被释放掉，如果原来已经存储了一些属性和方法，这些东西都会丢失</span></span><br><span class="line"><span class="comment"> *      所以内置类的原型不允许重定向到自己开辟的堆内存中，因为内置类的原型上自带了很多属性和方法，重定向后都没了，这样是不被允许的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 在原型上批量开发方法的时候，使用原型重定向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Fn,</span><br><span class="line">    aa: 12,</span><br><span class="line">    bb: 13,</span><br><span class="line">    cc: 14</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function fun() &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun.prototype = &#123;</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;,</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">30</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> my_fun = <span class="keyword">new</span> fun();</span><br><span class="line">my_fun.b(); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(my_fun.a);</span><br><span class="line">my_fun.c(); <span class="comment">//my_fun._proto_.c // 30</span></span><br><span class="line"><span class="built_in">console</span>.log(my_fun.a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有属性：自己堆内存中存储的属性相对自己来说是私有的</span></span><br><span class="line"><span class="comment">// 公有属性：自己基于_proto_属性找到的属性相对自己来说是公有的</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">12</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">45</span>];</span><br><span class="line"><span class="comment">// 为啥ary.sort可以执行：因为sort是array.prototype上内置的属性方法，而ary是它的一个实例，可以基于_proto_找到原型上的这个方法，然后调取使用</span></span><br><span class="line">ary.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基于内置类的原型扩展方法，供他的实例调取使用</span></span><br><span class="line"><span class="comment"> *   1. 我们增加的方法最好设置“my”前缀(前缀可以随便定义)，防止把内置方法重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.kpUnique = <span class="function"><span class="keyword">function</span> <span class="title">kpUnique</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 方法中的this一般都是当前的实例，也就是我们要操作的数组</span></span><br><span class="line">    <span class="comment">// ary._proto_.kpUnique() IE浏览器中屏蔽了我们对_proto_的操作</span></span><br><span class="line">    <span class="comment">// Array.prototype.myUnique() ;// 这种方法极少使用</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = <span class="keyword">this</span>[i];</span><br><span class="line">        obj.hasOwnProperty(item) ? (<span class="keyword">this</span>[i] = <span class="keyword">this</span>[<span class="keyword">this</span>.length - <span class="number">1</span>], <span class="keyword">this</span>.length--, i--) : obj[item] = item;</span><br><span class="line">    &#125;;</span><br><span class="line">    obj = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*var a = ary.kpUnique(); // this:ary, 我们操作this相当于操作ary，方法执行完成，就会修改原数组</span></span><br><span class="line"><span class="comment">// 此时方法执行的返回值是undefined; 原数组改变</span></span><br><span class="line"><span class="comment">console.log(a);</span></span><br><span class="line"><span class="comment">console.log(ary);</span></span><br><span class="line"><span class="comment">// 执行sort返回的是排序后的数组，执行reverse()返回的也是数组，执行pop返回的是返回的那一项</span></span><br><span class="line"><span class="comment">ary.sort(function (a, b) &#123;</span></span><br><span class="line"><span class="comment">    return a - b;</span></span><br><span class="line"><span class="comment">&#125;).reverse().pop(); // js中的链式写法：保证每一个方法执行返回的依然是当前类的实例，这样就可以继续调取方法使用了。*/</span></span><br><span class="line"><span class="keyword">var</span> max = ary.kpUnique().sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;).pop();</span><br><span class="line"><span class="built_in">console</span>.log(ary);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// document.parentNode 和 document.parentnode的区别</span><br><span class="line"></span><br><span class="line">// 怎么规避多人开发函数重名问题</span><br><span class="line">使用单例模式规避</span><br><span class="line">把当前模块的属性和方法放在一个命名空间中（笔试的时候不要写太详细，阐述题不会表达可以手写代码）</span><br><span class="line"></span><br><span class="line">// javascript如何实现面向对象中的继承</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 你理解的闭包是什么，优缺点？</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    
    
    <div>
        
            <div>

<div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>

</div>
        
    </div>

    

    

    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"><i class="fa fa-tag"></i> javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/02/Javascript基础知识一/" rel="next" title="Javascript基础知识一">
                <i class="fa fa-chevron-left"></i> Javascript基础知识一
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/18/Javascript基础知识三/" rel="prev" title="Javascript基础知识三">
                Javascript基础知识三 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div onclick="showGitment()" id="gitment-display-button">显示 Gitment 评论</div>
        <div id="gitment-container" style="display:none"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">堂主</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/rss.html" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/abluecup/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2946358527@qq.com" target="_blank" title="邮箱">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量提升机制"><span class="nav-number">1.</span> <span class="nav-text">变量提升机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念："><span class="nav-number">1.1.</span> <span class="nav-text">概念：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带var-和不带var-的区别"><span class="nav-number">2.</span> <span class="nav-text">带var 和不带var 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域链"><span class="nav-number">3.</span> <span class="nav-text">作用域链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只对等号左边进行变量提升"><span class="nav-number">4.</span> <span class="nav-text">只对等号左边进行变量提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件判断下的变量提升"><span class="nav-number">5.</span> <span class="nav-text">条件判断下的变量提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同名问题处理"><span class="nav-number">6.</span> <span class="nav-text">同名问题处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#let创建的变量不存在变量提升"><span class="nav-number">7.</span> <span class="nav-text">let创建的变量不存在变量提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-JS中暂时性死区问题"><span class="nav-number">8.</span> <span class="nav-text">ES6 JS中暂时性死区问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包作用域-scope"><span class="nav-number">9.</span> <span class="nav-text">闭包作用域(scope)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找上级作用域"><span class="nav-number">10.</span> <span class="nav-text">查找上级作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆栈内存释放"><span class="nav-number">11.</span> <span class="nav-text">堆栈内存释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">12.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程（OOP-Object-Oriented-Programming）"><span class="nav-number">13.</span> <span class="nav-text">面向对象编程（OOP Object Oriented Programming）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单例设计模式-singleton-pattern"><span class="nav-number">13.1.</span> <span class="nav-text">单例设计模式 singleton pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#oop面向对象"><span class="nav-number">13.2.</span> <span class="nav-text">oop面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象"><span class="nav-number">13.2.1.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类"><span class="nav-number">13.2.2.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例"><span class="nav-number">13.2.3.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS中的内置类"><span class="nav-number">13.3.</span> <span class="nav-text">JS中的内置类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS中创建值的两种方式"><span class="nav-number">13.4.</span> <span class="nav-text">JS中创建值的两种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数机制"><span class="nav-number">13.4.1.</span> <span class="nav-text">构造函数机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#细节"><span class="nav-number">13.4.2.</span> <span class="nav-text">细节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型和原型链-（prototype-amp-proto）"><span class="nav-number">13.5.</span> <span class="nav-text">原型和原型链 （prototype &amp; proto）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习题"><span class="nav-number">13.6.</span> <span class="nav-text">练习题</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">堂主</span>

  
    <div class="powered-by">
        <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
          本站访客数:<span id="busuanzi_value_site_uv"></span>
        </span>
    </div>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">74.1k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'FTvPdsu2TK6x3E711x6QpQJD-gzGzoHsz',
        appKey: 'xPDqtHbApNKoxM9CeFc5bbUU',
        placeholder: '留言',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
    
  </script>

  

  

  

  

</body>
</html>
